---
category: [系统]
tags: [编程, 電子]
title: Lua 应用
date: 2025-08-23 1:00:00
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
    text-align: center;
  }
  td.left {
    vertical-align: center;
    text-align: left;
  }  
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
  }
</style>

# Lua 代码结构

![Alt X](../assets/img/lua/luaset.png)

## 虚拟机核心功能部分

|文件|作用|
|:---:|:---:|
|lua.c|lua的可执行入口 main函数|
|lapi.c	|C语言接口|
|ldebug.c|Debug 接口 |
|ldo.c|函数调用以及栈管理 |
|lfunc.c |函数原型及闭包管理 |
|lgc.c|垃圾回收机制|
|lmem.c |内存管理接口|
|lobject.c|对象操作函数|
|lopcodes.c|虚拟机字节码定义|
|lstate.c|全局状态机 管理全局信息|
|lstring.c|字符串池 |
|ltable.c|表类型的相关操作 |
|ltm.c|元方法 |
|lvm.c|虚拟机 |
|lzio.c |输入流接口|


## 源代码解析和预编译

|文件	|作用|
|:---:|:---:|
|lcode.c	|代码生成器 |
|ldump.c|序列化预编译的Lua 字节码 |
|llex.c|词法分析器 |
|lparser.c|解析器|
|lundump.c|还原预编译的字节码|

## 内置的库

|文件|作用|
|:---:|:---:|
|lauxlib.c|库编写用到的辅助函数库 |
|lbaselib.c|基础库 |
|ldblib.c|Debug 库 |
|linit.c|内嵌库的初始化 |
|liolib.c|IO 库 |
|lmathlib.c|数学库 |
|loadlib.c|动态扩展库管理 |
|loslib.c|OS 库 |
|lstrlib.c|字符串库 |
|ltablib.c|表处理库|


要编写一个 main.c，在main.c 中需要加入 lua.h、lualib.h、lauxlib.h 头文件。程序主要是建立一个 Lua 的栈，然后在栈上设置数据，继续从栈上获取数据和出栈操作，最后关闭栈。


要将 main.c 文件编译成二进制可执行文件。其中编译参数中，需要带上 -l lua，将 lua 库作为静态库编译到的工程中去。 **-llua  -lm -ldl** ：加载 lua库、数据库和 dl 库等。


# Lua 的扩展库

编写有三种方式：

## 注册方式扩展

注册方式在主体语言里面编写扩展函数，然后通过 lua_register 方式，注册到 Lua 全局注册表中
扩展库编写
  - 注册方式示例，在 C 语言中，定义一个 my_func 函数，入参为 lua_State *L，函数内容将一个数字加上100。然后调用 lua_register 函数，将 my_func 函数注册到 Lua 栈的全局注册表中。当 Lua 语言中，遇到这个注册的 C 语言全局函数的时候，就会执行该函数。


```c
＃include ＜stdio.h＞
＃include ＜stdlib.h＞
＃include ＜math.h＞
＃include ＜lua.h＞
＃include ＜lualib.h＞
＃include ＜lauxlib.h＞

// 自定义一个 Lua 扩展函数
static int my_func(lua_State ＊L){
  int d = lual_checkinteger(L, 1);
  lua_pushinteger(L, d ＋ 100); 
  return 1;
}
  
int main(){
// 初始化一个栈
  lua_State ＊L = luaL_newstate();
  luaL_openlibs(L);

  lua_pushstring(L, "Lua API");
  lua_pushstring(L, "Hello Lua");
  int size = lua_gettop(L);
  printf("栈个数:％i\n", size);
// 注册函数
  lua_register(L, "my_func", my_func);
// 文件加载方式
  luaL_loadfile(L, "test.lua");
  int size2 = lua_gettop(L);
  printf("加载文件后，栈个数:％i\n", size2);
// 执行文件  
  lua_pcall(L, 0, 0, 0);
// 关闭栈
  lua_close(L);
return 0;
```

lua 脚本

```lua
--test. lua
print(＂luaL_loadfile: 执行文件加载的 Lua 脚本！＂)；
print(＂自定义函数调用：＂ .. my_func(100))；
```

编译并执行

```sh
＄ gcc main. c -o main -l lua
＄ ./main
栈个数：2
加载文件后，栈个数：3
luaL_loadfile:执行文件加载的Lua脚本！
自定义函数调用：200
```

## Lua 语言本身的扩展

按照 Lua 语言本身的扩展库设计方式进行编写动态库加载方式


  - 编写一个独立的扩展库文件，需要包含三个维度内容：
    - 扩展函数：自定义一个扩展函数，为lua_State 对象，函数如果要获取外部参数，则从 Lua 的栈上获取。扩展函数默认返回 1，则执行成功。
    - 配置数组：主要定义函数名称和扩展库中函数的映射关系。函数名称即为 Lua 语言中可以回调的函数。
    - 模块配置：定义一个以 luaopen_* 开头的函数，内部调用 luaL_newlib 函数实现模块的初始化。一般 Lua 中使用：模块名称.函数名称。

```c
＃define lmylib_c
＃define LUA LIB
＃include ＜stdio. h＞
＃include ＜stdlib.h＞
＃include ＜math. h＞
＃include ＜stdarg. h＞
＃include "lprefix.h"
＃include "lua.h"
＃include "lualib.h"
＃include "lauxlib.h"

// lua_State ＊L 返回 1 则函数执行成功
// 通过 luaL_checkinteger 获取
static int mylib_number(lua_State ＊L){
  int d = luaL_checkinteger(L，1);
  // 获取参数
  lua_pushinteger(L， d ＋ 100);
  // push result
  return 1；
}

static const struct luaL_Reg mylibi[] = {
  {"mylib_number", mylib_number};
  {NULL, NULL}
}

// mylib = 模块名称，luaL_newlib 初始化模块
extern int luaopen_mylib(lua_State＊ L){
  luaL_newlib(L， mylib);
  return 1;
}
```

添加了模块后，需要修改 Lua 的其它两个文件：

 - lualib.h 文件：添加 LUA_MYLIBNAME 和 LUAMOD_API
 - linit.c 文件：添加 {LUA_MYLIBNAME, luaopen_mylib}


标准的扩展库，需要将扩展库直接编译进 Lua 源码里面，并且需要修改 lualib.h 和 linit.c 文件，对于集群线上大批量部署 Lua 语言，会造成巨大的困难。
因此这方法不建议使用。所以不再详细介绍。


## 动态库加载

将扩展库编译成 **.so** 的动态库，Lua 语言中通过 **require** 方式动态加载库文件。



Lua 可以通过 requre 方式动态加载扩展库，所以可以将扩展库编译成 **.so** 的文件，就可以实现动态加载方式。

动态库和静态库的区别：

 - 静态库：在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。
 - 动态库：在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。


```c
#include <stdio. h>
#include <stdlib. h>
#include <math. h>
#include <stdarg.h>

#include <lua. h>
#include <lualib.h>
#include <lauxlib. h>

int luaopen_mylibi(lua_State *L);

static int add(lua_State *L){
  int d =  luaL_checkinteger(L, 1);
  lua_pushinteger(L, d + 100);
  return 1;
}

static const struct luaL_Reg mylibi[] = {
  {"add", add},
  {NULL, NULL}
}

extern int luaopen_mylibi(lua_State* L){
  luaL_newlib(L, mylibi);
  return 1;
}
```

lua 脚本

```lua
-- 动态加载 mylibi
local mylibi ＝ require("mylibi"); 
-- 调用 mylibi.add 函数
print(mylibi.add(1024));1
```


编译并执行

```sh
$ gcc mylibi.c -fPIC -shared -o mylibi.so
＄ ./main
栈个数：2
加载文件后，栈个数：3
luaL_loadfile:执行文件加载的Lua脚本！
自定义函数调用：1124
```

注意：Linux 系统下的 **so** 编译文件。编译完成后，mylibi.so 和 Lua 执行脚本同一个目录下。


