---
category: [數學]
tags: [動畫, 編程]
title: Android XML
date: 2022-10-22 1:00:00
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
    text-align: center;
  }
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
</style>

# Android 佈局

## 以編程方式做佈局

```java
Button btn = (Button) findViewById(R.id.mybutton);

btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        addWord(v);
    }
});

```

## 以 XML 方式做佈局

文件存儲在佈局文件夾 *layout* 中，名稱為: *activity_main*

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:layout_width="fill_parent"
  android:layout_height="fill_parent"
  android:orientation="vertical" >

  <TextView android:id="@+id/text"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="This is a TextView" />

  <Button android:id="@+id/button"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="This is a Button" />

</LinearLayout>
```

使用程序激活佈局

```java
setContentView(R.layout.activity_main);
```

## 佈局中的項目激活方法

```xml
<Button android:id="@+id/button"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="This is a Button"
    android:onClick="addWord" />
```

在 *XML* 中點擊動作設置為 *addWord*

```java
public void addWord(View v) {
    // 主程序中是否需要任務
}
```

## 在其他類中調用 UI *用戶界面* 線程

### 使用 **Handler**

```java
final Handler mHandler = new Handler(mMainActivity.getAplicationContext().getMainLooper());
final Runnable mRunnable = new Runnable(){
    @override
    public void run(){
      UI Thread
    }
};
mHandler(mRunnable);
```

### 使用 **runOnUiThread**

```java
runOnUiThread(new Runnable(){
    @override
    public void run(){
      UI Thread
    }
});
```
## 佈局動態更改方法

Android 中的每個可見組件都是一個 View 視圖。 這包括 Button、Spinner、TextView、EditText 等。 程序中的 XML 文件定義被編譯為視圖，常用方法是使用 setContentView() 方法。其實 setContentView() 方法的內部也是使用 LayoutInflater 來加載佈局的，只不過這部分源碼是內部的不容易查看到。

LayoutInflater 可以用來編譯佈局再動態地整合到已有的視圖中。

獲取 LayoutInflater 的三種方式:

第一種方式
```java
LayoutInflater inflater = getLayoutInflater();
```

第二種方式
```java
LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
```

第三種方式
```java
LayoutInflater inflater = LayoutInflater.from(context);
```


inflate 為 LayoutInflater 的方法用以編譯視圖部份。inflate() 方法一般接收兩個參數，第一個參數就是要加載的佈局 ID，第二個參數是指給該佈局的外部再嵌套一層父佈局，如果不需要就直接傳 null。這樣就成功成功創建了一個佈局的實例，之後再將它添加到指定的位置就可以顯示出來了。

MainActivity 對應的佈局文件叫做 activity_main.xml

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/main_layout"
  android:layout_width="match_parent"
  android:layout_height="match_parent" >
</LinearLayout>
```

接下來再定義一個佈局文件，名為button_layout.xml

```xml
<Button xmlns:android="http://schemas.android.com/apk/res/android"
  android:layout_width="wrap_content"
  android:layout_height="wrap_content"
  android:text="Button" >
</Button>
```

這個佈局文件非常簡單，只有一個 Button 按鈕而已。現在我們要 LayoutInflater 來將 button_layout 這個佈局添加到主佈局文件的 LinearLayout 中。

```java
public class MainActivity extends Activity {
  private LinearLayout mainLayout;
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    mainLayout = (LinearLayout) findViewById(R.id.main_layout);
    LayoutInflater layoutInflater = LayoutInflater.from(this);
    View buttonLayout = layoutInflater.inflate(R.layout.button_layout, null);
    mainLayout.addView(buttonLayout);
 }
}
```

先是獲取 LayoutInflater 的實例，然後調用它的 inflate() 方法來加載 button_layout 這個佈局，最後調用 LinearLayout 的 addView() 方法將它添加到LinearLayout 中。LayoutInflater 技術廣泛應用於需要動態添加 View 的時候。


inflate() 方法還有個接收三個參數的方法重載，結構如下:

```java
public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot);
```

|root|attachToRoot|描述|使用方法|問題|
|:---:|:---:|:---|:---|:--:|
|null|失去作用|設置任何值都沒有意義|用 addView，如上例但可能會表現異常|有機會異常|
|不為 null|false|需要這個父元素的 LayoutParams 來在將來添加時決定佈局文件最外層的所有 layout 屬性|用 addView 將項目添加到視圖|安全|
|不為 null|true|會給加載的佈局文件的指定一個父佈局|已添加如下示例|安全|
|不為 null|-|不設置attachToRoot參數的情況下默認為 true|已添加如下示例|安全|


```java
public class MainActivity extends Activity {
  private LinearLayout mainLayout;
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    mainLayout = (LinearLayout) findViewById(R.id.main_layout);
    LayoutInflater layoutInflater = LayoutInflater.from(this);
    View buttonLayout = layoutInflater.inflate(R.layout.button_layout, mainLayout, true);
  }
}
```

如果沒有外部佈局 layout_width 和 layout_height 的值修改成多少，都不會有任何效果的，因為這兩個值現在已經完全失去了作用。平時經常使用 layout_width 和 layout_height 來設置 View 的大小，並且能正常工作，就像這兩個屬性確實是用於設置 View 的大小的。而實際上則不然，它們其實是用於設置 View 在佈局中的大小的，也就是說，首先 View 必須存在於一個佈局中，之後如果將 layout_width 設置成 match_parent 表示讓 View 的寬度填充滿佈局，如果設置成 wrap_content 表示讓 View 的寬度剛好可以包含其內容，如果設置成具體的數值則 View 的寬度會變成相應的數值。這也是為什麼這兩個屬性叫作 layout_width 和 layout_height，而不是width 和 height。

但對於 Button 這個控件不存在於任何佈局當中，所以 layout_width 和 layout_height 這兩個屬性理所當然沒有任何作用。那麼怎樣修改才能讓按鈕的大小改變呢？解決方法其實有很多種，最簡單的方式就是在 Button 的外面再嵌套一層佈局。如下:

```xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:layout_width="match_parent"
  android:layout_height="match_parent" >
  <Button
    android:layout_width="300dp"
    android:layout_height="80dp"
    android:text="Button" >
  </Button>
</RelativeLayout>
```

### setContentView 和 inflate 區別：

setContentView() 一旦調用, layout就會立刻顯示 UI；而 inflate 只會把 Layout 形成一個以 View 類實現成的對象，有需要時再用 setContentView(view) 顯示出來。

# Thread，Looper 和 Handler 的關係

Android 是消息驅動型的系統。實現對應的消息驅動機制的四要素：

 - 接收消息的“消息隊列” ——【MessageQueue】
 - 阻塞式地從消息隊列中接收消息並進行處理的“線程” ——【Thread+Looper】
 - 可發送的“消息的格式” ——【Message】
 - “消息發送函數”——【Handler的post和sendMessage】


## Looper

一個Looper類似一個消息泵。它本身是一個死循環，不斷地從 MessageQueue 中提取 Message 或者 Runnable。而 Handler 可以看做是一個 Looper 的暴露接口，向外部暴露一些事件，並暴露 sendMessage() 和 post() 函數。

除了 UI 線程 / 主線程以外，普通的線程是不自帶 Looper 的。想要通過 UI 線程與子線程通信需要在子線程內自己實現一個 Looper 。開啟 Looper 分三步走：

 - 判定是否已有Looper並Looper.prepare()
 - 做一些準備工作(如暴露handler等)
 - 調用Looper.loop()，線程進入阻塞態

示例如下:

```java
class LooperThread extends Thread {
    public Handler mHandler;
    public void run() {
        Looper.prepare();
        mHandler = new Handler() {
            public void handleMessage(Message msg) {
                // 在此處處理傳入的消息
            }
        };
        Looper.loop();
    }
}
```

## Handler 和 Runnable

handler可以分發 Message 對象和 Runnable 對像到主線程中， 每個 Handler 實例，都會綁定到創建他的線程中(一般是位於主線程)，它有兩個作用:

(1) 安排消息或 Runnable 在某個主線程中某個地方執行，
(2) 安排一個動作在不同的線程中執行

Handler中分發消息的一些方法
*主線程隊列*
  post(Runnable)
  postAtTime(Runnable,long)
  postDelayed(Runnable long)
*Message 對像到隊列*
  sendEmptyMessage(int)
  sendMessage(Message)
  sendMessageAtTime(Message,long)
  sendMessageDelayed(Message,long)

 以上 post 類方法允許你排列一個 Runnable 對像到 *主線程隊列* 中，sendMessage 類方法，允許你安排一個帶數據的 *Message 對像到隊列* 中，等待更新。

```java
private void initUtils() {
    Handler mMainHandler = new Handler(Looper.getMainLooper());
    mMainHandler.postDelayed(new Runnable() {
        @Override
        public void run() {
            // 在此處做你需要的事
        }
    }, 1500);
}
```
