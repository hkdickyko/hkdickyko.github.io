---
category: [MPU]
tags: [IoT, 编程]
title: 九轴传感器
date: 2025-11-08 1:00:00
---

<style>
  table {
    width: 100%
    }
  td.left {
    vertical-align: center;
    text-align: left;
    width: 30%;
  }
  td {
    vertical-align: center;
    text-align: center;
  }
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  tr:nth-child(even){
    background-color:#ffffe5;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
  }
  
</style>

<script src="../assets/plugin/mermaid.min.js"></script>


# 九轴传感器

IMU20948技术特性

|量程参数|规格|技术优势|
|:---:|:---:|:---:|
|加速度|±2g/±4g/±8g/±16g|16位ADC，0.98mg/LSB@±16g|
|陀螺仪|±250/±500/±1000/±2000 dps|0.0038°/s/LSB@±250dps|
|磁力计|±4900μT|16位分辨率，0.15μT/LSB|

## 芯片内部采用三层堆叠结构

 - MEMS传感层：包含三轴加速度计和陀螺仪
 - ASIC处理层：集成数字运动处理器(DMP)
 - 磁力计层：AK09916磁力计通过I2C从接口连接


## 九轴数据融合原理


**传感器融合算法**

$$
姿态矩阵=加速度计校准 \times 陀螺仪积分 \times 磁力计补偿
$$


**典型算法对比**


|算法|计算复杂度|精度|适用场景|
|:---:|:---:|:---:|:---:|
|互补滤波|低|一般|低速运动|
|卡尔曼滤波|高|高|动态环境|
|Mahony|中等|较高|嵌入式系统|


## 校准验证代码

```c
x-bias = 1000*IMU.accelBiasX; 
y-bias = 1000*IMU.accelBiasY;
z-bias = 1000*IMU.accelBiasZ;
```

 - 将加速度偏置转换为 mg 单位 (1g = 1000mg)
 - X / Y 轴偏置应 < 50mg，Z 轴接近  <font color="#FF1000">0</font> (理想值)
 - 确保校准过程有效，避免硬件安装误差

## 动态零位补偿

```c
static int calibration_cnt = 0;
if(calibration_cnt < 1000 && abs(IMU.gx)<0.5 && abs(IMU.gy)<0.5) {
  IMU.accelBiasX += IMU.ax * 0.001;
  IMU.accelBiasY += IMU.ay * 0.001;
  calibration_cnt++;
}
```

 - 前 1000 次采样持续修正加速度偏置
 - 0.001 为学习率系数，控制校准速度
 - 实现动态自适应，消除温度漂移影响


# 传感器数据预处理 

## 加速度计处理

```c
IMU.ax = (float) IMU.accelCountX * IMU.aRes - IMU.accelBiasX;
IMU.ay = (float) IMU.accelCountY * IMU.aRes - IMU.accelBiasY;
IMU.az = (float) IMU.accelCountZ * IMU.aRes - IMU.accelBiasZ;
```

**数据处理流程**
 - accelCount：原始 ADC 值
 - aRes 为分辨率计算(例如 ±16g 量程时为 2048 LSB/g)
 - 减去校准偏置消除零位误差

**关键参数**

 - 量程设置：建议初始化时配置为 ±8g
 - 分辨率公式：aRes = 16.0 / 32768.0  (16位ADC)

## 陀螺仪处理


```c
IMU.gx = (float) IMU.gyroCountX * IMU.gRes - IMU.gyroBiasX;
IMU.gy = (float) IMU.gyroCountY * IMU.gRes - IMU.gyroBiasY; 
IMU.gz = (float) IMU.gyroCountZ * IMU.gRes - IMU.gyroBiasZ;
```

**漂移控制**

 - 典型偏置值应 < 1°/s
 - 温度每升高 1℃，零偏变化约 0.01°/s
 - 改进建议，可添加温度补偿函数



## 磁力计数据融合


```c
// 注意： X / Y 轴需要交换
float mx_raw = (float) IMU.magCountY * IMU.mRes;
float my_raw = (float) IMU.magCountX * IMU.mRes;
IMU.mx = (mx_raw - IMU.magBiasY) * IMU.magScaleY;
IMU.my = (my_raw - IMU.magBiasX) * IMU.magScaleX;

// Z 轴需要反转
float mz_raw = -(float) IMU.magCountZ * IMU.mRes; 
IMU.mz = (mz_raw - IMU.magBiasZ) * IMU.magScaleZ;
```

 - magBias 为硬铁干扰补偿
 - magScale 为软铁畸变校正
 - 注意校准数据需对应新坐标系


## 姿态解算核心算法

**Mahony 滤波器**

```c
MahonyQuaternionUpdate(
  IMU.ay,                // 加速度 Y → X
  IMU.ax,                // 加速度 X → Y 
  -IMU.az,               // 加速度 Z 反转
  IMU.gy * DEG_TO_RAD,   // 陀螺 Y → X
  IMU.gx * DEG_TO_RAD,   // 陀螺 X → Y
  -IMU.gz * DEG_TO_RAD,  // 陀螺 Z 反转
  IMU.mx, 
  IMU.my,
  IMU.mz,
  IMU.deltat
);
```

**欧拉角转换**

```c
IMU.yaw   = atan2(2.0f * (*(getQ()+1) * *(getQ()+2) + *getQ()
                    * *(getQ()+3)), *getQ() * *getQ() + *(getQ()+1)
                    * *(getQ()+1) - *(getQ()+2) * *(getQ()+2) - *(getQ()+3)
                    * *(getQ()+3));
IMU.pitch = -asin(2.0f * (*(getQ()+1) * *(getQ()+3) - *getQ()
                    * *(getQ()+2)));
IMU.roll  = atan2(2.0f * (*getQ() * *(getQ()+1) + *(getQ()+2)
                    * *(getQ()+3)), *getQ() * *getQ() - *(getQ()+1)
                    * *(getQ()+1) - *(getQ()+2) * *(getQ()+2) + *(getQ()+3)
                    * *(getQ()+3));
IMU.pitch *= RAD_TO_DEG;
IMU.yaw   *= RAD_TO_DEG;
 
      // Declination of SparkFun Electronics (40°05'26.6"N 105°11'05.9"W) is
      // 	8° 30' E  ± 0° 21' (or 8.5°) on 2016-07-19
      // - http://www.ngdc.noaa.gov/geomag-web/#declination
IMU.yaw  -= 8.5;
IMU.roll *= RAD_TO_DEG;
```




