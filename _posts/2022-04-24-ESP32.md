---
category: [編程]
tags: [IoT]
title: ESP 開發的軟件框架
date: 2022-04-23 06:00:00
---

# ESP32-C3

ESP32-C3 搭載 RISC-V 32 位單核處理器，工作頻率高達 160 MHz，模組支持 Wi-Fi。內置 400 KB SRAM，384 KB ROM，8KB RTC SRAM，內置 4MB Flash。

# 安裝 ESP-IDF

基本上所有類型的 ESP32 開發板也能用這個開發工具編譯。安裝方法如下。

[ESP-IDF 互聯網資源](https://github.com/espressif/esp-idf)

```shell
sudo apt-get install git wget flex bison gperf python3 python3-pip python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0
python3 --version
git clone --recursive https://github.com/espressif/esp-idf.git
cd ~/esp/esp-idf
./install.sh
source ./export.sh

```
# ESP32 程式模板

因 ESP32 開發版是基於模板程式，再由網上下載相關開發版的程式部份，步驟及下載部分詳列如下。

[ESP32 程式模板下載](https://github.com/espressif/esp-idf-template)

```shell
cd ~/esp
git clone --recursive https://github.com/espressif/esp-idf-template
mv esp-idf-template esp32c3

```
注意：<font color="#FF1000">esp32c3</font> 需要根據的情況進行更改


# 選擇安裝並編譯模板設置

如選擇安裝 ESP32-C3，則在 set-target 為 esp32c3 如下。
 - 第 1 行 轉到需要建構程式目錄
 - 第 2 行 將目錄設置為 shell 參數
 - 第 3 行 到 idf 的安裝目䤸
 - 前 4 行 更新 idf 的相關部份連接
 - 第 5 行 使用shell參數返回主程式目錄
 - 第 6 行 顯示 idf 版本，以確認 idf 安裝正常。
 - 第 7 行 下載相關開發版的指令
 - 第 8 行 編譯及燒錄程序到開發版
 - 第 9 行 監管執行程序的顯示資訊

```shell
# 編譯環境的基本設置
cd ~/需要建構程式目錄
curdir=$(pwd)
cd ~/esp/esp-idf
source ./export.sh
cd ${curdir}
idf.py --version

# 根據要求使用
idf.py set-target esp32c3
idf.py menuconfig


# 用 USB 線將 ESP32 開發板與 PC 連接； 
# 當刷機程式開始時，同時按下 RESET 和 BOOT 按鈕，然後先放開 RESET 按鈕，然後再放開 BOOT 按鈕。
# 刷機後軟體會辨識硬體。
# 燒錄文件到開發板
idf.py flash
idf.py monitor

```

如需要微調更新設定，可以執行以下命令. **idf.py menuconfig** 。 例如:添加 WiFi 連接 SSID 和密碼。

# 外圍連接安裝問題

 - 如果無法訪問 **ttyACM0** 以下命令將授予訪問權限

```shell
sudo adduser $USER dialout
sudo chmod a+rw /dev/ttyACM0

```

# 編譯並安裝全過程

 - 如果發現任何錯誤，可以執行以下命令. **idf.py menuconfig** 用於在 ESP32-C3 開發板上設置設置的命令

```shell
# 編譯環境的基本安裝
cd ~/需要建構程式目錄
curdir=$(pwd)
rm -rf build
idf.py fullclean
rm -rf `find -name CMakeCache.txt`
cd ~/esp/esp-idf
./install.sh
source ./export.sh
cd ${curdir}
idf.py --version

# 根據要求使用
idf.py set-target esp32c3
idf.py menuconfig

# 用 USB 線將 ESP32 開發板與 PC 連接； 
# 當刷機程式開始時，同時按下 RESET 和 BOOT 按鈕，然後先放開 RESET 按鈕，然後再放開 BOOT 按鈕。
# 刷機後軟體會辨識硬體。
# 燒錄文件到開發板
idf.py build
idf.py flash
idf.py monitor

```
注意：<font color="#FF1000">esp32c3</font> 需要根據的情況進行更改

# extra.h
```c
#include <driver/gpio.h>
#include <esp_spiffs.h>

// 網絡服務器
void setTime();
void wifi_init_sta();
void httpCall(httpd_handle_t *server);
void connect_handler(void *arg, esp_event_base_t event_base, int32_t event_id,
                     void *event_data);
void disconnect_handler(void *arg, esp_event_base_t event_base,
                        int32_t event_id, void *event_data);
void stop_webserver(httpd_handle_t server);
char *getIP(int port);
char *getUrlStr(httpd_req_t *req);
char *http_get_task(const char *webServer, char *port, const char *webPath);
httpd_handle_t start_webserver();

// 文件讀/寫
void spiffsClose(esp_vfs_spiffs_conf_t conf);
char *list(const char *path, const char *match, const char *partition_Name);
bool fileCreate(char *fileName_Path, char *content);
bool fileAppend(char *fileName_Path, char *content);
int fileSize(const char *fileName_Path);
char *fileRead(const char *fileName_Path);
esp_vfs_spiffs_conf_t spiffsInit(char *path, char *partition_Name);

// 字符串修改
void removeChar(char *str, char charToRemmove);
int findStr(const char *src, const char *str, int offset);
char *subStr(const char *source, int pos0, int pos1);
char *replaceStr(const char *src, const char *oldW, const char *newW);
char *trimStr(char *str);
char *extractStr(const char *src, const char *startStr, char *endStr);
char *replaceHtml(char *html, char *newStr, char *firstStr, char *lastStr);

// 外圍設備输入输出端口
void initGPIO();
int setGPIO(gpio_num_t GPIO_PIN, bool onFalg);
esp_err_t i2c_Init(uint8_t i2cAddr, int scl, int sda, int speed, uint8_t port, int timeout);
esp_err_t i2c_ReadBytes(uint8_t rAddr, uint8_t *buf, int len);
esp_err_t i2c_WriteBytes(uint8_t wAddr, uint8_t *data, int length);

// AHT10
int AHT10(float *temperature, float *humidity);

// MQTT
void initPublish(int topicSize);
void publish(char *topic, char *content, int qos);
void mqtt_IP();

```

# 外圍設備输入输出端口 peripherals.c

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/queue.h>

#include <esp_log.h>
#include <driver/gpio.h>
#include <driver/i2c.h>

// --- GPIO -------------------------------------------
void initGPIO()
{
  gpio_config_t io_conf = {};
  io_conf.intr_type = GPIO_INTR_DISABLE;
  io_conf.mode = GPIO_MODE_OUTPUT;
  io_conf.pin_bit_mask = ((1ULL << 12) | (1ULL << 13));
  io_conf.pull_down_en = 0;
  io_conf.pull_up_en = 0;
  gpio_config(&io_conf);
}

int setGPIO(gpio_num_t GPIO_PIN, bool onFalg)
{
  if (onFalg)
  {
    gpio_set_level(GPIO_PIN, 1);
    return 1;
  }
  else
  {
    gpio_set_level(GPIO_PIN, 0);
    return 0;
  }
}

//--- i2C -------------------------------------------
static int i2c_master_port;
static uint8_t i2c_device;
static int i2c_timeout;

esp_err_t i2c_ReadBytes(uint8_t rAddr, uint8_t *buf, int len)
{
  return i2c_master_write_read_device(i2c_master_port, i2c_device, &rAddr, 1, buf, len, i2c_timeout / portTICK_PERIOD_MS);
}

esp_err_t i2c_WriteBytes(uint8_t wAddr, uint8_t *data, int length)
{
  uint8_t write_buf[length + 1];
  write_buf[0] = wAddr;
  for (int i = 0; i < length; i++)
    write_buf[i + 1] = data[i];
  return i2c_master_write_to_device(i2c_master_port, i2c_device, write_buf, sizeof(write_buf), i2c_timeout / portTICK_PERIOD_MS);
}

esp_err_t i2c_Init(uint8_t i2cAddr, int scl, int sda, int speed, uint8_t port, int timeout)
{
  i2c_device = i2cAddr;
  i2c_master_port = port;
  i2c_timeout = timeout;
  i2c_config_t conf = {
      .mode = I2C_MODE_MASTER,
      .sda_io_num = sda,
      .scl_io_num = scl,
      .sda_pullup_en = GPIO_PULLUP_ENABLE,
      .scl_pullup_en = GPIO_PULLUP_ENABLE,
      .master.clk_speed = speed,
  };
  i2c_param_config(i2c_master_port, &conf);
  return i2c_driver_install(i2c_master_port, conf.mode, 0, 0, 0);
}

// --- AHT10 -------------------------------------------
int AHT10(float *temperature, float *humidity)
{
  uint8_t i2cAddr_W = i2c_device << 1 | 0;
  uint8_t i2cAddr_R = i2c_device << 1 | 1;
  uint8_t datar[1] = {0xBA};
  uint8_t datai[3] = {0xE1, 0x08, 0x00};
  uint8_t datam[3] = {0xAC, 0x33, 0x00};
  uint8_t buf[6] = {0, 0, 0, 0, 0, 0};

  i2c_Init(0x38, 5, 4, 400000, 0, 1000);
  vTaskDelay(10);
  i2c_WriteBytes(i2cAddr_W, datar, 1);
  vTaskDelay(100);
  i2c_WriteBytes(i2cAddr_W, datai, 3);
  vTaskDelay(175);
  i2c_WriteBytes(i2cAddr_W, datam, 3);
  vTaskDelay(75);
  i2c_ReadBytes(i2cAddr_R, buf, 6);

  if ((buf[0] & 0x68) == 0x08)
  {
    int H1 = buf[1];
    H1 = (H1 << 8) | buf[2];
    H1 = (H1 << 8) | buf[3];
    H1 = H1 >> 4;
    H1 = (H1 * 1000) / 1024 / 1024;
    int T1 = buf[3];
    T1 = T1 & 0x0000000F;
    T1 = (T1 << 8) | buf[4];
    T1 = (T1 << 8) | buf[5];
    T1 = (T1 * 2000) / 1024 / 1024 - 500;
    *temperature = T1 / 10.0;
    *humidity = H1 / 10.0;
  }
  else
  {
    return -1;
  }
  i2c_driver_delete(i2c_master_port);
  return 0;
}

```

# 文件讀/寫, 字符串修改 fileIO.c

```c
#include <stdio.h>
#include <string.h>
#include <sys/unistd.h>
#include <sys/stat.h>
#include <esp_vfs.h>
#include <esp_err.h>
#include <esp_log.h>
#include <esp_spiffs.h>

#include <freertos/FreeRTOS.h>
#include <freertos/event_groups.h>
#include <freertos/task.h>
#include <string.h>
#include <sys/time.h>
#include <errno.h>
#include <sys/fcntl.h>
#include <unistd.h>
#include <ctype.h>

#include <esp_event.h>
#include <esp_event_loop.h>
#include <esp_attr.h>
#include <esp_system.h>
#include <esp_attr.h>

// ============================================================================

// fnmatch defines
#define FNM_NOMATCH 1        // Match failed.
#define FNM_NOESCAPE 0x01    // Disable backslash escaping.
#define FNM_PATHNAME 0x02    // Slash must be matched by slash.
#define FNM_PERIOD 0x04      // Period must be matched by period.
#define FNM_LEADING_DIR 0x08 // Ignore /<tail> after Imatch.
#define FNM_CASEFOLD 0x10    // Case insensitive search.
#define FNM_PREFIX_DIRS 0x20 // Directory prefixes of pattern match too.
#define EOS '\0'

//-----------------------------------------------------------------------
static const char *rangematch(const char *pattern, char test, int flags)
{
  int negate, ok;
  char c, c2;

  if ((negate = (*pattern == '!' || *pattern == '^')))
    ++pattern;

  if (flags & FNM_CASEFOLD)
    test = tolower((unsigned char)test);

  for (ok = 0; (c = *pattern++) != ']';)
  {
    if (c == '\\' && !(flags & FNM_NOESCAPE))
      c = *pattern++;
    if (c == EOS)
      return (NULL);

    if (flags & FNM_CASEFOLD)
      c = tolower((unsigned char)c);

    if (*pattern == '-' && (c2 = *(pattern + 1)) != EOS && c2 != ']')
    {
      pattern += 2;
      if (c2 == '\\' && !(flags & FNM_NOESCAPE))
        c2 = *pattern++;
      if (c2 == EOS)
        return (NULL);

      if (flags & FNM_CASEFOLD)
        c2 = tolower((unsigned char)c2);

      if ((unsigned char)c <= (unsigned char)test &&
          (unsigned char)test <= (unsigned char)c2)
        ok = 1;
    }
    else if (c == test)
      ok = 1;
  }
  return (ok == negate ? NULL : pattern);
}

//--------------------------------------------------------------------
static int fnmatch(const char *pattern, const char *string, int flags)
{
  const char *stringstart;
  char c, test;

  for (stringstart = string;;)
    switch (c = *pattern++)
    {
    case EOS:
      if ((flags & FNM_LEADING_DIR) && *string == '/')
        return (0);
      return (*string == EOS ? 0 : FNM_NOMATCH);
    case '?':
      if (*string == EOS)
        return (FNM_NOMATCH);
      if (*string == '/' && (flags & FNM_PATHNAME))
        return (FNM_NOMATCH);
      if (*string == '.' && (flags & FNM_PERIOD) &&
          (string == stringstart ||
           ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
        return (FNM_NOMATCH);
      ++string;
      break;
    case '*':
      c = *pattern;
      while (c == '*')
        c = *++pattern;

      if (*string == '.' && (flags & FNM_PERIOD) &&
          (string == stringstart ||
           ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
        return (FNM_NOMATCH);

      if (c == EOS)
        if (flags & FNM_PATHNAME)
          return ((flags & FNM_LEADING_DIR) ||
                          strchr(string, '/') == NULL
                      ? 0
                      : FNM_NOMATCH);
        else
          return (0);
      else if ((c == '/') && (flags & FNM_PATHNAME))
      {
        if ((string = strchr(string, '/')) == NULL)
          return (FNM_NOMATCH);
        break;
      }

      while ((test = *string) != EOS)
      {
        if (!fnmatch(pattern, string, flags & ~FNM_PERIOD))
          return (0);
        if ((test == '/') && (flags & FNM_PATHNAME))
          break;
        ++string;
      }
      return (FNM_NOMATCH);
    case '[':
      if (*string == EOS)
        return (FNM_NOMATCH);
      if ((*string == '/') && (flags & FNM_PATHNAME))
        return (FNM_NOMATCH);
      if ((pattern = rangematch(pattern, *string, flags)) == NULL)
        return (FNM_NOMATCH);
      ++string;
      break;
    case '\\':
      if (!(flags & FNM_NOESCAPE))
      {
        if ((c = *pattern++) == EOS)
        {
          c = '\\';
          --pattern;
        }
      }
      break;
    default:
      if (c == *string)
      {
      }
      else if ((flags & FNM_CASEFOLD) && (tolower((unsigned char)c) == tolower((unsigned char)*string)))
      {
      }
      else if ((flags & FNM_PREFIX_DIRS) && *string == EOS && ((c == '/' && string != stringstart) || (string == stringstart + 1 && *stringstart == '/')))
        return (0);
      else
        return (FNM_NOMATCH);
      string++;
      break;
    }
  return 0;
}

char *list(const char *path, const char *match, const char *partition_Name)
{
  DIR *dir = NULL;
  struct dirent *ent;
  char type[8];
  char size[9];
  char tpath[255];
  char tbuffer[80];
  struct stat sb;
  struct tm *tm_info;
  char *lpath = NULL;
  int statok;
  char *strValue = (char *)malloc(sizeof(char) * 2048);
  sprintf(strValue, "[");
  int n = strlen(strValue);
  char tmpValue[256];
  dir = opendir(path);
  if (!dir)
  {
    printf("Error opening directory\n");
    return NULL;
  }
  size_t tot = 0, used = 0;
  esp_spiffs_info(partition_Name, &tot, &used);
  tot = tot / 1024;
  used = used / 1024;
  int freeUsed = tot - used;
  sprintf(tmpValue, "{'檔案類型':'總結','檔案名稱':'可用內存 / 總內存','檔案大小':'%d / %d KB','日期/時間':'-'}]\0", freeUsed, tot);
  uint64_t total = 0;
  int strTotal = 0;
  int nfiles = 0;
  while ((ent = readdir(dir)) != NULL)
  {
    sprintf(tpath, path);
    if (path[strlen(path) - 1] != '/')
      strcat(tpath, "/");
    strcat(tpath, ent->d_name);
    tbuffer[0] = '\0';
    if ((match == NULL) || (fnmatch(match, tpath, (FNM_PERIOD)) == 0))
    {
      statok = stat(tpath, &sb);
      if (statok == 0)
      {
        tm_info = localtime(&sb.st_mtime);
        strftime(tbuffer, 80, "%d/%m/%Y %R", tm_info);
      }
      else
        sprintf(tbuffer, "-");
      if (ent->d_type == DT_REG)
      {
        sprintf(type, "%s", "檔案");
        nfiles++;
        if (statok)
          strcpy(size, "?");
        else
        {
          total += sb.st_size;
          if (sb.st_size < (1024 * 1024))
            sprintf(size, "%d", (int)sb.st_size);
          else if ((sb.st_size / 1024) < (1024 * 1024))
            sprintf(size, "%d KB", (int)(sb.st_size / 1024));
          else
            sprintf(size, "%d MB", (int)(sb.st_size / (1024 * 1024)));
        }
      }
      else
      {
        sprintf(type, "%s", "目錄");
        strcpy(size, "-");
      }
      if (n < strTotal - 256)
      {
        strValue = (char *)realloc(strValue, sizeof(char) * (strTotal + 256));
        strTotal = strTotal + 256;
      }
      sprintf(strValue + n, "{'檔案類型':'%s','檔案名稱':'%s','檔案大小':'%s','日期/時間':'%s'},", type, ent->d_name, size, tbuffer);
    }
    n = strlen(strValue);
  }
  strTotal = strlen(strValue) + strlen(tmpValue) + 2;
  strValue = (char *)realloc(strValue, sizeof(char) * strTotal);
  sprintf(strValue + n, "%s\0", tmpValue);
  closedir(dir);
  free(lpath);
  return strValue;
}

bool fileCreate(char *fileName_Path, char *content)
{
  FILE *f = fopen(fileName_Path, "w");
  if (f != NULL)
  {
    fprintf(f, content);
    fclose(f);
    return true;
  }
  printf("File ( %s ) create failed.\n", fileName_Path);
  return false;
}

bool fileAppend(char *fileName_Path, char *content)
{
  FILE *f = fopen(fileName_Path, "a");
  if (f != NULL)
  {
    fprintf(f, content);
    fclose(f);
    return true;
  }
  printf("File ( %s ) append failed.\n", fileName_Path);
  return false;
}

int fileSize(const char *fileName_Path)
{
  struct stat st;
  stat(fileName_Path, &st);
  return (int)st.st_size;
}

char *fileRead(const char *fileName_Path)
{
  int n = fileSize(fileName_Path) + 1;
  char *content = malloc(n * sizeof(char));
  FILE *f = fopen(fileName_Path, "r");
  if (f != NULL)
  {
    char line[256];
    int i = 0, total = 0;
    while (fgets(line, sizeof(line), f))
    {
      total = strlen(line);
      memcpy(&(content[i]), line, strlen(line));
      i = i + total;
    }
    content[i] = '\0';
    fclose(f);
    return content;
  }
  printf("File ( %s ) read failed.\n", fileName_Path);
  return NULL;
}

esp_vfs_spiffs_conf_t spiffsInit(char *path, char *partition_Name)
{
  esp_vfs_spiffs_conf_t conf = {
      .base_path = path,
      .partition_label = partition_Name,
      .max_files = 5,
      .format_if_mount_failed = false};
  esp_err_t ret = esp_vfs_spiffs_register(&conf);
  if (ret != ESP_OK)
  {
    printf("Failed to initialize SPIFFS (%s)", esp_err_to_name(ret));
  }
  else
  {
    size_t total = 0, used = 0;
    ret = esp_spiffs_info(conf.partition_label, &total, &used);
    if (ret != ESP_OK)
    {
      printf("Failed to get SPIFFS partition information (%s)", esp_err_to_name(ret));
    }
    else
    {
      printf(" ---> SPIFFS: free %d KB of %d KB\n", (total - used) / 1024, total / 1024);
    }
  }
  return conf;
}

void spiffsClose(esp_vfs_spiffs_conf_t conf)
{
  esp_vfs_spiffs_unregister(conf.partition_label);
  printf(" ---> SPIFFS unmounted.\n");
}

char *subStr(const char *source, int pos0, int pos1)
{
  int n = pos1 - pos0;
  char *destination = malloc(sizeof(char) * n + 1);
  strncpy(destination, source + pos0, n);
  return destination;
}

void removeChar(char *str, char charToRemmove)
{
  int i, j;
  int len = strlen(str);
  for (i = 0; i < len; i++)
  {
    if (str[i] == charToRemmove)
    {
      for (j = i; j < len; j++)
      {
        str[j] = str[j + 1];
      }
      len--;
      i--;
    }
  }
}

int findStr(const char *src, const char *str, int offset)
{
  char content[strlen(src)];
  strncpy(content, src + offset, strlen(src) - offset);
  char *p = strstr(content, str);
  if (p)
    return p - content + offset;
  return -1;
}

char *replaceStr(const char *src, const char *oldW, const char *newW)
{
  char *result;
  int i, cnt = 0;
  int newWlen = strlen(newW);
  int oldWlen = strlen(oldW);
  for (i = 0; src[i] != '\0'; i++)
  {
    if (strstr(&src[i], oldW) == &src[i])
    {
      cnt++;
      i += oldWlen - 1;
    }
  }
  result = (char *)malloc(i + cnt * (newWlen - oldWlen) + 1);
  i = 0;
  while (*src)
  {
    if (strstr(src, oldW) == src)
    {
      strcpy(&result[i], newW);
      i += newWlen;
      src += oldWlen;
    }
    else
      result[i++] = *src++;
  }
  result[i] = '\0';
  return result;
}

char *trimStr(char *str)
{
  char *end;
  while (isspace((unsigned char)*str))
    str++;
  if (*str == 0)
    return str;
  end = str + strlen(str) - 1;
  while (end > str && isspace((unsigned char)*end))
    end--;
  end[1] = '\0';
  return str;
}

char *extractStr(const char *src, const char *startStr, char *endStr)
{
  int pos0 = findStr(src, startStr, 0);
  int length = strlen(startStr);
  int pos1 = findStr(src, endStr, pos0 + length);
  pos0 = pos0 + length;
  char *destination = subStr(src, pos0, pos1);
  destination[pos1 - pos0] = '\0';
  return trimStr(destination);
}

```

# 網絡服務器 internet.c

```c
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/event_groups.h>
#include <string.h>

#include <nvs_flash.h>
#include <nvs_flash.h>
#include <sys/param.h>
#include <esp_wifi.h>
#include <esp_event.h>
#include <esp_log.h>
#include <esp_system.h>
#include <esp_netif.h>
#include <esp_eth.h>
#include <esp_http_server.h>
#include "esp_sntp.h"

#include <lwip/err.h>
#include <lwip/sockets.h>
#include <lwip/sys.h>
#include <lwip/netdb.h>
#include <lwip/dns.h>

#include "extra.h"

#define SNTP_TIME_SERVER "stdtime.gov.hk"
#define HTTP_ESP_MAXIMUM_RETRY 10
#define WIFI_CONNECTED_BIT BIT0
#define WIFI_FAIL_BIT BIT1

static EventGroupHandle_t s_wifi_event_group;
static int s_retry_num = 0;

void event_handler(void *arg, esp_event_base_t event_base,
                   int32_t event_id, void *event_data)
{
  if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START)
  {
    esp_wifi_connect();
  }
  else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED)
  {
    if (s_retry_num < HTTP_ESP_MAXIMUM_RETRY)
    {
      esp_wifi_connect();
      s_retry_num++;
    }
    else
    {
      xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);
    }
  }
  else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP)
  {
    ip_event_got_ip_t *event = (ip_event_got_ip_t *)event_data;
    printf("\n ---> IP:" IPSTR, IP2STR(&event->ip_info.ip));
    s_retry_num = 0;
    xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);
  }
}

void wifi_init_sta()
{
  esp_err_t ret = nvs_flash_init();
  if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)
  {
    nvs_flash_erase();
    ret = nvs_flash_init();
  }
  s_wifi_event_group = xEventGroupCreate();
  esp_netif_init();
  esp_event_loop_create_default();
  esp_netif_create_default_wifi_sta();
  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  esp_wifi_init(&cfg);

  esp_event_handler_instance_t instance_any_id;
  esp_event_handler_instance_t instance_got_ip;
  esp_event_handler_instance_register(WIFI_EVENT,
                                      ESP_EVENT_ANY_ID, &event_handler, NULL, &instance_any_id);
  esp_event_handler_instance_register(IP_EVENT,
                                      IP_EVENT_STA_GOT_IP, &event_handler, NULL, &instance_got_ip);

  wifi_config_t wifi_config = {
      .sta = {
          .ssid = HTTP_ESP_WIFI_SSID,
          .password = HTTP_ESP_WIFI_PASS,
      },
  };
  esp_wifi_set_mode(WIFI_MODE_STA);
  esp_wifi_set_config(WIFI_IF_STA, &wifi_config);
  esp_wifi_start();

  EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,
                                         WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,
                                         pdFALSE,
                                         pdFALSE,
                                         portMAX_DELAY);

  if (bits & WIFI_CONNECTED_BIT)
  {
    printf(", Success to connect Wifi");
    setTime();
  }
  else
  {
    printf(", Failed to connect WiFi\n");
  }
}

void stop_webserver(httpd_handle_t server)
{
  httpd_stop(server);
}

void disconnect_handler(void *arg, esp_event_base_t event_base,
                        int32_t event_id, void *event_data)
{
  httpd_handle_t *server = (httpd_handle_t *)arg;
  if (*server)
  {
    stop_webserver(*server);
    *server = NULL;
  }
}

void connect_handler(void *arg, esp_event_base_t event_base,
                     int32_t event_id, void *event_data)
{
  httpd_handle_t *server = (httpd_handle_t *)arg;
  if (*server == NULL)
  {
    *server = start_webserver();
  }
}

httpd_handle_t start_webserver()
{
  httpd_handle_t server = NULL;
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.lru_purge_enable = true;
  if (httpd_start(&server, &config) == ESP_OK)
  {
    esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &connect_handler, &server);
    esp_event_handler_register(WIFI_EVENT, WIFI_EVENT_STA_DISCONNECTED, &disconnect_handler, &server);
    httpCall(&server);
    return server;
  }
  printf("Error starting server!");
  return NULL;
}

char *getUrlStr(httpd_req_t *req)
{
  size_t buf_len = httpd_req_get_url_query_len(req) + 1;
  if (buf_len > 1)
  {
    char *buf = malloc(buf_len);
    if (buf)
      if (httpd_req_get_url_query_str(req, buf, buf_len) == ESP_OK)
      {
        return buf;
      }
    free(buf);
  }
  return NULL;
}

void setTime()
{
  int retry = 0;
  const int retry_count = 30;
  char strftime_buf[64];
  time_t now;
  struct tm timeinfo;
  sntp_setoperatingmode(SNTP_OPMODE_POLL);
  sntp_setservername(1, "pool.ntp.org");
  sntp_setservername(0, SNTP_TIME_SERVER);
  sntp_set_sync_mode(SNTP_SYNC_MODE_SMOOTH);
  sntp_init();
  while (sntp_get_sync_status() == SNTP_SYNC_STATUS_RESET && ++retry < retry_count)
  {
    vTaskDelay(5000 / portTICK_PERIOD_MS);
  }
  time(&now);
  setenv("TZ", "CST-8", 1);
  tzset();
  localtime_r(&now, &timeinfo);
  strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
  printf("\n ---> Date/Time (GMT+8): %s\n", strftime_buf);
}

char *http_get_task(const char *webServer, char *port, const char *webPath)
{
  char REQUEST[256];
  sprintf(REQUEST, "GET %s HTTP/1.0\r\nHost: %s:%s\r\nUser-Agent: esp-idf/1.0 esp32\r\n\r\n", webPath, webServer, port);
  const struct addrinfo hints = {
      .ai_family = AF_INET,
      .ai_socktype = SOCK_STREAM,
  };
  struct addrinfo *res;
  // struct in_addr *addr;
  int s, r;
  int total = 0;
  char recv_buf[256];
  char *rbuf = (char *)malloc(sizeof(char) * 256);
  bool flag = false;
  while (!flag)
  {
    int err = getaddrinfo(webServer, "80", &hints, &res);
    if (err != 0 || res == NULL)
    {
      printf("DNS lookup failed err=%d res=%p\n", err, res);
      vTaskDelay(1000 / portTICK_PERIOD_MS);
      continue;
    }

    // addr = &((struct sockaddr_in *)res->ai_addr)->sin_addr;
    s = socket(res->ai_family, res->ai_socktype, 0);
    if (s < 0)
    {
      printf("... Failed to allocate socket.\n");
      freeaddrinfo(res);
      vTaskDelay(1000 / portTICK_PERIOD_MS);
      continue;
    }
    if (connect(s, res->ai_addr, res->ai_addrlen) != 0)
    {
      printf("... socket connect failed errno=%d\n", errno);
      close(s);
      freeaddrinfo(res);
      vTaskDelay(4000 / portTICK_PERIOD_MS);
      continue;
    }
    freeaddrinfo(res);
    if (write(s, REQUEST, strlen(REQUEST)) < 0)
    {
      printf("... socket send failed\n");
      close(s);
      vTaskDelay(4000 / portTICK_PERIOD_MS);
      continue;
    }
    struct timeval receiving_timeout;
    receiving_timeout.tv_sec = 5;
    receiving_timeout.tv_usec = 0;
    if (setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &receiving_timeout, sizeof(receiving_timeout)) < 0)
    {
      printf("... failed to set socket receiving timeout\n");
      close(s);
      vTaskDelay(4000 / portTICK_PERIOD_MS);
      continue;
    }
    int current = 0;
    do
    {
      r = read(s, recv_buf, sizeof(recv_buf) - 1);
      total = total + r;
      if (total > sizeof(rbuf))
      {
        total = total + 256;
        rbuf = (char *)realloc(rbuf, sizeof(char) * total);
      }
      memcpy(rbuf + current, recv_buf, r);
      current = current + r;
    } while (r > 0);
    rbuf[current] = '\0';
    close(s);
    flag = true;
  }
  return rbuf;
}

char *getIP(int port)
{
  char *content = http_get_task("www.cloudflare.com", "80", "/cdn-cgi/trace/");
  char *ipaddress = extractStr(content, "ip=", "ts=");
  char *ripaddress = (char *)malloc(sizeof(strlen(ipaddress)) + 10);
  sprintf(ripaddress, "%s:%d", ipaddress, port);
  printf(" ---> Internet IP : %s\n", ripaddress);
  free(ipaddress);
  free(content);
  return ripaddress;
}

typedef struct
{
  char *topic;
  char *content;
  int qos;
} publishList;

static publishList *arrayList;
static int publishCount = 0;

void initPublish(int topicSize)
{
  arrayList = malloc(sizeof(publishList) * topicSize);
}

void publish(char *topic, char *content, int qos)
{
  arrayList[publishCount].topic = topic;
  arrayList[publishCount].content = content;
  arrayList[publishCount].qos = qos;
  publishCount = publishCount + 1;
}

static void mqtt_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data)
{
  esp_mqtt_event_handle_t event = event_data;
  esp_mqtt_client_handle_t client = event->client;
  switch ((esp_mqtt_event_id_t)event_id)
  {
  case MQTT_EVENT_CONNECTED:
    printf(" ---> MQTT Connected.\n");
    for (int i = 0; i < publishCount; i++)
      esp_mqtt_client_publish(client, arrayList[i].topic, arrayList[i].content, 0, arrayList[i].qos, 1);
    publishCount = 0;
    break;
  case MQTT_EVENT_DISCONNECTED:
    printf(" ---> MQTT Disconnected.\n");
    break;
  default:
    break;
  }
}

void mqtt_IP()
{
  const esp_mqtt_client_config_t mqtt_cfg = {
      .uri = "ws://test.mosquitto.org:8080",
  };
  esp_mqtt_client_handle_t client = esp_mqtt_client_init(&mqtt_cfg);
  esp_mqtt_client_register_event(client, ESP_EVENT_ANY_ID, mqtt_event_handler, NULL);
  esp_mqtt_client_start(client);
}

```
# C 主程序 main.c

```c
#include <esp_event.h>
#include <esp_http_server.h>
#include <string.h>

#include <extra.h>

static char *html;
static char *css;
static char *js;
static char *fileList;
static char *actual_IP;

esp_err_t aht_get_handler(httpd_req_t *req)
{
  float temperature;
  float humidity;
  AHT10(&temperature, &humidity);
  char output[256];
  sprintf(output, "温度:%3.3lf, 湿度:%3.3lf", temperature, humidity);

  char *firstStr = "$(\"#temperature\").text(\"";
  char *lastStr = "\");";
  html = replaceHtml(html, output, firstStr, lastStr);
  httpd_resp_send(req, html, HTTPD_RESP_USE_STRLEN);
  return ESP_OK;
}

esp_err_t gpio_get_handler(httpd_req_t *req)
{
  size_t buf_len = httpd_req_get_url_query_len(req) + 1;
  if (buf_len > 1)
  {
    char *buf = malloc(buf_len);
    if (buf)
      if (httpd_req_get_url_query_str(req, buf, buf_len) == ESP_OK)
      {
        printf("GPIO URL query => %s", buf);
      }
    free(buf);
  }
  const char *resp_str = (const char *)req->user_ctx;
  httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN);
  return ESP_OK;
}

void readInit()
{
  esp_vfs_spiffs_conf_t conf;
  conf = spiffsInit("/spiffs", "storage");
  html = fileRead("/spiffs/sample.html");
  css = fileRead("/spiffs/css/sample.css");
  js = fileRead("/spiffs/js/sample.js");
  fileList = list("/spiffs", "*.*", conf.partition_label);
  for (int i = 0; i < 5; i++)
  {
    html = replaceStr(html, "IP_ADDRESS", actual_IP);
  }
  spiffsClose(conf);
}

char *readSpiffs(char *fileName)
{
  esp_vfs_spiffs_conf_t conf;
  conf = spiffsInit("/spiffs", "storage");
  char *content = fileRead(fileName);
  spiffsClose(conf);
  return content;
}

esp_err_t gpio_get_hander(httpd_req_t *req)
{
  char *resp_str = getUrlStr(req);
  if (strcmp(resp_str, "1O") == 0)
  {
    setGPIO(12, 1);
    printf("\nOn1");
  }
  if (strcmp(resp_str, "1F") == 0)
  {
    setGPIO(12, 0);
    printf("\nOff1");
  }
  if (strcmp(resp_str, "2O") == 0)
  {
    setGPIO(13, 1);
    printf("\nOn2");
  }
  if (strcmp(resp_str, "2F") == 0)
  {
    setGPIO(13, 0);
    printf("\nOff2");
  }
  free(resp_str);
  return ESP_OK;
}

esp_err_t index_get_handler(httpd_req_t *req)
{
  httpd_resp_send(req, html, HTTPD_RESP_USE_STRLEN);
  return ESP_OK;
}

esp_err_t list_get_handler(httpd_req_t *req)
{
  html = replaceStr(html, "FILE_INFORMATION", fileList);
  httpd_resp_send(req, html, HTTPD_RESP_USE_STRLEN);
  return ESP_OK;
}

esp_err_t misc_get_handler(httpd_req_t *req)
{
  char *content = NULL;
  if (strstr(req->uri, "/css"))
  {
    httpd_resp_set_type(req, "text/css");
    content = css;
  }
  if (strstr(req->uri, "/js"))
  {
    content = js;
    httpd_resp_set_type(req, "text/plain");
  }
  httpd_resp_send(req, content, HTTPD_RESP_USE_STRLEN);
  return ESP_OK;
}

httpd_uri_t basic_handlers[] =
    {
        {.uri = "/List",
         .method = HTTP_GET,
         .handler = list_get_handler,
         .user_ctx = NULL},
        {.uri = "/",
         .method = HTTP_GET,
         .handler = index_get_handler,
         .user_ctx = NULL},
        {.uri = "/css/sample.css",
         .method = HTTP_GET,
         .handler = misc_get_handler,
         .user_ctx = NULL},
        {.uri = "/js/sample.js",
         .method = HTTP_GET,
         .handler = misc_get_handler,
         .user_ctx = NULL},
        {.uri = "/LED",
         .method = HTTP_GET,
         .handler = gpio_get_hander,
         .user_ctx = NULL},
        {.uri = "/aht",
         .method = HTTP_GET,
         .handler = aht_get_handler,
         .user_ctx = "AHT 10 - 12345678!"}};

void httpCall(httpd_handle_t *server)
{
  for (uint8_t i = 0; i < sizeof(basic_handlers) / sizeof(httpd_uri_t); i++)
  {
    httpd_register_uri_handler(*server, &basic_handlers[i]);
  }
}

void app_main(void)
{
  wifi_init_sta();
  actual_IP = getIP(91);
  readInit();
  initGPIO();
  initPublish(10);
  publish("/tmpIP_HK", actual_IP, 1);
  mqtt_IP();
  start_webserver();
}

```
# MQTT

```html
<html>
  <head>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  </head>
  <body>
    <script>
      var client = mqtt.connect("ws://test.mosquitto.org:8081");
      client.on("connect", () => {
        console.log("connected.");
        client.subscribe("/tmpIP_HK");
        client.on("message", function (topic, payload) {
          let urlAddress = [payload].join(",");
          window.location.href = "http://" + urlAddress;
        });
      });
    </script>
  </body>
</html>
```

# 網頁項目包含以下的文件

## sample.html

用 HTML 頁面來控制開發板和監控設備之間的界面可以提供很好的效果，輕鬆兼容更多平台，包括個人電腦、平板電腦和手機。

```html
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script type="text/javascript" src="js/sample.js"></script>
    <link rel="stylesheet" href="css/sample.css" />
  </head>
  <body>
    <p id="iDate"></p>
    <script>
      let ipaddress = "IP_ADDRESS";
      $(document).ready(function () {
        $("#temperature").text("溫度和濕度信息!");
      });
    </script>
     <div class="rbuttonHolder">
      <table class="base">
        <tr>
          <td class="ledLable">LED 1</td>
          <td>
            <a href="http://IP_ADDRESS/LED?1O" class="rbtn onBtn"></a>
            <a href="http://IP_ADDRESS/LED?1F" class="rbtn offBtn"></a>
          </td>
        </tr>
        <tr>
          <td class="ledLable">LED 2</td>
          <td>
            <a href="http://IP_ADDRESS/LED?2O" class="rbtn onBtn"></a>
            <a href="http://IP_ADDRESS/LED?2F" class="rbtn offBtn"></a>
          </td>
        </tr>
        <tr>
          <td class="ledLable">功能</td>
          <td>
            <a href="http://IP_ADDRESS/List" class="rbtn confirmBtn"></a>
            <a href="http://IP_ADDRESS/aht" class="rbtn measureBtn"></a>
          </td>
        </tr>
        <tr>
          <td colspan="3">
            <h2>
              <div class="ledLable" id="temperature"></div>
            </h2>
          </td>
        </tr>
        <tr>
          <td colspan="3">
            <table id="itable"></table>
            <script>
              let listInfo = FILE_INFORMATION;
              tableFromJSON(listInfo);
            </script>
          </td>
        </tr>
      </table>
    </div>
  </body>
</html>
```


## sample.css

CSS 用於控製網頁效果的呈現,並且在互聯網上可以獲得很多已開發的 CSS 代碼

```css
body {
  background-image: -webkit-linear-gradient(top, #f1f1f1, #fafafa);
  background-image: linear-gradient(top, #edecec, #cecbc9);
}

.cbuttonHolder {
  /* 90 per circular button */
  disply: block;
  margin: auto;
  text-align: center;
  position: relative;
  width: 180px;
  height: 100px;
}

.rbuttonHolder {
  /* 120 per circular button */
  disply: block;
  margin: auto;
  text-align: center;
  position: relative;
  width: 480px;
  height: 100px;
}

.rbtn {
  background-image: -webkit-linear-gradient(top, #dfdfd0, #fff);
  background-image: linear-gradient(top, #dfdfd0, #fff);
  border-radius: 10%;
  box-shadow: 0px 8px 10px 0px rgba(0, 0, 0, 0.3), inset 0px 4px 1px 1px white,
    inset 0px -3px 1px 1px rgba(204, 198, 197, 0.5);
  float: left;
  margin: 10px 10px 10px 10px;
  position: relative;
  -webkit-transition: all 0.1s linear;
  transition: all 0.1s linear;
  height: 4em;
  width: 5em;
}

.rbtn:after {
  color: #e9e6e4;
  content: "";
  display: block;
  font-size: 1.5em;
  text-decoration: none;
  text-shadow: 0px -1px 1px #bdb5b4, 1px 1px 1px white;
  position: absolute;
  height: 1.5em;
  width: 1.5em;
}

.rbtn:hover {
  background-image: -webkit-linear-gradient(top, #fff, #dfdfd0);
  background-image: linear-gradient(top, #fff, #dfdfd0);
  color: #0088cc;
}

.rbtn:active {
  background-image: -webkit-linear-gradient(top, #efedec, #f7f4f4);
  background-image: linear-gradient(top, #efedec, #f7f4f4);
  box-shadow: 0 3px 5px 0 rgba(0, 0, 0, 0.4),
    inset 0px -3px 1px 1px rgba(204, 198, 197, 0.5);
}

.rbtn:active:after {
  color: #dbd2d2;
  text-shadow: 0px -1px 1px #bdb5b4, 0px 1px 1px white;
}

.confirmBtn:after {
  content: "目錄";   /* 確認 */
  left: -0.8em;
  top: 0.6em;
  width: 5em;
}

.confirmBtn:hover:after {
  color: #bf00ff;
  text-shadow: 0px 0px 6px #e699ff;
}

.offBtn:after {
  content: "關閉";
  left: -0.8em;
  top: 0.6em;
  width: 5em;
}

.offBtn:hover:after {
  color: #d9006c;
  text-shadow: 0px 0px 6px #ff99cc;
}

.onBtn:after {
  content: "開啟";
  left: -0.8em;
  top: 0.6em;
  width: 5em;
}

.onBtn:hover:after {
  color: #006619;
  text-shadow: 0px 0px 6px #73ff73;
}

.measureBtn:after {
  content: "測量";
  left: -0.8em;
  top: 0.6em;
  width: 5em;
}

.measureBtn:hover:after {
  color: #0000d9;
  text-shadow: 0px 0px 6px #9999ff;
}

.cbtn {
  background-image: -webkit-linear-gradient(top, #dfdfd0, #fff);
  background-image: linear-gradient(top, #dfdfd0, #fff);
  border-radius: 50%;
  box-shadow: 0px 8px 10px 0px rgba(0, 0, 0, 0.3), inset 0px 4px 1px 1px white,
    inset 0px -3px 1px 1px rgba(204, 198, 197, 0.5);
  float: left;
  margin: 10px 10px 10px 10px;
  position: relative;
  width: 4em;
  height: 4em;
  -webkit-transition: all 0.1s linear;
  transition: all 0.1s linear;
}

.cbtn:after {
  color: #e9e6e4;
  content: "";
  display: block;
  font-size: 2.2em;
  text-decoration: none;
  text-shadow: 0px -1px 1px #bdb5b4, 1px 1px 1px white;
  position: absolute;
  width: 2.5em;
  height: 2.5em;
}

.cbtn:hover {
  background-image: -webkit-linear-gradient(top, #fff, #dfdfd0);
  background-image: linear-gradient(top, #fff, #dfdfd0);
  color: #0088cc;
}

.cbtn:active {
  background-image: -webkit-linear-gradient(top, #efedec, #f7f4f4);
  background-image: linear-gradient(top, #efedec, #f7f4f4);
  box-shadow: 0 3px 5px 0 rgba(0, 0, 0, 0.4),
    inset 0px -3px 1px 1px rgba(204, 198, 197, 0.5);
}

.cbtn:active:after {
  color: #dbd2d2;
  text-shadow: 0px -1px 1px #bdb5b4, 0px 1px 1px white;
}

.tick:after {
  content: "✔";
  left: -0.3em;
  top: 0.2em;
}

.tick:hover:after {
  color: #0000d9;
  text-shadow: 0px 0px 6px #4d4cff;
}

.cross:after {
  content: "✖";
  left: -0.3em;
  top: 0.2em;
}

.cross:hover:after {
  color: #eb2f2f;
  text-shadow: 0px 0px 6px #e67e7e;
}

h1 {
  position: relative;
  z-index: 2;
  color: #ff0000;
  font-size: 3em;
  text-transform: uppercase;
  transform: rotate(-1deg);
  text-shadow: 1px 1px hsl(50, 50%, 45%), 2px 2px hsl(50, 50%, 40%),
    3px 3px hsl(50, 50%, 35%), 4px 4px hsl(50, 50%, 34%),
    10px 10px 30px rgba(0, 0, 0, 0.5);
}

h1:hover {
  color: #ffff00;
}

h2 {
  position: relative;
  z-index: 2;
  color: #17d15e;
  font-size: 1.8em;
  filter: drop-shadow(3px 3px 3px rgb(12, 8, 9));
}

h2:hover {
  color: #ffff00;
}

div {
  margin: 10px 50px 30px;
}

table#itable {
  font-size: 12px;
  font-weight: normal;
  width: 100%;
  max-width: 100%;
  border-collapse: separate;
  border: solid #eeeeee 1px;
  border-radius: 8px;
  box-shadow: 3px 5px 5px 0 rgba(0, 0, 0, 0.4),
    inset 0px -3px 2px 2px rgba(204, 198, 197, 0.5);
}

table#itable td,
table#itable th {
  text-align: center;
  padding: 8px;
  border: solid transparent 1px;
  border-radius: 5px;
  font-size: 15px;
}

table#itable th {
  color: #ffffff;
  background: #666666;
}

table#itable th:nth-child(odd) {
  color: #ffffff;
  background: #666666;
}

table#itable tr:nth-child(even) {
  background: #ffffea;
}

table#itable tr:nth-child(odd) {
  background: #fafffa;
}

table#itable tr:hover {
  background-color: #eeeeee;
}

span#small {
  font-size: 23px;
  color: #0036d9;
}

#box {
  height: 50px;
  width: 50px;
  -webkit-appearance: none;
  box-shadow: -10px -10px 15px rgba(255, 255, 255, 0.5),
    10px 10px 15px rgba(70, 70, 70, 0.12);
  border-radius: 50%; /*Makes the circle*/
  border: 5px solid #ececec;
  outline: none;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}

#box:hover {
  box-shadow: -10px -10px 15px rgba(255, 255, 255, 0.5),
    10px 10px 15px rgba(70, 70, 70, 0.12),
    inset -10px -10px 15px rgba(255, 255, 255, 0.5),
    inset 10px 10px 15px rgba(70, 70, 70, 0.12);
}

p#iDate {
  margin: auto;
  padding: 15px 15px 0px 0px;
  font-size: 2em;
  text-align: center;
  height: 50px;
  width: 15em;
  border-radius: 8px;
  border: 8px solid #fffff4;
  box-shadow: inset -8px -8px 10px rgba(255, 255, 255, 0.5),
    inset 10px 10px 15px rgba(70, 70, 70, 0.22);
  color: white;
  text-shadow: 0 0 3px #ff0000, 0 0 5px #0000ff;
}

div.ledLabel {
  position: absolute;
  margin: auto;
  font-size: 2em;
  text-align: center;
  display: block;
}

table.base {
  font-size: 1em;
  font-weight: normal;
  border-collapse: collapse;
}

table.base td,
table.base th {
  margin: auto;
  text-align: center;
  border-collapse: collapse;
}

td.ledLable {
  font-size: 2em;
  padding: 0.2em 20px 0px 10px;
  text-shadow: 2px 2px #FFFF00;
}
```

## sample.js

用 Javascript 可以讓我們在互聯網上獲得更多已開發和創意的功能

```js
$(function () {
  function padTo2Digits(num) {
    return num.toString().padStart(2, "0");
  }

  function formatDate() {
    idate = new Date();
    odate =
      [
        idate.getFullYear(),
        padTo2Digits(idate.getMonth() + 1),
        padTo2Digits(idate.getDate()),
      ].join("-") +
      " " +
      [
        padTo2Digits(idate.getHours()),
        padTo2Digits(idate.getMinutes()),
        padTo2Digits(idate.getSeconds()),
      ].join(":");
    document.getElementById("iDate").innerHTML = odate;
    let t = setTimeout(function () {
      formatDate();
    }, 1000);
  }

  formatDate();
});

function tableFromJSON(iList) {
  var col = [];
  for (var i = 0; i < iList.length; i++) {
    for (var key in iList[i]) {
      if (col.indexOf(key) === -1) {
        col.push(key);
      }
    }
  }
  var table = document.getElementById("itable");
  var tr = table.insertRow(-1);
  for (var i = 0; i < col.length; i++) {
    var th = document.createElement("th");
    th.innerHTML = col[i];
    tr.appendChild(th);
  }
  for (var i = 0; i < iList.length; i++) {
    tr = table.insertRow(-1);
    for (var j = 0; j < col.length; j++) {
      var tabCell = tr.insertCell(-1);
      tabCell.innerHTML = iList[i][col[j]];
    }
  }
}
```
## 用平板電腦控制的視頻

![Alt movie](../assets/img/misc/esp32c3.gif)

# littlefs 文件系统

[littlefs 互聯網資源](https://github.com/joltwallet/esp_littlefs)

```shell
git submodule add https://github.com/joltwallet/esp_littlefs.git
git submodule update --init --recursive
```

# CMakeLists.txt

將文件夾 **~/程序目錄/web** 下的文件寫入 **littlefs** 分區

```
idf_component_register(SRCS "demo_esp_littlefs.c" INCLUDE_DIRS "." )

# 從 'web' 目錄創建一個 littlefs 圖像
# 適合名為 “littlefs” 的分區。鏡像在項目刷時刷到
# 帶有 'idf.py -p PORT flash' 的目標。
littlefs_create_partition_image(littlefs ../web)

```