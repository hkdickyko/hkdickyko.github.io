---
category: [編程]
tags: [編程]
title: ESP 開發的軟件框架
date: 2022-04-23 06:00:00
---

# ESP32-C3

ESP32-C3 搭載 RISC-V 32 位單核處理器，工作頻率高達 160 MHz，模組支持 Wi-Fi。內置 400 KB SRAM，384 KB ROM，8KB RTC SRAM，內置 4MB Flash。

# 安裝 ESP-IDF

基本上所有類型的 ESP32 開發板也能用這個開發工具編譯。安裝方法如下。

[ESP-IDF 互聯網資源](https://github.com/espressif/esp-idf)

```shell
sudo apt-get install git wget flex bison gperf python3 python3-pip python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0
python3 --version
git clone --recursive https://github.com/espressif/esp-idf.git
cd ~/esp/esp-idf
./install.sh
source ./export.sh

```
# ESP32 程式模板

因 ESP32 開發版是基於模板程式，再由網上下載相關開發版的程式部份，步驟及下載部分詳列如下。

[ESP32 程式模板下載](https://github.com/espressif/esp-idf-template)

```shell
cd ~/esp
git clone --recursive https://github.com/espressif/esp-idf-template
mv esp-idf-template esp32c3

```
注意：<font color="#FF1000">esp32c3</font> 需要根據的情況進行更改


# 選擇安裝並編譯模板設置

如選擇安裝 ESP32-C3，則在 set-target 為 esp32c3 如下。
 - 第 1 行 轉到主程式目錄
 - 第 2 行 將目錄設置為 shell 參數
 - 第 3 行 到 idf 的安裝目䤸
 - 前 4 行 更新 idf 的相關部份連接
 - 第 5 行 使用shell參數返回主程式目錄
 - 第 6 行 顯示 idf 版本，以確認 idf 安裝正常。
 - 第 7 行 下載相關開發版的指令
 - 第 8 行 編譯及燒錄程序到開發版
 - 第 9 行 監管執行程序的顯示資訊

```shell
cd ~/主程式目錄
curdir=$(pwd)
cd ~/esp/esp-idf
source ./export.sh
cd ${curdir}
idf.py --version
idf.py set-target esp32c3
idf.py menuconfig
idf.py flash
idf.py monitor

```

如需要微調更新設定，可以執行以下命令. **idf.py menuconfig** 。 例如:添加 WiFi 連接 SSID 和密碼。

# 外圍連接安裝問題

 - 如果無法訪問 **ttyACM0** 以下命令將授予訪問權限

```shell
sudo adduser $USER dialout
sudo chmod a+rw /dev/ttyACM0

```

# 編譯並安裝全過程

 - 如果發現任何錯誤，可以執行以下命令. **idf.py menuconfig** 用於在 ESP32-C3 開發板上設置設置的命令

```shell
cd ~/主程式目錄
curdir=$(pwd)
rm -rf build
idf.py fullclean
rm -rf `find -name CMakeCache.txt`
cd ~/esp/esp-idf
./install.sh
source ./export.sh
cd ${curdir}
idf.py --version
idf.py set-target esp32c3
idf.py menuconfig   # 根據要求使用
idf.py build
idf.py flash
idf.py monitor

```
注意：<font color="#FF1000">esp32c3</font> 需要根據的情況進行更改

# extra.h
```c
void setTime();
void wifi_init_sta();
void httpCall(httpd_handle_t* server);
void connect_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data);
void disconnect_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data);
void stop_webserver(httpd_handle_t server);
char* getUrlStr(httpd_req_t *req);
httpd_handle_t start_webserver();

```


# internet.c

```c
#include <esp_wifi.h>
#include <esp_event.h>
#include <esp_log.h>
#include <esp_system.h>
#include <nvs_flash.h>
#include <sys/param.h>
#include "nvs_flash.h"
#include "esp_netif.h"
#include "esp_eth.h"
#include <esp_http_server.h>
#include <string.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/event_groups.h>
#include <lwip/err.h>
#include <lwip/sys.h>
#include "esp_sntp.h"

#include "extra.h"

#define HTTP_ESP_WIFI_SSID      "xxxx"
#define HTTP_ESP_WIFI_PASS      "xxxx-xxxx-xxxx"
#define SNTP_TIME_SERVER        "stdtime.gov.hk"
#define HTTP_ESP_MAXIMUM_RETRY  10

#define WIFI_CONNECTED_BIT BIT0
#define WIFI_FAIL_BIT      BIT1

static EventGroupHandle_t s_wifi_event_group;
static int s_retry_num = 0;

void event_handler(void* arg, esp_event_base_t event_base,
                                int32_t event_id, void* event_data)
{
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        if (s_retry_num < HTTP_ESP_MAXIMUM_RETRY) {
            esp_wifi_connect();
            s_retry_num++;
        } else {
            xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);
        }
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        printf("\n ---> IP:" IPSTR, IP2STR(&event->ip_info.ip));
        s_retry_num = 0;
        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);
    }
}

void wifi_init_sta()
{
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      nvs_flash_erase();
      ret = nvs_flash_init();
    }
    s_wifi_event_group = xEventGroupCreate();
    esp_netif_init();
    esp_event_loop_create_default();
    esp_netif_create_default_wifi_sta();
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    esp_wifi_init(&cfg);

    esp_event_handler_instance_t instance_any_id;
    esp_event_handler_instance_t instance_got_ip;
    esp_event_handler_instance_register(WIFI_EVENT,
            ESP_EVENT_ANY_ID,&event_handler,NULL,&instance_any_id);
    esp_event_handler_instance_register(IP_EVENT,
            IP_EVENT_STA_GOT_IP,&event_handler,NULL,&instance_got_ip);

    wifi_config_t wifi_config = {
        .sta = {
            .ssid = HTTP_ESP_WIFI_SSID,
            .password = HTTP_ESP_WIFI_PASS,
         },
    };
    esp_wifi_set_mode(WIFI_MODE_STA);
    esp_wifi_set_config(WIFI_IF_STA, &wifi_config);
    esp_wifi_start();

    EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,
            WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,
            pdFALSE,
            pdFALSE,
            portMAX_DELAY);

    if (bits & WIFI_CONNECTED_BIT) {
        printf(", Success to connect Wifi");
        setTime();
    } else {
        printf(", Failed to connect WiFi\n");
    }
 }

void stop_webserver(httpd_handle_t server)
{
    httpd_stop(server);
}

void disconnect_handler(void* arg, esp_event_base_t event_base,
                               int32_t event_id, void* event_data)
{
    httpd_handle_t* server = (httpd_handle_t*) arg;
    if (*server) {
        stop_webserver(*server);
        *server = NULL;
    }
}

void connect_handler(void* arg, esp_event_base_t event_base,
                            int32_t event_id, void* event_data)
{
    httpd_handle_t* server = (httpd_handle_t*) arg;
    if (*server == NULL) {
        *server = start_webserver();
    }
}

httpd_handle_t start_webserver()
{
    httpd_handle_t server = NULL;
    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
    config.lru_purge_enable = true;
    if (httpd_start(&server, &config) == ESP_OK) {
        esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &connect_handler, &server);
        esp_event_handler_register(WIFI_EVENT, WIFI_EVENT_STA_DISCONNECTED, &disconnect_handler, &server);
        httpCall(&server);
        return server;
    }
    printf("Error starting server!");
    return NULL;
}

char* getUrlStr(httpd_req_t *req)
{
    size_t buf_len = httpd_req_get_url_query_len(req) + 1;
    if (buf_len > 1) {
        char* buf = malloc(buf_len);
        if(buf)
            if (httpd_req_get_url_query_str(req, buf, buf_len) == ESP_OK) {
                return buf;
            }
        free(buf);
    }
    return NULL;
}

void setTime(){
    int retry = 0;
    const int retry_count = 30;
    char strftime_buf[64];
    time_t now;
    struct tm timeinfo;
    sntp_setoperatingmode(SNTP_OPMODE_POLL);
    sntp_setservername(1, "pool.ntp.org");
    sntp_setservername(0, SNTP_TIME_SERVER);
    sntp_set_sync_mode(SNTP_SYNC_MODE_SMOOTH);
    sntp_init();
    while (sntp_get_sync_status() == SNTP_SYNC_STATUS_RESET && ++retry < retry_count) {
        vTaskDelay(5000 / portTICK_PERIOD_MS);
    }
    time(&now);
    setenv("TZ", "CST-8", 1);
    tzset();
    localtime_r(&now, &timeinfo);
    strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
    printf("\n ---> Date/Time (GMT+8): %s\n", strftime_buf);
}

```
# main.c

```c
#include <esp_event.h>
#include <esp_http_server.h>
#include <string.h>

#include <extra.h>

esp_err_t aht_get_handler(httpd_req_t *req)
{
    httpd_resp_set_type(req, "text/plain");
    const char* resp_str = (const char*) req->user_ctx;
    httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

esp_err_t gpio_get_handler(httpd_req_t *req)
{
    size_t buf_len = httpd_req_get_url_query_len(req) + 1;
    if (buf_len > 1) {
        char* buf = malloc(buf_len);
        if(buf)
            if (httpd_req_get_url_query_str(req, buf, buf_len) == ESP_OK) {
                printf("GPIO URL query => %s", buf);
            }
        free(buf);
    }
    const char* resp_str = (const char*) req->user_ctx;
    httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

httpd_uri_t basic_handlers[2] =
{
    {
    .uri       = "/gpio",
    .method    = HTTP_GET,
    .handler   = gpio_get_handler,
    .user_ctx  = "GPIO test!"
    },
    {
    .uri       = "/aht",
    .method    = HTTP_GET,
    .handler   = aht_get_handler,
    .user_ctx  = "AHT 10!"
    }
};

void httpCall(httpd_handle_t* server){
    for (uint8_t i = 0; i < sizeof(basic_handlers) / sizeof(httpd_uri_t); i++){
        httpd_register_uri_handler(*server, &basic_handlers[i]);
    }
}

void app_main(void)
{
    wifi_init_sta();
    start_webserver();
}

```

# littlefs 文件系统

[littlefs 互聯網資源](https://github.com/joltwallet/esp_littlefs)

```shell
git submodule add https://github.com/joltwallet/esp_littlefs.git
git submodule update --init --recursive
```

# CMakeLists.txt

將文件夾 **~/程序目錄/web** 下的文件寫入 **littlefs** 分區

```
idf_component_register(SRCS "demo_esp_littlefs.c" INCLUDE_DIRS "." )

# 從 'web' 目錄創建一個 littlefs 圖像
# 適合名為 “littlefs” 的分區。鏡像在項目刷時刷到
# 帶有 'idf.py -p PORT flash' 的目標。
littlefs_create_partition_image(littlefs ../web)

```
