---
category: [Android]
tags: [編程]
title: Android 零件
date: 2022-10-22 1:00:00
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
    text-align: center;
  }
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
</style>

# Android Webview 與 javascript 通信

Android 利用 Webview 提供給 HTML 和 javascript 通信。Java 方法通過一個特殊的類暴露給 Javascript。這方法使用 @JavascriptInterface 註釋進行。

## Android 部分

WebAppInterface 用於創建接口函數的類

```java
public class WebAppInterface {
  Context mContext;
  // 實例化接口並設置 Context
  WebAppInterface(Context c) {
    mContext = c;
  }
  // 從網頁顯示彈出窗口
  @JavascriptInterface
  public void showToast(String toast) {
    Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();
  }
}
````

將網絡權限添加到 AndroidManifest.xml

```xml
<uses-permission android:name="android.permission.INTERNET" />
```

創建了這個項目 content_main.xml 文件，並使用 Basic Activity 作為主要活動添加 webview。

```xml
<WebView xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/webview"
  android:layout_width="fill_parent"
  android:layout_height="fill_parent"
/>
```

創建 UI Webview 的主線程

```java
// 創建 mWebview 後應激活以下功能
WebView myWebView = (WebView) findViewById(R.id.webview);
  mWebView.addJavascriptInterface(new WebAppInterface(this), "JsBridge");
  mWebView.loadUrl("http://www.google.com");
```

第一個參數是帶有上下文的接口類，後者是變量在 Javascript 中使用的名稱 (區分大小寫)。

## Javascript 部分

```js
<input type="button" value="你好" onClick="showAndroidToast('你好 Android!')" />
<script type="text/javascript">
function showAndroidToast(toast) {
  if(typeof JsBridge !== "undefined" && JsBridge !== null) {
    JsBridge.showToast(toast);
  } else {
    alert("不能夠在網頁視圖中查看");
  }
}
</script>
```

在 Javascript 中有一個名為 JsBridge 的全局對象及來自 addJavascriptInterface 的方法。該對象具有接口，在本例中為 showToast(String toast)。 if 語句用於檢查 JsBridge 的名字對像是否已設置。有了這個 if 語句，如果 JsBridge 不存在，javascript會跳出函數，該網頁可以從其他瀏覽器使用以及不存在 JsBridge 界面的地方。



# Dialog (對話方塊)

對話方塊是一個小型視窗，可提示使用者做決定或輸入其他資訊。對話方塊不會填滿螢幕，通常用於強制回應事件。

```java
public void openDialog() {
  final Dialog dialog = new Dialog(context);
  dialog.setContentView(R.layout.dialog_demo);
  dialog.setTitle(R.string.dialog_title);
  dialog.show();
}
```

創建 XML 佈局文件 dialog_demo.xml 並創建 UI 設計。

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <TextView
        android:id="@+id/dialog_info"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:padding="10dp"
        android:text="@string/dialog_text"/>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="40dp"
        android:layout_below="@id/dialog_info">

        <Button
            android:id="@+id/dialog_cancel"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="0.50"
            android:background="@color/dialog_cancel_bgcolor"
            android:text="Cancel"/>

        <Button
            android:id="@+id/dialog_ok"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="0.50"
            android:background="@color/dialog_ok_bgcolor"
            android:text="Agree"/>
    </LinearLayout>
</RelativeLayout>
```

注意 strings.xml 和 colors.xml 中的字符和顏色可以很容易改變。

## AlertDialog (建立快訊對話方塊)

可以使用 AlertDialog 並使用其 Builder 類構造一個構造函數，該構造函數僅接受 Context，因為對話框將從傳入的 Context 繼承正確的主題，但可以將特定主題資源指定為第二個參數。

```java
AlertDialog.Builder builder1 = new AlertDialog.Builder(context);
builder1.setTitle("對話框的標題");
builder1.setMessage("在這裡寫下你的信息.");
builder1.setCancelable(true);
// 指定偵聽器允許在關閉對話框之前執行操作。單擊對話框按鈕時，對話框會自動關閉。
builder1.setPositiveButton(
  "確認",
  new DialogInterface.OnClickListener() {
    public void onClick(DialogInterface dialog, int id) {
      dialog.cancel();
    }
});

builder1.setNegativeButton(
  "取消",
  new DialogInterface.OnClickListener() {
    public void onClick(DialogInterface dialog, int id) {
      dialog.cancel();
    }
});

AlertDialog alert11 = builder1.create();
alert11.setIcon(android.R.drawable.ic_dialog_alert)
alert11.show();
```

如果你不在主線程中

```java
runOnUiThread(new Runnable() {
  @Override
  public void run() {
    if (!isFinishing()){
      new AlertDialog.Builder(YourActivity.this)
        .setTitle("Your Alert")
        .setMessage("Your Message")
        .setCancelable(false)
        .setPositiveButton("ok", new OnClickListener() {
        @Override
          public void onClick(DialogInterface dialog, int which) {
            // Whatever...
          }
        }).show();
    }
  }
});
```

創建 XML 佈局文件用於 AlertDialog 與對話框示例相同

```java
public Dialog onCreateDialog(Bundle savedInstanceState) {
  AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
  LayoutInflater inflater = requireActivity().getLayoutInflater();
  builder.setView(inflater.inflate(R.layout.dialog_demo, null))
    .setPositiveButton("確認", new DialogInterface.OnClickListener() {
      @Override
      public void onClick(DialogInterface dialog, int id) {
        dialog.cancel();
      }
    })
    .setNegativeButton("取消", new DialogInterface.OnClickListener() {
      public void onClick(DialogInterface dialog, int id) {
        dialog.cancel();
      }
    });
  return builder.create();
}
```

# 資料排序


![Alt x](../assets/img/android/datatype.png)

## List

### ArrayList

List 裡頭可能是單一基本型別如 int, String。無論是對基本型別或自訂的類別作排序我們都可以透過  - Collections.sort(List l, Comparator c)
方法來做排序而其中的 Comparator 就是排序的關鍵。


```java
List<StringIntPair> list = new ArrayList<StringIntPair>();
   list.add(new StringIntPair("ab", 5));
   list.add(new StringIntPair("ca", 3));
   list.add(new StringIntPair("aa", 2));
   list.add(new StringIntPair("db", 4));
   list.add(new StringIntPair("bc", 1));


// 依 string 排序
Collections.sort(list, new Comparator<StringIntPair>() {
    public int compare(StringIntPair o1, StringIntPair o2) {
      return o1.getString().compareTo(o2.getString());
    }
});

// 依Integer排序
Collections.sort(list, new Comparator<StringIntPair>() {
   public int compare(StringIntPair o1, StringIntPair o2) {
     return o2.getInteger()-o1.getInteger();
   }
});
```


## Map

### HashMap

把資料的 (key, value) 放入 HashMap 以後要針對特定的 key 取得 value 是非常簡單的有效的方法。

HashMap 已經達到可以利用 key 值迅速取得 value。但是如果要印出所有資料卻又不知道 key 值時。只好利用HashMap 的 entrySet() 方法取得所有資料。然後把這些資料匯入 List 中做處理
只要資料匯入 List 後就可以依照 key 或 value 排序列印。

```java
HashMap<String, Integer> transcript;

transcript = new HashMap<String, Integer>();
// 加入資料
  transcript.put("Alex", 95);
  transcript.put("Bibby", 70);
  transcript.put("Charlie", 85);
  transcript.put("David", 75);
// 取出資料
  int value = transcript.get("Bibby");

// 想依 key 列出所有資料，先將所有HashMap 裡的 entry 放入 List
List<Map.Entry<String, Integer>> list_Data = new ArrayList<Map.Entry<String, Integer>>(transcript.entrySet());

// 依 key 排序並傳回
Collections.sort(list_Data, new Comparator<Map.Entry<String, Integer>>(){
  public int compare(Map.Entry<String, Integer> entry1, Map.Entry<String, Integer> entry2){
    return (entry1.getKey().compareTo(entry2.getKey()));
  }
});

```

### TreeMap

TreeMap 會自動將存入的 key 做排序，若是想要存入 Map 並有排序的話，TreeMap 較好用。而 TreeMap 也可使用自定的排序方法。

```java
TreeMap(Comparator<? super K> comparator);
```

若有指定compartor。put 進去的鍵值對會根據 comparator 的排序規則對 key 進行排序從而進行存儲。如不提供 comparator，那麼 key 就使用自然排序。










