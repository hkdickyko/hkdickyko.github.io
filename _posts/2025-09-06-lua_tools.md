---
category: [系统]
tags: [编程, 電子]
title: lua tools
date: 2025-09-06 1:00:00
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
    text-align: center;
  }
  td.left {
    vertical-align: center;
    text-align: left;
  }  
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
  }
</style>

# Lua 共享库资源

Lua 与共享库（通常称为 C 模块或扩展）交互，通过与用 C/C++ 或其他可编译成共享库的语言编写的代码集成来扩展其功能。这使得 Lua 脚本能够利用现有的编译代码、访问系统级功能或比纯 Lua 更高效地执行计算密集型任务。

在 Lua 中可以使用 **require** 来导入其他模块，使用其内容。但也有些内容是天然就在 Lua 中的，不必做什么操作就可以直接调用。如果是在 C 中内嵌 Lua 中，则需要在一开始调用函数 **luaL_openlibs**。


## CMake 编绎共享库资源

### CMakeLists.txt 模板用作编绎共享库

```cmake
# 处理该项目所需的 CMake 最低版本
cmake_minimum_required(VERSION 4.1.1)

# XXX 为要编绎的 Lua 共享库名称
set(PROG_NAME "luasocket")
set(LUA_SRC_DIR "/data/data/com.termux/files/home")
project (${PROG_NAME}_prog)

# 共享库 C 文件在 src 目录下的名称列表
file(GLOB SRC_LIST src/*.c)

# 需要在 C 文件列表中预先移除的 C 文件，名称为 YYY 在目录內
list(GET SRC_LIST 0 FIRST_ITEM)
get_filename_component(FILE_DIRECTORY ${FIRST_ITEM} DIRECTORY)
list(REMOVE_ITEM SRC_LIST ${FILE_DIRECTORY}/YYY.c)

# 要编绎的 Lua 共享库
add_library(${PROG_NAME} SHARED ${SRC_LIST})

# 相等于编绎時的 -fpic， 配合以上的 SHARED 用于编绎动态程式库 .so
set_target_properties(${PROG_NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)

# 要链结的 Lua 头文件目录
target_include_directories(${PROG_NAME} PUBLIC ${LUA_SRC_DIR}/lua-5.4.8/src)

# 要链结的 Lua 动态程式库目录
target_link_directories(${PROG_NAME} PUBLIC ${LUA_SRC_DIR}/lua-5.4.8/build)

# 如要引入的外部程式库，可用以下例子，m 为 math 数学程式库
# target_link_libraries(${PROG_NAME} m)

# 用于设定 C 文件內的巨集条件。相等于 gcc -D 句式
# target_compile_definitions(${PROG_NAME} PUBLIC PLAT="linux")
```

请参考[C 与 lua](https://hkdickyko.github.io/%E7%B3%BB%E7%BB%9F/lua_c) 教程


## C 文件要注意事项

### C #include ＜＞ 和 #include ““ 的区别

所以，一般情况下引用标准函数库中的头文件时，用#include<> 能有更高的效率，但是其实它的查找顺序非常严格：

1. #include <>

    - 在编译器设置的 include 路径内搜索
    - 如果是在命令行中编译，则在系统的 INCLUDE 环境变量内搜索

2. #include ""

    - 在包含当前 include 指令的文件所在的文件夹内搜索
    - 如果上一步找不到，则在之前已经使用 include 指令打开过的文件所在的文件夹内搜索，如果已经有多个被 include 的文件，则按照它们被打开的相反顺序去搜索
    - 如果上一步找不到，则在编译器设置的 include 路径内搜索
    - 如果上一步找不到，则在系统的 INCLUDE 环境变量内搜索。

所以，要注意的一点就是，如果自己写的头文件，而不是标准库函数中的，那么引用这个头文件要使用 #include ""，而不能使用 #include <>，因为我们自己写的头文件并不在编译器设置的路径内，使用 #include <> 会提示无法找到。

## 列出库文件中函数名、变量名

Linux 的 nm 命令用于列出二进制对象文件（如库文件 .a, .so 或可执行文件）中的符号信息，包括函数名、变量名以及它们所在的区域。可以查找特定符号是否存在于文件中，或者找出程序引用的未定义符号。 


|参数|说明|
|:---:|:---|
|-A/-o/–print-file-name|在输出时加上文件名|
|-a/–debug-syms|输出所有符号，包含debugger-only symbols|
|-B/–format=bsd|BSD码显示，兼容MIPS nm|
|-C/–demangle|将低级符号名解析为用户级名字，可以使得 C++ 函数名更具可读性|
|-D/–dynamic|显示动态符号。该选项只对动态目标（如特定类型的共享库）有意义|
|-f format/–format=format|使用format格式输出。format可以选取 bsd、sysv 或 posix，该选项在GNU的nm中有用。默认为bsd|
|-g/–extern-only|只显示外部符号|
|-l/–line-numbers|对于每个符号，使用 debug 信息找到文件名和行号|
|-n/-v/–numeric-sort|按符号对应地址的顺序排序，而非按符号名字字符顺序排序|
|-P/–portability|按照 POSIX2.0 标准格式输出，等同于使用 -f posix|
|-p/–no-sort|按照目标文件中遇到的符号顺序显示，不排序|
|-r/–reverse-sort|反转排序|
|-s/–print-armap|当列出库成员符号时，包含索引。索引的内容：模块和其包含名字的映射|
|-u/–undefined-only|只显示未定义符号|
|–defined-only|只显示定义了的符号|


例子如下:

```sh
$ nm -D libm.so
```


## luasocket

用 cmake 编译以下的 CMakeLists.txt 文件，制作  linux 下的 luasocket 动态庫：

```cmake
cmake_minimum_required(VERSION 4.1.1)

set(PROG_NAME "luasocket")
set(LUA_SRC_DIR "/data/data/com.termux/files/home")

project (${PROG_NAME}_prog)

file(GLOB SRC_LIST src/*.c) 
list(GET SRC_LIST 0 FIRST_ITEM)
get_filename_component(FILE_DIRECTORY ${FIRST_ITEM} DIRECTORY)
list(REMOVE_ITEM SRC_LIST ${FILE_DIRECTORY}/wsocket.c)

add_library(${PROG_NAME} SHARED ${SRC_LIST})

set_target_properties(${PROG_NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)

target_include_directories(${PROG_NAME} PUBLIC ${LUA_SRC_DIR}/lua-5.4.8/src)

target_link_directories(${PROG_NAME} PUBLIC ${LUA_SRC_DIR}/lua-5.4.8/build)

target_compile_definitions(${PROG_NAME} PUBLIC PLAT="linux")
```

用以方法制作 socket.so 文件

```sh
$ cd build
$ cmake ..
$ make
```


### luasocket 库应用例子

部署 luasocket 库文件到 linux 下是受到 C 文件的 luaopen_xxx_xx 限制，其规则如下：

 - 全部 lua 文件需要放在脚本文件的目录下
 - socket.so 需要放在脚本文件目录下的 **socket** 目录中，并改名为 core.so
 - mime.so 需要放在脚本文件目录下的 **mime** 目录中，并改名为 core.so

需要这样是因为在 socket.lua 及 mime.lua 里面用 **require** 加载 C 库時，需要是要配合 C 文件的函数设定。


注意：**luaopen_xxx_xx** 是 C 文件中的入口函数，其中的 xxx 是目录， xx 则只文件名称，比如 luasocket.c 里面的入口函数是 luaopen_socket_core，所以这加载默认入口函数为脚本目录下的 socket 目录下的 core.so 或 core.lua 函数。

 - 在载入文件時 **_** 被更改为目录的 **/** ：  ./socket/core
 - 在用 **require** 加载动态库時 **_** 被更改为 **.** : require(socket.core)

为了解动态库，可以用 nm 指令列出动态库的 luaopen_xxx_xx 文件。以了解所需要的目录结构。

```sh
$ cd socket
$ nm -D core.so

000000000000a0d8 T luaopen_mime_core
0000000000009fb0 T luaopen_socket_core
000000000000d4e4 T luaopen_socket_serial
000000000000f584 T luaopen_socket_unix
```

根据以上列出函数即，在以现脚本下目录中有 socket 及 mime 兩個目录，socket 目录下有 <font color="#FF1000">3</font> 個文件，分别为 core.so， serial.so 及 unix.so。 而在mime 目录中只有 core.so 这 <font color="#FF1000">1</font> 個文件。可参考 [Lua  扩展库的动态库加载解释](https://hkdickyko.github.io/%E7%B3%BB%E7%BB%9F/lua_use)


这函数就是把两参数加起来，然后返回和。最后编译生成so文件：


```sh
$ gcc -g -Wall --shared -fPIC -o dylib/test.so dylib_test.c
```

注意：要给它建一个文件夹 dylib。因为 require 的时候会把 "dylib.test" 转成 "dylib/test" 默认去该路径下寻找 so 或者 lua 文件。


应用例子如下：

```lua
local http = require "http"

local body, status, headers, status_line = http.request("http://www.google.com")

if body then
    print("Response Body:", body)
    print("Status Code:", status)
    for k, v in pairs(headers) do
        print("Header:", k, "=", v)
    end
else
    print("Error:", status) -- In case of error, status contains the error message
end
```