---
category: [系统]
tags: [编程, 電子]
title: lua tools
date: 2025-09-06 1:00:00
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
    text-align: center;
  }
  td.left {
    vertical-align: center;
    text-align: left;
  }  
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
  }
</style>

# lua 功具资源

Lua 与共享库（通常称为 C 模块或扩展）交互，通过与用 C/C++ 或其他可编译成共享库的语言编写的代码集成来扩展其功能。这使得 Lua 脚本能够利用现有的编译代码、访问系统级功能或比纯 Lua 更高效地执行计算密集型任务。


## CMake 编绎功具资源

### CMakeLists.txt 模板

```cmake
# 处理该项目所需的 CMake 最低版本
cmake_minimum_required(VERSION 4.1.1)

# XXX 为要编绎的 Lua 共享库名称
set(PROG_NAME "luasocket")
set(LUA_SRC_DIR "/data/data/com.termux/files/home")
project (${PROG_NAME}_prog)

# 共享库 C 文件在 src 目录下的名称列表
file(GLOB SRC_LIST src/*.c)

# 需要在 C 文件列表中预先移除的 C 文件，名称为 YYY 在目录內
list(GET SRC_LIST 0 FIRST_ITEM)
get_filename_component(FILE_DIRECTORY ${FIRST_ITEM} DIRECTORY)
list(REMOVE_ITEM SRC_LIST ${FILE_DIRECTORY}/YYY.c)

# 要编绎的 Lua 共享库
add_library(${PROG_NAME} SHARED ${SRC_LIST})

# 相等于编绎時的 -fpic， 配合以上的 SHARED 用于编绎动态程式库 .so
set_target_properties(${PROG_NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)

# 要链结的 Lua 头文件目录
target_include_directories(${PROG_NAME} PUBLIC ${LUA_SRC_DIR}/lua-5.4.8/src)

# 要链结的 Lua 动态程式库目录
target_link_directories(${PROG_NAME} PUBLIC ${LUA_SRC_DIR}/lua-5.4.8/build)

# 如要引入的外部程式库，可用以下例子，m 为 math 数学程式库
# target_link_libraries(${PROG_NAME} m)

# 用于设定 C 文件內的巨集条件。相等于 gcc -D 句式
# target_compile_definitions(${PROG_NAME} PUBLIC PLAT="linux")
```

## C 文件要注意事项

### C #include ＜＞ 和 #include ““ 的区别

所以，一般情况下引用标准函数库中的头文件时，用#include<> 能有更高的效率，但是其实它的查找顺序非常严格：

1. #include <>

    - 在编译器设置的 include 路径内搜索
    - 如果是在命令行中编译，则在系统的 INCLUDE 环境变量内搜索

2. #include ""

    - 在包含当前 include 指令的文件所在的文件夹内搜索
    - 如果上一步找不到，则在之前已经使用 include 指令打开过的文件所在的文件夹内搜索，如果已经有多个被 include 的文件，则按照它们被打开的相反顺序去搜索
    - 如果上一步找不到，则在编译器设置的 include 路径内搜索
    - 如果上一步找不到，则在系统的 INCLUDE 环境变量内搜索。

所以，要注意的一点就是，如果自己写的头文件，而不是标准库函数中的，那么引用这个头文件要使用 #include ""，而不能使用 #include <>，因为我们自己写的头文件并不在编译器设置的路径内，使用 #include <> 会提示无法找到。


## luasocket

用 cmake 编译以下的 CMakeLists.txt 文件，制作  linux 下的 luasocket 动态庫：

```cmake
cmake_minimum_required(VERSION 4.1.1)

set(PROG_NAME "luasocket")
set(LUA_SRC_DIR "/data/data/com.termux/files/home")

project (${PROG_NAME}_prog)

file(GLOB SRC_LIST src/*.c) 
list(GET SRC_LIST 0 FIRST_ITEM)
get_filename_component(FILE_DIRECTORY ${FIRST_ITEM} DIRECTORY)
list(REMOVE_ITEM SRC_LIST ${FILE_DIRECTORY}/wsocket.c)

add_library(${PROG_NAME} SHARED ${SRC_LIST})

set_target_properties(${PROG_NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)

target_include_directories(${PROG_NAME} PUBLIC ${LUA_SRC_DIR}/lua-5.4.8/src)

target_link_directories(${PROG_NAME} PUBLIC ${LUA_SRC_DIR}/lua-5.4.8/build)

target_compile_definitions(${PROG_NAME} PUBLIC PLAT="linux")
```

## 列出库文件中函数名、变量名

Linux 的 nm 命令用于列出二进制对象文件（如库文件 .a, .so 或可执行文件）中的符号信息，包括函数名、变量名以及它们所在的区域。可以查找特定符号是否存在于文件中，或者找出程序引用的未定义符号。 


|参数|说明|
|:---:|:---|
|-A/-o/–print-file-name|在输出时加上文件名|
|-a/–debug-syms|输出所有符号，包含debugger-only symbols|
|-B/–format=bsd|BSD码显示，兼容MIPS nm|
|-C/–demangle|将低级符号名解析为用户级名字，可以使得 C++ 函数名更具可读性|
|-D/–dynamic|显示动态符号。该选项只对动态目标（如特定类型的共享库）有意义|
|-f format/–format=format|使用format格式输出。format可以选取 bsd、sysv 或 posix，该选项在GNU的nm中有用。默认为bsd|
|-g/–extern-only|只显示外部符号|
|-l/–line-numbers|对于每个符号，使用 debug 信息找到文件名和行号|
|-n/-v/–numeric-sort|按符号对应地址的顺序排序，而非按符号名字字符顺序排序|
|-P/–portability|按照 POSIX2.0 标准格式输出，等同于使用 -f posix|
|-p/–no-sort|按照目标文件中遇到的符号顺序显示，不排序|
|-r/–reverse-sort|反转排序|
|-s/–print-armap|当列出库成员符号时，包含索引。索引的内容：模块和其包含名字的映射|
|-u/–undefined-only|只显示未定义符号|
|–defined-only|只显示定义了的符号|


例子如下:

```sh
$ nm -D libm.so
```

## luasocket 例子

```lua
local http = require("socket.http")

local body, status, headers, status_line = http.request("http://example.com")

if body then
    print("Response Body:", body)
    print("Status Code:", status)
    for k, v in pairs(headers) do
        print("Header:", k, "=", v)
    end
else
    print("Error:", status) -- In case of error, status contains the error message
end
```