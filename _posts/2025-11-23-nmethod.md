---
category: [MPU]
tags: [IoT, 编程, 数学]
title: Numerical Methods（数值方法)
date: 2025-11-23 12:00:00
---

<style>
  table {
    width: 100%
    }
  td.left {
    vertical-align: center;
    text-align: left;
    width: 30%;
  }
  td {
    vertical-align: center;
    text-align: center;
  }
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  tr:nth-child(even){
    background-color:#ffffe5;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
  }
</style>


# Numerical Methods（数值方法)


在工程需要数值方法(Numerical Methods)之原因在于，通常能够使用微分方程式来对系统建模，需要知道系统动态响应时，就必须求解微分方程，但一般可能很难甚至无法求解出微分方程式之解析解(显解或隐式解)。在特殊情况只需要数值结果，并不需要解析。电脑计算可以快速做数值运算求得数值解。

常见的数值方法有
 
  - 尤拉法 (Euler’s Method)
  - 改进尤拉法 (Improved Euler’s Method)
  - 龙格－库塔法 (Runge–Kutta Method)

这三种属于一阶方法，即只需要建立一次导数就可以进行运算。 


对于一个给定的常微分方程初值问题：


$$
\frac {dy}{dx} = f(x,y)， y(x_0) = y_0
$$


## Euler

Euler 方法 (尤拉法) 是利用了泰勒展开式的概念去对一函数做一阶近似(即利用二维空间斜率之概念)。 而微分方程的意义本身就是变化量，所以知道了微分方程，基本上就掌握了未来的资讯量，可以在给定的条件下(初值，Initial condition以及边界，Boundary condition)预测出函数未来的长相，这也是为什么可以不需要知道解析解，即可找出系统动态的原因。


$$
y_{n+1} = y_n + h \cdot f(x_n, y_n)
$$ 


**代码详解**

 - $h$：步长
 - $x_n、y_n、y_{n+1}$：分别代表步骤 $n$ 和 $n+1$ 的时间


## Improved Euler’s Method

Improved Euler’s Method 方法 (改进尤拉法) 是使用滚动式修正，利用新预测出来的点，得到一组新的斜率，再与起始点的斜率平均，获得一组可以代表两点间斜率的一种方法(先预测斜率的概念)，最后以此修正过的斜率预测出新的点。


$$
k_1 = f(t_n, y_n)
$$

$$
k_2 = f(t_n + h, y_n + h k_1)
$$


$$
y_{n+1} = y_n + \frac{h}{2} (k_1 + k_2)
$$


**代码详解**

 - $h$：步长
 - $k_1$ 和 $k_2$：分别代表两个斜率估计值和校正值
 - $t_n、y_n、y_{n+1}$：分别代表步骤 $n$ 和 $n+1$ 的时间


## Runge-Kutta

Runge-Kutta 方法（龙格-库塔法）是一种用于求解常微分方程数值解的迭代算法。 其核心原理是透过在一个时间步长内计算多次导数的近似值，并将这些值以加权平均的方式组合起来，以获得比欧拉法更精确的下一个点的解。 简单来说，就是通过多个中间步骤来逼近真实解的曲线。  

以下是经典四阶龙格-库塔方法 (RK4) 


RK4 方法的目標是從當前點 $(x_{n},y_{n})$ 計算下一個點 $(x_{n+1},y_{n+1})$ 的近似解，其中 $x_{n+1}=x_{n}+h$，而 $h$ 是步長。它使用四個不同的斜率 $k_{1},k_{2},k_{3},k_{4}$ 的加權平均值來估計該步的平均斜率。


$$
k_1 = h f(x_n, y_n)
$$


$$
k_2 = h f\left(x_n + \frac{h}{2}, y_n + \frac{k_1}{2}\right)
$$


$$
k_3 = h f\left(x_n + \frac{h}{2}, y_n + \frac{k_2}{2}\right)
$$


$$
k_4 = h f(x_n + h, y_n + k_3)
$$


$$
y_{n+1} = y_n + \frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)
$$


**代码详解** 

 - $h$：步长
 - $k_1$：步长开始时的斜率估计值
 - $k_2$：用 $k_1$ 估计的中点处的斜率估计值
 - $k_3$：用 $k_2$ 更精确估计中点处的斜率估计值
 - $k_4$:用 $k_3$ 估计的终点处的斜率估计值
 - $y_{n+1}$：使用这四个斜率的加权平均（权重分别为 1, 2, 2, 1，总和为 6）计算出的下一个 $y$ 值