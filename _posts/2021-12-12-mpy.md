---
category: [積體電路]
tags: [IoT, 編程]
title: MicroPython 交叉編譯器
date: 2021-12-12 12:00:00
---

<style>
    table {
        width: 100%;
    }
</style>

## 用交叉編譯器從 C 代碼到 MicroPython 代碼 (mpy)

### 默認啟動頁面

![Alt cstub](../assets/img/mpy/mpyc_base.png)

- 方格<font color="#FF1000">紅色</font>內為程序名稱
 
- 方格<font color="#DDBB20">黃色</font>內為主要功能代碼

- 方格<font color="#2ACC20">綠色</font>內為各個功能函數代碼，每個函數有一套各自代碼段

重要<font color="#AA0000">注意事項</font>: 對於交叉編譯器，代碼頁的剩餘部分是固定不改變的。

## 輸入值選擇頁面

![Alt cstub](../assets/img/mpy/mpys_i.png)

 - 方格<font color="#E520FF">紫色</font>內為第一個輸入參數，為布林值    
 - 方格<font color="#FF1000">紅色</font>內為第二個輸入參數，為數組或元組  

### 輸入函數如下

 - mp\_obj\_is\_true(boolValue);
 - mp\_obj\_get\_int(intValue);
 - mp\_obj\_get\_float(floatValue));
 - mp\_obj\_str\_get\_str(stringValue, StringLength);
 - mp\_obj\_get\_array(...);

## 返回值選擇頁面

![Alt cstub](../assets/img/mpy/mpys_o.png)

 - 方格<font color="#FF1000">紅色</font>內為返回值，為數組或元組 

### 返回函數如下

 - mp\_obj\_new\_bool(boolValue);
 - mp\_obj\_new\_int(intValue);
 - mp\_obj\_new\_float(floatValue));
 - mp\_obj\_new\_str(stringValue, StringLength);
 - mp\_obj\_new\_bytes(bytesValue, bytesLength);
 - mp\_obj\_new\_tuple(tupleLength, tupleValue);
 - mp\_obj\_new\_list(listLength, listValue);
 - mp\_obj\_new\_dict(...);

## 實現交叉編譯器功能的示例

![Alt cstub](../assets/img/mpy/sample_s.png)

 - 方格<font color="#FF1000">紅色</font>內為創建函數，是為了防止錯誤的外部調用。 該函數需要在 MicroPython 調用定義之前定義。 因只是一個示例函數，所以輸入將用作返回值。


### 編譯後在Linux中輸出結果

![Alt cstub](../assets/img/mpy/sample_out.png)


## 編譯時出現問題

注意：一次只能使用一個程序上傳,以一步步的簡單方式對變量進行分組，防止複雜關係影響交叉編譯

編譯時出現問題代碼

 - ((IR_AC_Max - IR_AC_Min) > 20 & (IR_AC_Max - IR_AC_Min) < 1000)

解決的代碼 (用紅色標記)

 - (<font color="#FF1000"> ( </font>(IR_AC_Max - IR_AC_Min) > 20<font color="#FF1000"> ) </font> & <font color="#FF1000"> ( </font>(IR_AC_Max - IR_AC_Min) < 1000<font color="#FF1000"> ) </font>)

### 將部份函數如 memcpy, memset 加到代碼下，以防止編譯器調用全局頭文件引致錯誤。

```c
#ifndef min
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#endif

void* memcpy(void *dest, const void *src, size_t n)
{
  for (size_t i = 0; i < n; i++)
  {
    ((char *)dest)[i] = ((char *)src)[i];
  }
  return 0;
}

void* memset(void* b, int c, size_t len) {
    char* p = (char*)b;
    for (size_t i = 0; i != len; ++i) {
        p[i] = c;
    }
    return b;
}

size_t strlen(const char *str)
{
    const char *s;
    for (s = str; *s; ++s);
    return (s - str);
}

```

### MicroPython 平台中的示例代碼

![Alt cstub](../assets/img/mpy/mpy_code.png)

### MicroPython 平台輸出結果

![Alt cstub](../assets/img/mpy/mpy_th_out.png)

## ampy 使用

上傳文件 (*.mpy) 到 ESP32 模塊 (傳送接口為 /dev/ttyUSB0，如不是需自行更改。)

```shell
ampy --port /dev/ttyUSB0 put sample.mpy

```

### ampy 執行輸出中文的問題

MicroPython 程式執行結果的下 1 個位元組, 而 0x04 是 MicroPython 通知結束的特殊數值。這裡為了讓程式執行結果可以經由 USB 傳輸線串流顯示到電腦端, 所以採取了每收到 1 個位元組就立刻清除緩衝區強迫輸出到螢幕上的方式。這個方式對於一般的英數字沒有什麼影響, 可是若是中文字, 在 UTF-8 的編碼下, 至少會有 2 個位元組, 上述作法會把多個位元組拆散, 視為多個字元顯示, 因而造成個別位元組都是無法正常顯示的字元。

要解決這個問題, 最簡單的方式就是把函式中清除緩衝區的哪一行去掉,讓位元組連續輸出, 不要硬去清除緩衝區, 系統就不會認為個別位元組是單一字元了。

您可能會擔心把清除緩衝區的動作去除, 這樣會不會要累積一大堆輸出結果後才會在畫面上看到結果？那我們也可以這樣做, 依據 UTF-8 編碼的規則, 每收到一個完整的 UTF-8 編碼的字元就清除緩衝區強迫送出字元, 將同一函式改寫如下：

```python
utf8Char = b""
counts = 3
def stdout_write_bytes(b):
    global utf8Char, counts

    for i in b:
        curr = b'' + b    
        if curr==b'\x04':                 # end of output
            return;
        elif curr <= b'\x7f':             # 1-byte UTF-8 char
            utf8Char = curr
            counts = 0
        elif b'\xC0' <= curr <= b'\xDF':  # 2-bytes UTF-8 char
            utf8Char = curr
            counts = 1
        elif b'\xE0' <= curr <= b'\xEF':  # 3-bytes UTF-8 char
            utf8Char = curr
            counts = 2
        elif b'\xF0' <= curr <= b'\xF7':  # 4-bytes UTF-8 char
            utf8Char = curr
            counts = 3
        elif b'\x80' <= curr <= b'\xBF':  # 1 byte in a UTF-8 char
            utf8Char = utf8Char + curr
            counts = counts - 1

        if counts == 0:                   # 1 UTF-8 char readed
            print(utf8Char.decode('UTF-8'), end="")
            counts = 3                    # reset count
            utf8Char=b''
            
```            

這樣就可以使用 ampy 執行含有中文輸出的 MicroPython 程式了。


## 位元運算

位元運算位移，將每個二進制表示位元向左或向右移動預定數量的位置。 將二進制數移動位數相當於將數字乘以 $ 2^{移位數} $

- 向左移動 << = 乘 = $ 2^{移位數} $
- 向右移動 >> = 除 = $ 2^{-移位數} $

一個數字位元的二進制向一個方向移動，我們會在另一側出現一個空位。 如何填充這個空位置通常有三種可能性：
 - 填充空位為 <font color="#FF1000">0</font> 
 - 填充空位為 <font color="#FF1000">1</font>
 - 從另一側數字的二進制移出的位即<font color="#FF1000">旋轉</font>二進制數

位移多用於實現快速乘法或除法。 為了獲得這個程序的正確結果，我們必須用 0 填充空位。只有在負數除以 2 的冪的情況下，我們才需要用 1 填充左位，因為 負數表示為正數的 *two's-complement* ，即符號位為1。

對整數處理器，浮點運算會耗用相當多的資源。 如浮點運算可用整數進行操作則是一種更有效的替代方法。

**定點數學** 是一種解決方案，通常採用較大整數的形式，例如 16 位，其中最高八位是整數部分，最低八位是小數部分。 通過簡單地使用整數運算，可以有效地執行數學運算，而精度損失很小。

### 定點數學算法

第一步是定義系統要求及設定相關參數。 為了說明每個步驟，假設以下們子:
 - 從 0 到 1 且粒度為 0.01 的變量
 - 從 0 到 100 且粒度為 0.1 的變量
 - 從 -1,000 到 1,000 個，粒度為 0.01 的變量

### 整數部份

計算整數變量的最大絕對值 $ M $ ，每個示例需求的 $ M $ 值分別為 1、100 和 ±1,000。

並計算存儲這個數字所需的位數 $ x $，使得 

$$ 2^{x} \geq M \geq 2^{x -1} $$

如數字是有正負號，請在 $ x $ 上加 1。 對於我們的示例要求，$ x $ 分別為
- 1 即 $ 2^{1} = 2 \gt 1 $
- 7 即 $ 2^{7} = 128 \gt 100 $
- 11 即 $ 2^{10} = 1024 \gt 1000 $ 再因加正負號的1 即10 + 1 = 11。

**即位元數整數大於所需計的整數值**

### 小數部份

計算所需的粒度 $ G $ 。 計算提供此小數位所需的位數 $ y $，使得 

$$ \frac {1}{2^{y}} \geq  G \geq  \frac {1}{2^{y-1}} $$
 
對於我們的例子如下
 - 7 即 $ \frac {1}{128} = 0.0078125 \lt 0.01 $
 - 4 即 $ \frac {1}{16} = 0.0625 \lt 0.1 $

**即位元數的倒數小於所需計的小數值**

如要系統滿足設計需求，則所需的最小位元數是 $ x + y $。 其總和取整數如為 8、16 或 32位元。此總和將在以後稱為 *FULLSIZEINT*。 如總和大於系統中能使用的最大整數位元。則這系統不能滿足設計上的精確度要求。

### 四則運算

在四則基本運算符：+，-，× 和 ÷，必須按照如下計算

 - 在加法或減法（+ 和 -）時，該值也必須位移 $ x $
 - 在乘法和除法（× 和 ÷）時，該值則不需位移

當需要取出整數部份時，必須右移 $ x $， 如果需要小數部分，則必須將其屏蔽 $ x $

如一個32位元作為定點數學。前16位為整數部份。後16位為分數部份

```c
     integer (MSB)    fraction (LSB)
           v                 v
    0000000000000000.0000000000000000

#define SHIFT_AMOUNT 16 
#define SHIFT_MASK ((1 << SHIFT_AMOUNT) - 1)

int price = 500 << SHIFT_AMOUNT;
price += 10 << SHIFT_AMOUNT;
price *= 3;
price /= 4; 
// now our price is ((500 + 10) * 3) / 4 = 382.5

printf("price integer is %d\n", price >> SHIFT_AMOUNT);
printf("price fraction is %d\n", price & SHIFT_MASK);

printf("price fraction in decimal is %f\n", ((double)(price & SHIFT_MASK) / (1 << SHIFT_AMOUNT)));

printf("price is roughly %d.%lld\n", price >> SHIFT_AMOUNT, (long long)(price & SHIFT_MASK) * 100000 / (1 << SHIFT_AMOUNT));

```

## 倒數算法

因計算除數一般比較佔用CPU資源及對嵌入式CPU比較難於操作。所以就有以下的方法，將除法分解成加法及乘法。

### Newton's method (牛頓法)

$$ y = \frac {1}{x} = \frac {1}{\sqrt{x}} \times  \frac {1}{\sqrt{x}} $$

在互聯網上可以找到解決法 $ \frac {1}{\sqrt{x}} $  的方法

[Fast inverse square root](https://en.wikipedia.org/wiki/Fast_inverse_square_root) 


```c
#include <stdint.h>

float reciprocal(float number)
{
	const float x2 = number * 0.5F;
	const float threehalfs = 1.5F;
	
	union {
		float    f;
		uint32_t i;
	} conv = { .f = number };
	conv.i  = 0x5f3759df - ( conv.i >> 1 );
	conv.f *= threehalfs - ( x2 * conv.f * conv.f );
	conv.f *= threehalfs - ( x2 * conv.f * conv.f );
	conv.f *= threehalfs - ( x2 * conv.f * conv.f );
	return conv.f * conv.f;
}

```













