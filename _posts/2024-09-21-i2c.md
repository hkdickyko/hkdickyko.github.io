---
category: [積體電路]
tags: [IoT, 電子]
title: ESP I2C 通信总线
date: 2024-09-20 0:00:01
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
    text-align: center;
  }
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
  }
</style>

# I<sup>2</sup>C 通信总线

I<sup>2</sup>C（Inter-Integrated Circuit）通信总线，嵌入式系统设计中的一个关键组成部分，其灵活性和高效率使其在高级应用中备受青睐。关于 I<sup>2</sup>C 通信总线的深度解析，包括其基本概念、特点、通信协议，以及在不同场景下的高级应用和最佳实践。I<sup>2</sup>C 接口只有 **2** 根信号线，总线上可以连接多个设备，硬件实现简单，可扩展性强。I<sup>2</sup>C 通信协议可以用普通 GPIO 引脚进行软件模拟。I<sup>2</sup>C 接口主要用于通讯速率要求不高，以及多个器件之间通信的应用场景。

I<sup>2</sup>C 协议通信速度：

|模式|	速度|
|:---:|:---:|
|标准模式（Standard Mode）|	100kb/s|
|快速模式（Fast Mode）	|400kb/s|
|增强快速模式（Fast Mode Plus）|	1Mb/s|
|高速模式（High Speed Mode）|	3.4Mb/s|
|极速模式（Ultra-FastMode）	|5Mb/s|


## 7-bit 设备的数据传输


在开启信号后的首字节由 **7** 位从机地址和 **1** 位<font color="#FF1000">读/写</font>位组成，结构如下图：

![Alt i2c 7 bits](../assets/img/esp/i2caddress.png)

发送完这个字节之后，主机释放 **SDA** 总线等待从机给出 **ACK** 应答。如果从机给出了 **ACK** 应答，表示从机地址正确。并且已知晓是读还是写，便可以开始读写数据。如果从机没有给出 **ACK** 应答，则说明接收设备可能没有收到数据（如寻址的设备不存在或是设备正在忙碌）或无法解析收到的数据，如果是这样，则由主机来决定如何处理（停止或重启）。

## 10-bit 设备的数据传输

![Alt i2c 10bits](../assets/img/esp/i2c10bits.png)

在 10 位寻址中，从机地址在前两个字节中发送。第一个字节以特殊保留地址 <font color="#FF1000">1111 0</font>XX 开头，表示正在使用 10 位寻址。地址的 10 位编码在第一个字节的最后 2 位和第二个字节的整个 8 位中。第一个字节的第 8 位保留为 <font color="#FF1000">读/写</font> 标志。

需要了解基本的I2C帧结构：

写数据：

![Alt i2c read](../assets/img/esp/i2cw.png)

读数据：

![Alt i2c write](../assets/img/esp/i2cr.png)

## i2c_tools

I2C Tools 是一个简单但非常有用的工具，用于开发 I<sup>2</sup>C 相关应用程序，在 Linux 平台中也很有名。以下例子只是实现了基于 ESP32 控制台组件的 I<sup>2</sup>C 工具的一些基本功能。共支持五个命令行工具：

![Alt i2c write](../assets/img/esp/i2ctools.png)

 - i2cconfig：它将使用特定的 GPIO 编号、端口号和频率配置 I<sup>2</sup>C 总线
 - i2cdetect：它将扫描 I<sup>2</sup>C 总线中的设备，并输出一个表格，其中包含总线上检测到的设备列表
 - i2cget：它将读取通过 I<sup>2</sup>C 总线可见的寄存器
i2cset：它将设置通过 I<sup>2</sup>C 总线可见的寄存器
 - i2cdump：它将检查通过 I<sup>2</sup>C 总线可见的寄存器

i2c-tools 默认使用 gpio18 和 gpio19。可以使用 i2cconfig 修改 I<sup>2</sup>C 配置。这里将 I<sup>2</sup>C 的两个数据线接到 gpio18 和 gpio19。

Linux 下的 i2ctools 才有的指令

 - i2ctransfer：一次性读写多个字节

## I2C-Tools 的访问 I<sup>2</sup>C 设备的2种方式


下次有一光传感器，读出光强、距离值为例，步骤如下：

 - 复位：往寄存器 0 写入 0x4
 - 使能：往寄存器 0 写入 0x3
 - 读光强度：读寄存器 0xC、0xD 得到 **2** 字节的光强
 - 读光距离：读寄存器 OxE、OxF 得到 **2** 字节的距离值

假设根据手册得知，设备地址为 0x1E（也可通过 <font color="#FF1000">i2cdetect -y -a ×</font> 检查是否在哪个总线上，地址为 0x1E），及假设节在 I<sup>2</sup>C BUS 1 上。

### 使用 SMBus 协议


i2cdetect -y 0 



返回参数说明：

 - ‘--’：表示该地址被检测，但没有芯片应答；
 - ‘UU’：表示该地址当前由内核驱动程序使用；
 - ‘**’：**表示以十六进制表示的设备地址编号。

**i2cset** [-f] [-y] [-m MASK] [-r] [-a] I2CBUS CHIP-ADDRESS DATA-ADDRESS [VALUE] ... [MODE]

   

|指令|说明|
|:---:|:---|
|f|强制访问|
|y|指令执行自动 yes，否则会提示确认执行Continue? [Y/n] Y，不加参数 y 会有很多执行提示，可以帮助判断|
|r|写入后立即回读寄存器的值，并将结果与写入的值进行比较|
|I2CBUS|总线编号|
|CHIP-ADDRESS|i2c设备地址
|DATA-ADDRESS|i2c寄存器地址
|VALUE|要写入的值|
|MODE|指定读取的大小<br/>c (byte, no value)<br/>b (byte data, default)<br/>w (word data)<br/>i (I2C block data)<br/>s (SMBus block data)|

```
i2cset-f -y 1 0x1e 0x01 0x4
i2cset-f -y 1 0x1e 0x01 0x3
i2cget-f -y 1 0x1e Ox0c  W
i2cget-f -y 1 Ox1e Ox0e  w
```

### 使用 I<sup>2</sup>C 协议 (Linux)

**i2ctransfer** [-f] [-y] [-v] [-V] [-a] I2CBUS DESC [DATA] [DESC [DATA]]...


  I2CBUS is an integer or an I2C bus name
  DESC describes the transfer in the form: {r|w}LENGTH[@address]
    1) read/write-flag 2) LENGTH (range 0-65535) 3) I2C address (use last one if omitted)
  DATA are LENGTH bytes for a write message. They can be shortened by a suffix:
    = (keep value constant until LENGTH)
    + (increase value by 1 until LENGTH)
    - (decrease value by 1 until LENGTH)
    p (use pseudo random generator until LENGTH with value as seed)


```
i2ctransfer -f -y 1 w2＠0x1e 0x01   0x4
i2ctransfer -f -y 1 w2＠0x1e 0   0x3
i2ctransfer -f -y 1 w1＠0x1e 0xc r2
i2ctransfer -f -y 1 w1＠0x1e Oxe r2
```

![Alt i2c write](../assets/img/esp/i2ctransfer.png)


备注：在 Linux 上 i2c-tools 是通过操作 /dev 路径 i2c-× 设备文件完成，因此  kernel 必须开启 CONFIG_I2C_CHARDEV  宏控，否则会报找不到节点。