---
category: [编程]
tags: [编程, 系统]
title: C 与 lua
date: 2025-08-30 1:00:00
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
    text-align: center;
  }
  td.left {
    vertical-align: center;
    text-align: left;
  }  
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
  }
</style>

# C 与 lua 之间链接方法

在此先介绍 CMake 编绎的方法，以方便之后 C 应用之编绎。

## CMake 编译 Lua

在原档案目录下增建一个目录名称为 **build**， CMake 创建的所有内容都放置在这目录中，它會助于分离源文件和 CMake 创建的文件。我先寻找 CMake 版本号。

```sh
$ cmake --version
```

在原档案目录下创建一个名为 **CMakeLists.txt** 的文件，这是 CMake 配置文件。它包含用于构建程序的指令，以下例子为最简单的 CMakeLists.txt 文件。

```cmake
cmake_minimum_required(VERSION 4.1.1)

# 製作档案後的名称
project (lua_prog)
# 製作档案名称列表
file(GLOB SRC_LIST src/*.c)
# 用已获取的档案序列，寻找档案目录并储存到参数 FILE_DIRECTORY 內
list(GET SRC_LIST 0 FIRST_ITEM)
get_filename_component(FILE_DIRECTORY ${FIRST_ITEM} DIRECTORY)

## --- 编译 lua 程式库档案程序部份 ---
# 编译静态程式库，预先移除 lua 及 luac 执行档案程序
list(APPEND LIB_LIST ${SRC_LIST}) 
list(REMOVE_ITEM LIB_LIST ${FILE_DIRECTORY}/lua.c ${FILE_DIRECTORY}/luac.c)
# 编译静态程式库
add_library(lua STATIC ${LIB_LIST})
# 编译动态程式库
add_library(lua_so SHARED ${LIB_LIST})
# 更改编译动态程式库档案名称，因 CMake 不能重複制作档案名称
set_property(TARGET lua_so PROPERTY OUTPUT_NAME lua)

## --- 编译 lua 执行档案程序部份 ---
# 编译 lua 程式库，预先移除 luac.c 执行档案程序
list(APPEND LUA_LIST ${SRC_LIST}) 
list(REMOVE_ITEM LUA_LIST ${FILE_DIRECTORY}/luac.c)
# 编译 lua 执行档案程序
add_executable(lua_exe ${LUA_LIST}) 
# 加载外部连接编程式库， m 为数学程式库
target_link_libraries(lua_exe PRIVATE m)
# 更改编译档案名称，因 CMake 不能重複制作档案名称
set_property(TARGET lua_exe PROPERTY OUTPUT_NAME lua)

## --- 编译 luac 执行档案程序部份 ---
# 编译 luac 程式库，预先移除 lua.c 执行档案程序
list(APPEND LUAC_LIST ${SRC_LIST}) 
list(REMOVE_ITEM LUAC_LIST ${FILE_DIRECTORY}/lua.c)
# 编译 luac 执行档案程序
add_executable(luac ${LUAC_LIST})
# 加载外部连接编程式库， m 为数学程式库
target_link_libraries(luac PRIVATE m)
```

CMakeLists.txt 文件包含一组指令和说明，用于描述项目的源文件和目标。以上 CMakeLists.txt 文件为例。必须有以下部份：

**必须功能**

 - **cmake_minimun_required** 开头，指定了处理该项目所需的 CMake 最低版本。
 - **project** 指定传递给 cmake 命令的项目名称。
 - **add_executable** 添加一个可执行文件目标，该目标由指定的源文件构建。
- **add_library** 添加一个动态或静态程式库的文件目标，该目标由指定的源文件构建。


**辅助功能**

 - **target_link_libraries** 用于加载外部的 程式库。
 - **file** 可不使用，因只是将所有 C 的源文件档案变成一个序列。
 - **list** 可不使用，因只是修改 C 的源文件档案序列内容。
 - **set_property** 更改编译档案名称，因 cmake 不能重複制作档案名称。

注: **#** 为註解，以上脚本储存在 build 目录下

用以下步骤製作，所需要文件。

```sh
$ cd build
$ cmake ..
$ make
```

# 最基本从 C 程序中调用 lua 脚本

```c 
#include <lauxlib.h>
#include <lua.h>
#include <lualib.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
  int status, result;
  lua_State *L;
  // 创建的 lua 虚拟机
  L = luaL_newstate();
  // 加载 lua 所需程序库
  luaL_openlibs(L);
  // 加载 lua 脚本档案
  // --- 可变的主要程序部分 ------------------------------------
  status = luaL_loadfile(L, "main.lua");
  if (status) {
    fprintf(stderr, "档案不存在: %s\n", lua_tostring(L, -1));
    exit(1);
  }
  // 执行加载的 lua 档案
  result = lua_pcall(L, 0, LUA_MULTRET, 0);
  if (result) {
    fprintf(stderr, "脚本执行错误: %s\n", lua_tostring(L, -1));
    exit(1);
  }
  // -------------------------------------------------------
  // 关闭 lua 档案
  lua_close(L);
  // 返回 0 值为正常结束
  return 0;
}
```

可变的主要程序部分就需要更改。静态程式庫 **liblua.a** 在当前目录下。相关的 **C** 头文件也要加到 **C** 文件中。


**注解**: 
 - main.lua 是需要在 lua 计算的的程序。是每次载入程序是动态载入。

用以下步骤製作，所需要文件。动态链接库除外。

```sh
$ gcc -I ../lua-5.4.8/src -L . luabasic.c -o luabasic -l lua -l m
```

**注解**: 

 - -I 为编译时需要引人的头文件路径
 - -L 为引入的程序庫路径， <font color="#FF1000">.</font> 是代表在当前目录下
 - -o 是设定编译后执行档案的名称
 - -l 为引人的程序庫名称，即 lib<font color="#FF1000">lua</font> 及 lib<font color="#FF1000">m</font>


额外资料：用以下步骤製作动态程式库 **.so** 文件。

```sh
$ gcc -I ../lua-5.4.8/src -L . luax.c -shared -fpic -l dl -o luax -l lua -l m 
```

**注解**: 

 - -shared 创建动态链接库，用于生成 .so 文件
 - -fpic 生成位置无关代码 (Position-Independent Code)，编译共享库时必需的参数
 - -l dl 是显式加载动态函数庫


用以下方法，引入参数到 **C** 文件内的條件语句

```sh
$ gcc -D 名称
$ gcc -D 名称=值 
```

**注解**: 

 - -D 名称 是引入参数名称，在 C 文件內有條件语句可用到
 - -D 名称=值 是引入参数名称及其值，在 C 文件內有條件语句可用到

# Lua C API

以下所有的 lua 代码档案名称为 main.lua。C 程式只是列出代码片段。详细请参考前文。

## C 访问 Lua 变量

**Lua** 部份代码

```lua
data = 99;
```

**C** 部份代码片段

```c
if (luaL_dofile(L, "main.lua") == LUA_OK) {
  // 将 data 放入堆栈 (设置部分)
  lua_getglobal(L, "data"); 
  // data 位于堆栈顶部，使用 -1 (读取部份)
  lua_Number data_in_c = lua_tonumber(L, -1); 
  // 收到带有值的 lua data
  printf("%lf", data_in_c);
} else {
  printf("错误");
}
```

## C 将变量传递给 Lua

**C** 部份代码片段

```c
int data = 199;
// 将 data 推送到堆栈
lua_pushnumber(L, data); 
// 将堆栈顶部的值赋给一个变量 data
lua_setglobal(L, "data"); 
if (luaL_dofile(L, "main.lua") == LUA_OK) {
  printf("数据存入 lua 档案");
} else {
  printf("错误");
}
```

**Lua** 部份代码

```lua
print("[Lua] 输入数值 data 为 : " .. data )
```

## 访问 Lua 函数

**Lua** 部份代码

```lua
function add_2_numbers(value_1, value_2)
  print("[Lua] 输入两数值:：" .. value_1 .. " + " .. value_2 .. " = " .. value_1+value_2)
  return value_1 + value_2
end
```

**C** 部份代码片段

```c
if (luaL_dofile(L, "main.lua") == LUA_OK) {
  // 获取堆栈上的函数
  lua_getglobal(L, "add_2_numbers"); 
  if (lua_isfunction(L, -1)) { 
    // 设置第一个函数参数
    lua_pushnumber(L, 55); 
    // 设置第二个函数参数
    lua_pushnumber(L, 17); 
    // 將刚刚设置的参数推送到 Lua 堆栈
    const int arguments_count = 2 ; 
    // 函数返回 0 个值
    const int return_count = 1; 
    // 现在调用函数
    lua_pcall(L, arguments_count, return_count, 0); 
    // 读取栈顶输出结果
    lua_Number result = lua_tonumber(L, -1);
    printf("%lf", result);
  } else {
    printf("找不到函数。");
  }
} else {  
  printf("错误");
}        
```

## 从 Lua 调用 C 函数

**C** 部份代码片段

```c
int multiply_2_numbers(lua_State* L) {   
  // 函数参数位于 lua 堆栈上，最后一个参数位于顶部
  lua_Number arg_2 = lua_tonumber(L, -1);
  lua_Number arg_1 = lua_tonumber(L, -2); 
  // 计算结果
  lua_Number result = arg_2 * arg_1;  
  // 将结果推回堆栈
  lua_pushnumber(L, result);
  // 返回 1 因代表正确完成计算
  return 1;
}

// 公开函数，其操作与变量相同
lua_pushcfunction(L, multiply_2_numbers);
lua_setglobal(L, "multiply_2_numbers");
if (luaL_dofile(L, "main.lua") == LUA_OK) {
  printf("执行 lua 档案函数。")
} else {  
  printf("错误");
}    
```

**Lua** 部份代码

```lua
result = multiply_2_numbers(3,4)
print("[Lua] 调用 multiply_2_numbers(..) 并且结果是：" .. result)
```

## 访问 Lua 中的结构体（用户自订数据）

**Lua** 部份代码

```lua
data = create_data()
print("[Lua] 创建 userdata data") 
```

**C** 部份代码片段

```c
// any struct defined to pass to lua
struct Data {
  int m_x;
  int m_y;
};

// 在函数内部我们创建了 newuserdata 並反回值
int create_data(lua_State* L) {
  Data* data = static_cast<Foo*>(lua_newuserdata(L, sizeof(Data)));
  data->m_x = 0;
  data->m_y = 0;
  return 1;
}

// 在执行脚本前，将创建函数推送到 lua 堆栈并分配它以使其可调用
lua_pushcfunction(L, create_data);
lua_setglobal(L, "create_data");
if (luaL_dofile(L, "main.lua") == LUA_OK) {
  printf("执行 lua 档案函数。")
} else {
  printf("错误");
}
```

## 在 C 中读取 Lua 表 (table)

**Lua** 部份代码

```lua
data = {
  data_number = 1,
  bar_number = 2,
  data_string = "data",
  bar_string = "bar"
}
```

**C** 部份代码片段

```c
if (luaL_dofile(L, "main.lua") == LUA_OK)  {
  // 在堆栈上获取全局结构 data
  lua_getglobal(L, "data"); 
  // 验证它是否是表
  if (lua_istable(L, -1))  {
    // 获取字段 data_number，表位于堆栈顶部
    lua_getfield(L, -1, "data_number"); 
    auto data_v = lua_tonumber(L, -1); 
    // 栈顶为刚读的值。现表格位于 -2，从表中访问 bar_number
    lua_getfield(L, -2, "bar_number"); 
    auto bar_v = lua_tonumber(L, -1); 
    // 栈顶为刚读的值。现表格位于 -3，从表中访问 data_string
    lua_getfield(L, -3, "data_string"); 
    auto data_str = lua_tostring(L, -1); 
    // 栈顶为刚读的值。现表格位于 -4，从表中访问 bar_string    
    lua_getfield(L, -4, "bar_string"); 
    auto bar_str = lua_tostring(L, -1); 
    printf("%lf, %lf, %s, %s", data_v, bar_v, data_str, bar_str)
  } else { 
    printf("这不是表")
  }
} else {  
  printf("错误");
}    
```

## 在 C 中读取 Lua 数组 (array)

**Lua** 部份代码

```lua
data = {11, 22, 33}
```

**C** 部份代码片段

```c
if (luaL_dofile(L, "main.lua") == LUA_OK) {
  lua_getglobal(L, "data");
  // data 顶部，用 -1 访问，用 1 访问表中的 data[1]
  lua_rawgeti(L, -1, 1); 
  // data[1] 现在位于堆栈顶部
  auto first = lua_tonumber(L, -1); 
  // 栈顶为刚读的值。用 -2 访问表，用 2 访问表中的 data[2]  
  lua_rawgeti(L, -2, 2); 
  // data[2] 现在位于堆栈顶部
  auto second = lua_tonumber(L, -1); 
  // 栈顶为刚读的值。用 -3 访问表，用 3 访问表中的 data[3]
  lua_rawgeti(L, -3, 3); 
  // data[3] 现在位于堆栈顶部
  auto third = lua_tonumber(L, -1);
  pintf("%lf, %lf, %lf,", first, second, third);
} else {  
  printf("错误");
}    
```

## 在 C 中读取 Lua 表数组 (table array) - 方法 <font color="#FF1000">1</font>


**Lua** 部份代码

```lua
data = {
  [1] = { 
    bar = 123,
    baz = "baz",
  },
  [2] = { 
    bar = 456,
    baz = "another baz",
  }
}
```

**C** 部份代码片段

```c 
if (luaL_dofile(L, "main.lua") == LUA_OK) {
// 在堆栈上获取全局结构 data
  lua_getglobal(L, "data"); 
  // 验证它是否是表
  if (lua_istable(L, -1))  {
    // 推送 1 来访问第一个元素，data 现位于 -2
    lua_pushnumber(L, 1); 
    // 栈顶为刚压入的值。堆栈表索引变为 -2，索引是顶部的数值 1
    lua_gettable(L, -2); 
    // 验证它是否是表
    if (lua_istable(L, -1)) {
      // 像以上例子读取数据
      lua_getfield(L, -1, "bar"); 
      auto bar = lua_tonumber(L, -1);
      lua_getfield(L, -2, "baz");
      auto baz = lua_tostring(L, -1);
      printf("%lf, %s", bar , barz); 
    } 
    // 推送想要读取的下一个数组索引      
    lua_pushnumber(L, 2); 
    // 同时推送了另外四个值，表格位于前 5 位
    lua_gettable(L, -5); 
    if (lua_istable(L, -1)) {
      lua_getfield(L, -1, "bar");
      auto bar = lua_tonumber(L, -1);
      lua_getfield(L, -2, "baz");
      auto baz = lua_tostring(L, -1);
      printf("%lf, %s", bar , barz);
     }
  } else {
    printf("这不是表");
  }
} else {  
  printf("错误"); 
}
```

注意：lua_gettable 要先压入表的检索键值到栈中，才能调用。

## 在 C 中读取 Lua 表数组 (table array) - 方法 <font color="#FF1000">2</font>


以上例为 C 与 Lua 交互时，使用 lua_gettable 函数从 Lua 堆栈上的表中检索值。但其更具体的变体，如用于**字符串键**的 lua_getfield 或用于**整数键**的 lua_rawgeti 例子如下。

**C** 部份代码片段

```c
if (luaL_dofile(L, "main.lua") == LUA_OK) {
  lua_getglobal(L, "data"); 
  if (lua_istable(L, -1)) { 
    lua_getfield(L, -1, "data_1");
    if (lua_istable(L, -1)) {
      lua_getfield(L, -1, "bar"); 
      auto bar = lua_tonumber(L, -1);
      lua_getfield(L, -2, "baz");
      auto baz = lua_tostring(L, -1);
      printf("%lf, %s", bar , barz);   
    }
    lua_getfield(L, -4, "data_2");
    if (lua_istable(L, -1)) { 
      lua_getfield(L, -1, "bar");
      auto bar = lua_tonumber(L, -1);
      lua_getfield(L, -2, "baz");
      auto baz = lua_tostring(L, -1);
      printf("%lf, %s", bar , barz); 
    }
} else {
  printf("错误");
}
```

# Lua 堆栈

Lua C API 是基于堆栈的，这意味着 C 代码和 Lua 值之间的所有交互都通过虚拟堆栈进行。各种 Lua C API 函数会以特定的方式影响此堆栈，这些方式通常在官方 Lua 手册中针对每个函数进行记录。

## Lua API 函数如何影响堆栈

 - 压栈 (Pushing values)：
    - lua_pushnumber()、lua_pushstring()、lua_pushboolean()、lua_pushnil()、lua_pushcfunction()、lua_newtable() 等函数会将新值添加到栈顶。这会<font color="#FF1000">增加栈高</font>。

 - 弹出 (Popping values)：
    - lua_pop()、lua_settop() 等函数，或者 lua_call() 或 lua_pcall() 等函数（会弹出函数和参数）会隐式地从栈中移除值。这会<font color="#FF1000">降低栈高</font>。

 - 访问和修改值 (Accessing and modifying values)：
     - lua_tointeger()、lua_tostring()、lua_getfield()、lua_setfield()、lua_rawget()、lua_rawset() 等函数，可以访问或修改堆栈中特定索引处的值，而<font color="#FF1000">无需更改堆栈高度</font>。但是，某些函数可能会在运行过程中压入或弹出临时值，这些值随后会被清除。

 - 函数调用 (Function calls)：
    - 使用 lua_call() 或 lua_pcall() 从 C 语言调用 Lua 函数时，要调用的函数及其参数会被压入堆栈。调用结束后，这些参数会被弹出，Lua 函数的<font color="#FF1000">返回值也会被压入堆栈</font>。
    
 - 错误处理 (Error handling)：
    - 发生错误时，错误消息或相关值<font color="#FF1000">可能会被压入堆栈</font>，以供紧急函数或错误处理程序访问。

## 关键注意事项

 - 堆栈平衡 (Stack balance)：
    - 虽然从 Lua 调用的 C 函数不需要在返回时平衡堆栈（即，堆栈中的元素数量与进入时相同），但通过弹出不再需要的值来保持堆栈清洁是一种很好的做法，可以防止堆栈溢出并提高清晰度。

 - 堆栈索引 (Stack indice)：
    - 使用索引访问堆栈中的值。正索引表示相对于堆栈底部的绝对位置（1 表示第一个元素），而负索引表示相对于堆栈顶部的位置（-1 表示顶部元素）。

 - 堆栈增长 (Stack growth)：
    - 如果预计会推送许多值或返回参数，尤其是在通过 C 回调与 Lua 交互时，可能需要使用 lua_checkstack() 来确保有足够的堆栈空间。