---
category: [Movies]
tags: [系統, Linux]
title: ffmpeg 應用
date: 2023-06-26 1:00:00
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
  }
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
  }
</style>


# 前言

FFmpeg 是一个完整的跨平台音视频解决方案，它可以用于处理音频和视频的转码、录制、流化处理等应用场景。

[官网：http://ffmpeg.org/](http://ffmpeg.org/)


## Linux 下安装方法

```
$ apt install ffmpeg
```

FFmpeg 有三大利器，分别是 

- **ffmpeg** 主要是多媒体的编解码工具，具体功能主要包括视频裁剪，去除水印，添加 logo，提取封面，提取音频，提取视频等功能。
   - ffmpeg的主要工作流程相对比较简单如下
   
![Alt ffmpeg](../assets/img/linux/ffmpeg.png)

   - 其中需要经过六个步骤，
      - ffmpeg 首先读取输入源
      - 用 Demuxer 将音视频包进行解封装
      - 通过 Decoder 进行解码，将音视频通过Decoder 解码成为 YUV 或者 PCM 数据
      - 再通过 Encoder 将对应的数据进行编码  
      - 将编码后的音视频数据包通过 Muxer 进行封装
      - 最终输出为输出流

- **ffprobe** 是多媒体分析工具，比如音视频的参数、媒体容器的参数信息等。也可以分析媒体文件中每个包的长度、包的类型、帧的信息等。
- **ffplay** 提供了音视频显示和播放相关的图像信息，音频的波形信息等。简而言之就是一个播放器。
 
# ffmpeg-python

## 字幕样式

要改变字幕样式的外观，需要考虑包括应该支持字幕的内容、时间性和外观细节的文本文件。
给出了详细的出现顺序、时间和字幕内容。指定有关字幕外观的任何细节。要更改字幕的外观，需要通过添加新属性来修改此文本文件。

### 字幕外观的属性列表

**Font**

  - FontName：字体名称（例如 Arial、Times New Roman 等）
 
**Fontsize**

 - Fontsize：字体大小（例如 20 表示 20 点字体大小）

**Color**

 - PrimaColour：字幕的 Prima 颜色，例如，“&H00FFFFFF”表示 ABGR 格式中的白色
 - OutlineColour：文本轮廓颜色，例如 “&H80000000” 表示 ABGR 格式的半透明轮廓
 - BackColour：字幕背景颜色，例如 “&H40000000” 表示半透明 ABGR 格式的背景

**Text style**

 - Bold：使文本变为粗体（1 为启用，0 为禁用） 
 - Italic：使文本变为斜体（1 为启用，0 为禁用） 
 - Underline：为文本添加下划线（1 为激活，0 为停用） 
 - StrikeOut：删除文本（1 为激活，0 禁用）

**Borders**

 - Outline：文本轮廓厚度（例如 2 表示 2 像素轮廓）
 - BorderStyle：边框样式（0为无边框，1为单边框）
 
**Alignment**

 - Alignment：字幕的水平对齐方式（例如2为中心，7为屏幕底部）
 
**Spacing**

 - MarginL、MarginR、MarginV：左、右和垂直文本边距（例如 20 表示 20
 像素）


## 字幕样式例子

```
import ffmpeg

videoSrc = "video.mp4"
audioSrc = "audio.mp3"
outFile = "output.mp4"
srtFile = "source.srt"

style="FontName=Roboto,Bold=1,Italic=0,Fontsize=10,PrimaryColour=&H00ff3333,OutlineColour=&H20ffffff,Outline=1,BorderStyle=1"
        
input_video = ffmpeg.input(videoSrc)
input_audio = ffmpeg.input(audioSrc)
out = (ffmpeg.concat(input_video, input_audio, v=1, a=1)
       .filter('crop', w=300, h=300, x=0, y=0)
       .filter("subtitles", srtFileName, force_style=style)
       .output(outFile, vcodec='libx264', crf=iCRF, loglevel="error")
       )
ffmpeg.run(out, overwrite_output=True)
```

**concat** 将视频和音频合并到一个文件，参数
 - n 例子中没有显示，n 默认为 2。 
 - v 表示视频：将存储在第 1 部分，默认为 1。
 - a 表示音频：将存储在第 1 部分，默认为 0。 即音频将存储在每个视频流中。


**crop** 过滤器将视频裁剪或调整为任意尺寸并删除无水印的黑色边框，
 - w 表示宽度
 - h 表示高度
 - x 表示左侧
 - y 表示顶部
 
如果不设置 x 和 y ，则参考位于视频流的中央

**CRF** (恒定速率因子) 的范围是 0-51，其中 0 是无损的仅适用于8位，10位使用-qp 0，23 是默认值，51 是可能的最差质量。 一般较低的值会带来更高的质量，合理的范围是 17-28。17 或 18 在视觉上是无损的；它看起来应该与输入相同或几乎相同，但事实并非如此只是技术上无损。


## 常用函数
- compile()：编译二进制文件。
- get_ffmpeg_version()：获取FFmpeg版本号。
- get_ffprobe_version()：获取FFprobe版本号。
- get_platform()：获取平台信息。
- get_available_filters()：获取可用的过滤器列表。
- get_available_formats()：获取可用的媒体格式列表。
- input()：指定输入文件或视频流。
- output()：指定输出文件或视频流。
- run()：运行命令进行转码处理。
- filter()：为指定的输入或输出添加过滤器。
- overlay()：将视频叠加到另一个视频上。
- concat()：将多个视频合并。
- split()：将视频拆分成多个片段。
- trim()：裁剪输入视频的指定部分。
- setpts()：调整视频帧速率。
- drawtext()：在视频中添加文本。
- scale()：调整视频大小和比例。
- pad()：调整视频的宽度和高度。
- hflip()：水平翻转视频。
- vflip()：垂直翻转视频。
- transpose()：旋转90度，逆时针或顺时针旋转。
- autorotate()：根据元数据自动旋转视频。
- mute()：去除音频轨道。
- audio：指定音频参数，如采样率、声道数等。
- video：指定视频参数，如帧率、像素格式等。


## 其它

- ffmpeg.get_ffmpeg_version()：获取FFmpeg的版本号
- ffmpeg.get_ffprobe_version()：获取FFprobe的版本号
- ffmpeg.get_media_info(filename)：获取媒体文件的信息，包括时长、码率、分辨率等
- ffmpeg.get_thumbnail(filename, time, output_path)：获取视频文件指定时间的缩略图
- ffmpeg.get_video_thumbnail(filename, time, output_path)：获取视频文件指定时间的视频缩略图
- ffmpeg.get_audio_thumbnail(filename, time, output_path)：获取音频文件指定时间的音频波形图
- ffmpeg.convert(input_path, output_path, options)：将媒体文件转换为指定格式，可以指定多种转换选项
- ffmpeg.trim(input_path, output_path, start_time, duration)：剪辑媒体文件，可以指定剪辑起始时间和持续时间
- ffmpeg.concat(input_paths, output_path)：将多个媒体文件拼接成一个文件
- ffmpeg.overlay_video(overlay_path, base_path, output_path, options)：将视频文件叠加到另一个视频文件上
- ffmpeg.overlay_audio(overlay_path, base_path, output_path, options)：将音频文件叠加到另一个音频文件上
- ffmpeg.add_watermark(input_path, output_path, watermark_path, options)：给视频文件添加水印
- ffmpeg.extract_audio(input_path, output_path, options)：从视频文件中提取音频
- ffmpeg.extract_video(input_path, output_path, options)：从视频文件中提取视频
- ffmpeg.extract_subtitle(input_path, output_path, options)：从视频文件中提取字幕
- ffmpeg.extract_frame(input_path, output_path, time, options)：从视频文件中提取指定时间的帧
- ffmpeg.add_subtitle(input_path, output_path, subtitle_path, options)：给视频文件添加字幕
- ffmpeg.add_audio(input_path, output_path, audio_path, options)：给视频文件添加音频
- ffmpeg.add_video(input_path, output_path, video_path, options)：给音频文件添加视频
- ffmpeg.add_effect(input_path, output_path, effect_name, options)：给媒体文件添加特效


## 基础用法例子

使用 FFmpeg-python 裁剪视频文件的前10秒钟

```
import ffmpeg
input_file = 'input.mp4'
output_file = 'output.mp4'
# 裁剪前十秒
ffmpeg.input(input_file).trim(start=0, duration=10).output(output_file).run()
```


## 更换音频

```
$ ffmpeg -i video.mp4 -i audio.wav -map 0:v -map 1:a -c:v copy -shortest output.mp4
```
![raudio0](../assets/img/audio/replaceaudio0.png)

- map 选项允许手动选择流/轨道。 
- c:v copy 来流复制视频。不会发生视频重新编码。质量得到保证并且过程很快。如输入音频格式与输出格式兼容 -c:v copy 更改为 -c copy 以流复制视频和音频。如果重新编码视频和音频请删除 -c:v copy / -c copy。
- shortest 选项将使输出的持续时间与最短输入的持续时间相同。

```
$ ffmpeg -i video.mkv -i audio.mp3 -map 0 -map 1:a -c:v copy -shortest output.mkv
```
![raudio1](../assets/img/audio/replaceaudio1.png)

```
$ ffmpeg -i video.mkv -i audio.m4a -filter_complex "[0:a][1:a]amerge=inputs=2[a]" -map 0:v -map "[a]" -c:v copy -ac 2 -shortest output.mkv
```

![raudio2](../assets/img/audio/replaceaudio2.png)

### map 选项选择流

 map 选项用于选择输入中的哪些流应包含在输出中。还可用于排除具有负映射的特定流。

![rmap](../assets/img/audio/map-ffmpeg.png)

第一个命令不使用任何流说明符。是一种绝对的映射方法，是绝对的映射方法，无论类型如何，都会选择特定的流 即使它被指定 -map 1:3 指“第二个输入：第四个流”。

第二个命令包括流说明符（v 表示视频，a 表示音频）以将流限制为特定类型。 -map 1:a:2 指“第二个输入：仅音频：第三个音频流”。

## 背景噪音降低

- 添加带通滤波器以降低噪声水平

```
$ ffmpeg -i input_file -af "highpass=f=200, lowpass=f=3000" output_file
```

- 使用快速傅立叶变换对音频样本进行降噪, 将信号转换为单独的频谱分量.

```
$ ffmpeg -i input.mp4 -af "afftdn=nf=-25" output.mp4
```

## 音频(响度)标准化

使用 ffmpeg 对音频进行 Loudness normalization使用的时EBU R.128标准，同时也需要进行两次处理，分别获取当前音频的具体数值，以及使用获取到的具体数值作为参数用 ffmpeg 对音频进行修正。

```
$ ffmpeg -i <b>input.wav</b> -af loudnorm=I=-16:TP=-1.5:LRA=11:print_format=json -f null -

{
  "input_i" : "-23.54",
  "input_tp" : "-7.96",
  "input_lra" : "0.00",
  "input_thresh" : "-34.17",
  "output_i" : "-23.09",
  "output_tp" : "-7.51",
  "output_lra" : "0.00",
  "output_thresh" : "-33.72",
  "normalization_type" : "linear",
  "target_offset" : "7.09"
}

$ ffmpeg -y -i input.wav -af loudnorm=I=-16:TP=-1.5:LRA=11:measured_I=-23.54:measured_TP=-7.96:measured_LRA=0.00:measured_thresh=-34.1:offset=7.09:print_format=summary -ar 16k out.wav
```

注意:的是 loudnorm 过滤器使用 3 秒 的重叠音频窗口来计算源中的短期响度，从而调整目标位置以符合目标参数。所以当文件时常不足3秒时，可能输出结果会出现较大偏差，这时候可以将文件多重复几次直到足够3秒，执行标准化之后在裁剪为原来的长度。

###  响度归一化 (Loudness Normalization) 

测量源文件的积分响度，计算适当的偏移增益，然后应用补偿增益。 这是一个非常简单的算法.当没有足够的空间来进行简单的向上线性增益调整时该怎么办？ 我们应该如何处理直播的响度标准化？

- 想要将该音频的响度标准化为 -16.0 LUFS IL，最大真实峰值为 -1.5 dBTP，这些值在 AES 流响度建议范围内，我们将需要一个动态的非线性算法。

### 真实峰值（True Peak）

峰值就是波形振幅的波峰值（波形有波谷和波峰之分），说白了就是波形瞬态的最大电平值。

当峰值的持续时间超过一定的时间时（通常是几毫秒），才会计算出比较准确的峰值，而 EBU 给出了一种新的算法，无论它的持续时间有多短，都能正确的测量出其波形的真实峰值水平，故此称其为真峰值。它是用来检测信号有没有过载的，一旦信号过载就会被削波造成信号失真，正因如此，EBU给出建议为真峰值不要超过 -1 dBTP，目的就是防止信号产生过载削波，其单位为 dBTP (dB True Peak真实峰值），对应的值是dBFS值。

### 响度范围（Loudness Range, LRA）

响度范围,用来描述音频的响度反差,即音频短时响度电平的离散度,或者说最常出现的那85％的响度的分布范围,它决定着是否根据目标受众对音频的动态范围进行压缩.响度范围的大小与节目类型有关.
    
 - 流行音乐、广告等节目通常都进行了良好的压缩、激励甚至削波处理,响度范围小（一般为 2～5 LU）能量集中,听起来很破甚至非常吵闹,压迫感强烈；
 - 新闻、访谈节目的响度范围比较适中,听感较为舒适（6～10 LU）；
 - 电影、电视剧、戏曲、交响乐等节目出于艺术表现,响度范围较大（10 LU以上）,声音比较闷, 经压限处理之后才能在电视上良好地重放.

## 音频的均衡化

```
$ ffmpeg -i input.wav -af "equalizer=f=1000:width_type=h:width=200:g=-10" output.wav
```

参数说明 (可以使用逗号添加不同的频谱)
        
 - f 中心频率，单位 Hz
 - width_type 用于定义带宽，可以是 
    - h Hz
    - q Q 因子
    - o 倍频程
    - s 斜率
 - width 所选带宽的值
 - g 增益


上述命令中的 <b>equalizer</b> 是一个平衡器滤镜，它可以对指定频率范围内的音频信号进行音量调整。在例子中选择了 1000Hz 的频率范围，设置带宽宽度为 200Hz ，并在该范围内减小 10dB 的音量。