---
category: [編程]
tags: [編程]
title: Javascript 技巧
date: 2022-07-24 06:00:00
---

<style>
    table {
        width: 100%;
    }
</style>

# Javascript 有用技巧

## forEach 相比 map 返回值

forEach 和 map 都迭代元素。選擇一個而不是另一個取決於具體情況。

 - map 返回一個與原始列表相同大小的 **新數組**
 - forEach **不返回任何值**

## forEach 相比 map 應用分別

map 可以很容易地與其他數組方法 some()、every()、filter() 等鏈接。但 forEach() 不能與任何其他數組方法鏈接。
map 不會改變原始數組並返回新對象。但是，如果在數組內部使用回調，它可以改變原始對象，並返回一個只有改變元素的新數組。

## forEach 相比 map 何時使用
不使用返回的數組，不要使用 .map() 方法。如執行線性運算，可以使用 forEach() 方法。

## forEach 相比 map 速度
因此，如比較速度，普通循環總是比任何數組方法都快。在某些情況下 .map() 比 .forEach() 方法運行得更快。

![Alt text](../assets/img/misc/compare.png)

# 事件註冊、觸發與傳遞

事件註冊，我們透過 **addEventListener** 這個方法把函數註冊上去。

所有 EventTarget 的實例都有這個方法，也就是說不只是 DOM 節點，window 也是，甚至你自己 new 一個 EventTarget 的實例，都擁有這樣的能力。

addEventListener 的語法格式如下:

```js
/*
事件目標.addEventListener('事件類型',回呼函數);
*/

document.addEventListener('load', main);

function main(){
 consolelog("Success!");
}
```

以上告訴系統，我們在等待些什麼。希望能在使用者做了一些操作後（比如點擊 *click* ），及做一些什麼事情 (函數 *callback* )

註：**removeListener** 可以移除掉這個事件。

### 捕獲 (capture) 與冒泡

DOM 事件發生時，事件會先由外到內 (capturing phase)、再由內到外 (bubbling phase) 的順序來傳播。其信息流的方向，解釋如下圖:

![Alt text](../assets/img/misc/workflow.png)

在開發環境中有 87% 是冒泡的操作。所以 *addEventListener* 預設為 **冒泡操作** ，只有當 *addEventListener* 的最後一個參數設為 true 的時候，事件才會用 **捕獲操作** 方式傳遞。

### 事件停止傳遞

**stopPropogation** 用來控制<font color="#FF1000">事件不再往前傳遞</font>，這意味著不管往下（捕獲時）或是往上（冒泡時），都能停止。

**preventDefault** 防止預設行為觸發，它指的是停止瀏覽器的預設行為，<font color="#FF1000">並非事件傳遞</font>。它常常 *stopPropogation*  混淆，如果傳遞是二維的線性，那麼 default 行為就是第三維的瀏覽器行為，停止預設行為與停止事件傳遞完全是不同的事。

### 事件目標 (EventTarget) 實體註冊 & 事件目標實體觸發事件實體 (Event)

DOM 節點有一些 click()、focus()，但若是有一些自定義的事件類型，需要能有個方法把事件塞進去。那個動作正是 EventTarget 上都有的dispatchEvent 方法，我們可以透過以下方式把事件實體給塞進去。

```js
/*
事件目標.addEventListener('事件類型',回呼函數);
事件目標.dispatchEvent(事件實體);
*/
// 例子如下
element.dispatchEvent(new CustomEvent('Hello'));
```

### DOM Event 定義事件型態

JavaScript 用來監聽 (listen) 和處理 (event handling) 事件如下表:

|事件名稱|	觸發條件|
|:---:|:---|
|blur	|物件失去焦點時|
|change|	物件內容改變時|
|click	|滑鼠點擊物件時|
|dblclick|	滑鼠連點二下物件時|
|error|	當圖片或文件下載產生錯誤時|
|focus	|當物件被點擊或取得焦點時|
|keydown|	按下鍵盤按鍵時|
|keypress|	按下並放開鍵盤按鍵後|
|keyup	|按下並放開鍵盤按鍵時|
|load|	網頁或圖片完成下載時|
|mousedown	|按下滑鼠按鍵時|
|mousemove	|介於over跟out間的滑鼠移動行為|
|mouseout|	滑鼠離開某物件四周時|
|mouseover	|滑鼠進入一個元素 (包含進入該元素中的子元素) 四周時|
|mouseup	|放開滑鼠按鍵時|
|resize	|當視窗或框架大小被改變時|
|scroll|當捲軸被拉動時|
|select	|當文字被選取時|
|submit	|當按下送出按紐時|
|beforeunload	|當使用者關閉 (或離開) 網頁之前|
|unload	|當使用者關閉 (或離開) 網頁之後|

### 自定義事件型態方法

瀏覽器中使用 dispatchEvent 派發自定義事件，用以在 DOM 組件下交換信息。

1. createEvent()方法返回新創建的Event對象，支持一個參數，表示事件類型。

|參數|事件接口|初始化方法|
|:---:|:---:|:---:|
|HTMLEvents|HTMLEvent|initEvent()|
|MouseEvents|MouseEvent|initMouseEvent()|
|UIEvents|UIEvent|initUIEvent()|
|MutationEvents|MutationEvent|initMutationEvent()|

2. initEvent()方法用於初始化通過DocumentEvent接口創建的Event的值。 支持三個參數：initEvent(eventName, canBubble, preventDefault). 分別表示： 事件名稱，是否可以冒泡，是否阻止事件的默認操作。

3. dispatchEvent()就是觸發執行了，element.dispatchEvent(eventObject), 參數eventObject表示事件對象，是createEvent()方法返回的創建的Event對象。

```js
var elem = document.querySelector('#div');
var event = document.createEvent('Event');
// 定义事件名称myEvent
  event.initEvent('myEvent', true, true);
// 监听myEvent         
  elem.addEventListener('myEvent', function (e) {
    console.log(e);
  }, false);
// 使用目标对象去派发事件，可以是元素节点/事件对象
  elem.dispatchEvent(event);
```

CustomEvent 可以創建一個更具體的自定義事件，並且可以攜帶額外的參數：new CustomEvent(eventname, options)。

```js
var elem = document.querySelector('#div');
var event = document.createEvent('Event');
// 定义事件名称myEvent
  event.initEvent('myEvent', true, true);
// 监听myEvent         
  elem.addEventListener('myEvent', function(e)     
    {console.log(e.detail);}
  );
var event = new CustomEvent("myEvent", {"detail":{"username":123}});
// 使用目标对象去派发事件，可以是元素节点/事件对象
  elem.dispatchEvent(event);
// 结果输出：{username: 123}
```

## class

JavaScript 開發者有多種多樣的代碼風格，有的是函數式、有的是面向對象式。 類或者類的構造器是面向對象編程的一部分。 類可以看成創建對象的模板，這個模板可以設置一些初始值和提供一些特定的方法。

 JavaScript 通過構造函數和 **new** 操作符完全可以提供這種模板。

**get** 及 **set** 是特別字用途是使函數能像參數一般可用 = 號作設定。請參考以下例子:

```js
class sample {

  constructor(name) {
    this.id = name;
  }
    
  get name(){
    return this.name;
  }

  set name(name){
     this.name = name;
  }

  log(){
    console.log(this.name);
  }
}

let obj = new sample("test");
obj.log();
// consolelog is test

obj.name = "dicky";
obj.log();
// consolelog is dicky

let nameStr = obj.name
// nameStr is dicky
```