---
category: [編程]
tags: [編程]
title: Javascript 技巧
date: 2022-07-24 06:00:00
---

<style>
    table {
        width: 100%;
    }
</style>

# Javascript 有用技巧

## forEach 相比 map 返回值

forEach 和 map 都迭代元素。選擇一個而不是另一個取決於具體情況。

 - map 返回一個與原始列表相同大小的 **新數組**
 - forEach **不返回任何值**

## forEach 相比 map 應用分別

map 可以很容易地與其他數組方法 some()、every()、filter() 等鏈接。但 forEach() 不能與任何其他數組方法鏈接。
map 不會改變原始數組並返回新對象。但是，如果在數組內部使用回調，它可以改變原始對象，並返回一個只有改變元素的新數組。

## forEach 相比 map 何時使用
不使用返回的數組，不要使用 .map() 方法。如執行線性運算，可以使用 forEach() 方法。

## forEach 相比 map 速度
因此，如比較速度，普通循環總是比任何數組方法都快。在某些情況下 .map() 比 .forEach() 方法運行得更快。

![Alt text](../assets/img/misc/compare.png)

# 事件註冊、觸發與傳遞

事件註冊，我們透過 **addEventListener** 這個方法把函數註冊上去。

所有 EventTarget 的實例都有這個方法，也就是說不只是 DOM 節點，window 也是，甚至你自己 new 一個 EventTarget 的實例，都擁有這樣的能力。

addEventListener 的語法格式如下:

```js
/*
事件目標.addEventListener('事件類型',回呼函數);
*/

document.addEventListener('load', main);

function main(){
 consolelog("Success!");
}
```

以上告訴系統，我們在等待些什麼。希望能在使用者做了一些操作後（比如點擊 *click* ），及做一些什麼事情 (函數 *callback* )

註：**removeListener** 可以移除掉這個事件。

### 捕獲 (capture) 與冒泡

DOM 事件發生時，事件會先由外到內 (capturing phase)、再由內到外 (bubbling phase) 的順序來傳播。其信息流的方向，解釋如下圖:

![Alt text](../assets/img/misc/workflow.png)

在開發環境中有 87% 是冒泡的操作。所以 *addEventListener* 預設為 **冒泡操作** ，只有當 *addEventListener* 的最後一個參數設為 true 的時候，事件才會用 **捕獲操作** 方式傳遞。

## 事件停止傳遞

**stopPropogation** 用來控制<font color="#FF1000">事件不再往前傳遞</font>，這意味著不管往下（捕獲時）或是往上（冒泡時），都能停止。

**preventDefault** 防止預設行為觸發，它指的是停止瀏覽器的預設行為，<font color="#FF1000">並非事件傳遞</font>。它常常 *stopPropogation*  混淆，如果傳遞是二維的線性，那麼 default 行為就是第三維的瀏覽器行為，停止預設行為與停止事件傳遞完全是不同的事。

## 事件目標 (EventTarget) 實體註冊 & 事件目標實體觸發事件實體 (Event)

DOM 節點有一些 click()、focus()，但若是有一些自定義的事件類型，需要能有個方法把事件塞進去。那個動作正是 EventTarget 上都有的dispatchEvent 方法，我們可以透過以下方式把事件實體給塞進去。

```js
/*
事件目標.addEventListener('事件類型',回呼函數);
事件目標.dispatchEvent(事件實體);
*/
// 例子如下
element.dispatchEvent(new CustomEvent('Hello'));
```

### DOM Event 定義事件型態

JavaScript 用來監聽 (listen) 和處理 (event handling) 事件如下表:

|事件名稱|	觸發條件|
|:---:|:---|
|blur	|物件失去焦點時|
|change|	物件內容改變時|
|click	|滑鼠點擊物件時|
|dblclick|	滑鼠連點二下物件時|
|error|	當圖片或文件下載產生錯誤時|
|focus	|當物件被點擊或取得焦點時|
|keydown|	按下鍵盤按鍵時|
|keypress|	按下並放開鍵盤按鍵後|
|keyup	|按下並放開鍵盤按鍵時|
|load|	網頁或圖片完成下載時|
|mousedown	|按下滑鼠按鍵時|
|mousemove	|介於over跟out間的滑鼠移動行為|
|mouseout|	滑鼠離開某物件四周時|
|mouseover	|滑鼠進入一個元素 (包含進入該元素中的子元素) 四周時|
|mouseup	|放開滑鼠按鍵時|
|resize	|當視窗或框架大小被改變時|
|scroll|當捲軸被拉動時|
|select	|當文字被選取時|
|submit	|當按下送出按紐時|
|beforeunload	|當使用者關閉 (或離開) 網頁之前|
|unload	|當使用者關閉 (或離開) 網頁之後|

## 自定義事件型態方法

瀏覽器中使用 dispatchEvent 派發自定義事件，用以在 DOM 組件下交換信息。

1. createEvent()方法返回新創建的Event對象，支持一個參數，表示事件類型。

|參數|事件接口|初始化方法|
|:---:|:---:|:---:|
|HTMLEvents|HTMLEvent|initEvent()|
|MouseEvents|MouseEvent|initMouseEvent()|
|UIEvents|UIEvent|initUIEvent()|
|MutationEvents|MutationEvent|initMutationEvent()|

2. initEvent()方法用於初始化通過DocumentEvent接口創建的Event的值。 支持三個參數：initEvent(eventName, canBubble, preventDefault). 分別表示： 事件名稱，是否可以冒泡，是否阻止事件的默認操作。

3. dispatchEvent()就是觸發執行了，element.dispatchEvent(eventObject), 參數eventObject表示事件對象，是createEvent()方法返回的創建的Event對象。

```js
var elem = document.querySelector('#div');
var event = document.createEvent('Event');
// 定义事件名称myEvent
  event.initEvent('myEvent', true, true);
// 监听myEvent
  elem.addEventListener('myEvent', function (e) {
    console.log(e);
  }, false);
// 使用目标对象去派发事件，可以是元素节点/事件对象
  elem.dispatchEvent(event);
```

CustomEvent 可以創建一個更具體的自定義事件，並且可以攜帶額外的參數：new CustomEvent(eventname, options)。

```js
var elem = document.querySelector('#div');
var event = document.createEvent('Event');
// 定义事件名称myEvent
  event.initEvent('myEvent', true, true);
// 监听myEvent
  elem.addEventListener('myEvent', function(e)
    {console.log(e.detail);}
  );
var event = new CustomEvent("myEvent", {"detail":{"username":123}});
// 使用目标对象去派发事件，可以是元素节点/事件对象
  elem.dispatchEvent(event);
// 结果输出：{username: 123}
```
## JavaScript 中調用、應用和綁定方法的快速指南

函數原型鏈的調用、應用和綁定方法是 JavaScript 中一些最重要和最常用的概念，並且與 this 關鍵字密切相關。

![Alt text](../assets/img/misc/variablejs.png)


### **call** 調用方法

 - 可以進行函數/方法借用，可以從其他對像中借用函數並將其與其他對象的數據一起使用。
 - 使用 call()，可以編寫一次方法，然後在另一個對像中繼承它，而無需為新對象重寫方法。
 - 在 call 方法中，第一個參數將是引用或我們希望 *this* 指向的內容。
 - 後面的參數可以是該函數的參數。 可以傳遞任意數量的以逗號分隔的參數。

```js
func.call([thisArg[, arg1, arg2, ...argN]])
```

參數：
 - thisArg 是可選。 是調用 func 時用作 this 的值。
 - arg1, arg2, ...argN 函數的可選參數。

返回值：
  - 指定的 this 值和參數調用函數的結果。

### **apply** 應用方法

 - 可以編寫一次方法，然後在另一個對像中繼承它，而無需為新對象重寫方法。
 - apply 與 call() 非常相似，除了它支持的參數類型。通過 apply，還可以使用數組字面量。
 - argsArray 使用參數。 arguments 是函數的局部變量。 它可用於被調用對象的所有未指定參數。 因此，當您使用 apply 方法時，**不必知道被調用對象的參數**。
 - 給定的 this 值調用函數，並以**數組**（或類似數組的對象）的形式提供參數。

```js
func.apply(thisArg, [argsArray])
```

參數：
 - thisArg 為調用 func 提供的 this 值。
 - argsArray 是可選。 一個類似數組的對象，指定調用 func 時應使用的參數，如果不應向函數提供參數，則為 null 或 undefined。


請注意，這可能不是方法看到的實際值：如果方法是非嚴格模式代碼中的函數，null 和 undefined 將被替換為全局對象，原始值將被裝箱。 該參數是必需的。

返回值：
  - 指定的 this 值和參數調用函數的結果。

### **bind** 應用方法

 - 函數創建一個新的綁定函數，它是一個包裝原始函數對象的奇異函數對象。調用綁定函數通常會導致其包裝函數的執行。
 - bind 方法看起來和 call 方法完全一樣，但唯一的區別是這裡不是直接調用這個方法，而是 bind 方法將此方法與對象綁定並返回該方法的**副本**。
 - 裡有一個問題，它不會直接調用該方法，而是會返回一個可以稍後調用的方法。這基本上用於綁定並保留該方法的副本並稍後使用它。


綁定方法
bind() 方法返回一個新函數，當被調用時，它的 this 設置為一個特定的值。

```js
func.bind(thisArg[, arg1[, arg2[, ...]]])
```

參數：
 - thisArg 調用綁定函數時作為 this 參數傳遞給 func。如果沒有為 bind 提供參數 this，或為 null 或未定義，則執行範圍的 this 將被視為新函數。
 - arg1, arg2, ...argN 是可選。 調用 func 時提供給綁定函數的參數前面的參數。

返回值：
 - 指定 this 值和初始參數（如果提供）的給定函數的副本。


## class

JavaScript 開發者有多種多樣的代碼風格，有的是函數式、有的是面向對象式。 類或者類的構造器是面向對象編程的一部分。 類可以看成創建對象的模板，這個模板可以設置一些初始值和提供一些特定的方法。

 JavaScript 通過構造函數和 **new** 操作符完全可以提供這種模板。

**get** 及 **set** 是特別字用途是使函數能像參數一般可用 = 號作設定。請參考以下例子:

```js
class sample {

  constructor(name) {
    this.id = name;
  }

  get name(){
    return this.name;
  }

  set name(name){
     this.name = name;
  }

  log(){
    console.log(this.name);
  }
}

let obj = new sample("test");
obj.log();
// consolelog is test

obj.name = "dicky";
obj.log();
// consolelog is dicky

let nameStr = obj.name
// nameStr is dicky
```
