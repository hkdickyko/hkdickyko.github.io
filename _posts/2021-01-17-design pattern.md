---
category: 編程 
tags: [設計模式]
---


# 設計模式

設計模式（design pattern）是軟體設計中普遍存在`反覆出現`的各種問題，提出具體的解決方案。

`物件導向`設計模式通常以`類別`或`物件`來描述其中的關係和相互作用，但不涉及完成應用程式的特定類別或物件。

`設計模式`不直接用來完成程式碼的編寫，而是描述不同情況下，怎麼解決問題的一種方案，是指軟體「設計」層次上的問題。避免引起麻煩的`緊耦合`，以增強軟體設計面對並適應變化的能力。

`演算法`不能算是一種設計模式，因為演算法主要是用來解決計算上的問題。

# 建立型模式

 建立型模式我們希望達到不自己創建物件的效果(在程式碼中不使用new)，把創建的過程封裝起來，從而達到單一實例、提升效能、容易擴充，等等的好處。

  - 單例模式 (Singleton)
    > 只有`一個`實例，而且自行實例化並向整個系統提供這個實例。可以確保線程安全，保證物件唯一性。

  - 抽象工廠模式 (Abstract Factory)
    > 是提供一個建立一系列相關或互相依賴物件的介面，而無需指定它們具體的類別。

  - 工廠方法模式 (Factory Method Pattern)
    > 定義一個用於建立類別的介面，讓子類別決定從`多個`類別中實體化哪`一個`類別。使類別的實例化延遲到其子類別。

  - 建造者模式 (Builder Pattern)
    > 是設計來提供一個有彈性解決方案，用OOP的方式來解決一個不同`複雜`物件的創造。目的是為了要分離一個複雜物品的建造和表示建造的方式。

  - 原形模式 (Prototype Pattern)
    > 是從一個物件`透過拷貝`，不需要知道任何建立的細節。由於是`直接在記憶體中進行二進位資料的拷貝`，比起使用建構式產生物件的方式效能好很多。在建構複雜的狀況下還可以簡化所需要的程式碼、提升程式碼的可讀性。


# 結構型模式

 結構型模式整理既有的類別，並且將這些類別做一些適當的轉換，最終達到更容易使用、更加靈活、變化他們的表示···等等的效果。

  - 轉接器模式 (Adapter Pattern)
    > 也被稱為wrapper，用一個介面來`轉換另一個已存在類別的介面`。這是經常被使用來用一個已存在的類別，用一個介面來包裝已存在類別使兩個不相容的類別可以共同工作。

  - 橋接模式 (Bridge Pattern )
    > 是將抽象部分與實現部分分離，使它們都可以獨立地變化。一個原則「多用組合、少用繼承」。也就是盡量用`組合`或`聚合`來代替類別繼承，這樣可以提高自由度，並且在各個類別的種類增加時，用少量的程式碼組合出系統。

  - 組合模式 (Composite Pattern) 
    > 是將物件組合成樹形結構以表示「部分-整體」的層次結構。組合模式使得用戶對單個物件和組合物件的使用具有一致性。在組合模式中所有的物件都是整體的一部分，而整體是物件的`集合`。

  - 裝飾模式 (Decorator)
    > 動態的給一個類別添加額外的功能。相比產生子類別更為靈活。設計的原則是透過某種方式封裝可能的變化，並且減少類別之間的互相影響`降低耦合度`。

  - 外觀模式 (Facade Pattern)
    > 是為子系統提供一個`一致`的介面或功能，使得這一子系統更加容易使用。並且可以當作是一個重構過程的起點。

  - 享元模式 (Flyweight Pattern)
    > 是需要`共用`程式碼或`共有`一份實體，是物件池的一種實作。避免需要大量創建物件的狀況，使物件的使用更有效（可以減少記憶體的使用量）。

  - 代理模式 (Proxy Pattern)
    > 是為其他物件提供一種代理以控制對這個物件的存取。使用的時機是在`存取權利需要控制時`或`在存取時需要提供其他的功能時`。


# 行為型模式

 行為型模式為設計模式的一種類型，用來識別對象之間的常用交流模式並加以實現。如此，可在進行這些交流活動時增強彈性。

  - 觀察者模式 (Observer Pattern)
    > 是一種一對多的依賴關係，當物件的狀態改變，所有依賴於它的物件都會得到通知並被`自動更新`。

  - 範本方法模式 (TemplateMethod Pattern) 
    > 是把某些行為或定義推遲到子類別實現，所以可以很簡單的在不改變程式基礎骨架的狀況下，`繼承範本`方法，拓展不同的行為方式。

  - 命令模式 (Command Pattern)
    > 有三個主要角色，`Invoker`，`ICommand` 和`Receiver`，是對進行封裝的典型模式，將命令的命令接收`請求`跟執行命令`實際`之間切分開來。

  - 狀態模式 (State Pattern)
    > 是一個物件的內在狀態改變時`允許改變其行為`，這個物件看起來像是改變了其類別。

  - 責任鍊模式 (Chain of Responsibility Pattern)
    > 是多個物件都有機會處理請求，從而使發送者和接收者之間`避免耦合關係`。這將物件連成一條鏈，並沿著這條鏈傳遞該請求，直到有一個物件處理它為止。發出請求的客戶端不用知道最終是誰處理。

  - 解譯器模式 (Interpreter Pattern)
    > 是一種語法的表示，當一個語言中的句子，可以使用`抽象的語法樹表示`的時候，就適合使用這模式。

  - 仲介者模式 (Mediator Pattern)
    > 是一個仲介物件來封裝一系列的物件互動。仲介者使個物件不需要顯式地互相參考，從而使其`耦合鬆散`，而且可以獨立地改變它們之間的互動。

  - 訪問者模式 (Visitor Pattern)
    > 是一個作用於某物件結構中的各元素之操作。它使你可以再不改變各元素之類別的前提之下，定義作用於這些元素的新操作。將`處理`和`資料結構`兩者分離開來。
    
  - 策略模式 (Strategy Pattern)
    > 定義一個介面`替換方法`，經由替換不同方法。使得物件擁有不同的行為或`演算法`。

  - 備忘錄模式 (Memoto Pattern)
    > 是在不破壞封裝性的前提之下，捕獲一個物件的內部狀態，並在該物件之外保存這個狀態。這樣以後就可將該物件恢復到原先保存的狀態，即`Undo`和`Redo`。

  - 迭代器模式 (Iterator Pattern)
    > 是一種方法依序存取一個聚合物件中各個元素，而又`不暴露`該物件的內部表示。

# 結論

    設計模式沒有高下之分，而是系統設計的思考方式，使程式設計者能夠主要關注於程式內容。
    以上的各種模式只是提供方法減少程式耦合和解決一些經常遇到的問題。需要使用者根據需求而自行選擇使用。