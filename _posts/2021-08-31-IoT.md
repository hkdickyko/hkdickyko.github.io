---
category: [積體電路, 編程]
tags: [IoT]
---

# MicroPython 在 ESP32 內的安裝方法

MicroPython 有 Python許多迷你化的標準函式庫，也有例如 *machine*、*network* 等硬體相關的專屬函式庫用於控制硬體相關功能

- 源代碼下載地址 : [MicroPython](https://micropython.org/download/)

## 改裝 ESP32 開發板


網址下載 [ESP32 的 microPython 內核](https://micropython.org/download/esp32/)，下載已編譯的 **MicroPython** 版的 **ESP32** 內核，用以燒錄到 ESP32 的開發版內。


燒錄方法如下:


- 安裝 **esptool** 作燒錄 ESP 開發版之工具
- *esp32-20180511-v1.9.4.bin* 為 **MicroPython** 版預制的 **ESP32** 內核，其中 *20180511-v1.9.4* 為預製內核的開發日期及版本號碼
- */dev/ttyUSB0* 為 *USB* 接口地址

 

```
$ pip install esptool
$ esptool.py --chip esp32 --port /dev/ttyUSB0 write_flash -z 0x1000 esp32-20180511-v1.9.4.bin

```

ESP 開發板圖示如下

![Alt ESP32]({{ '/assets/img/IoT/esp32.png' | relative_url }})


## 安裝 **ampy** 來將*microPython* 上傳/下載文件 *ESP32* 到開發扳內

- */dev/ttyUSB0* 為 *USB* 接口地址

```
$ sudo pip3 install adafruit-ampy
$ echo "export AMPY_PORT='/dev/ttyUSB0'" >> ~/.bashrc

```

---

|            ampy 指令            |       指令描述        |
|:-------------------------------|:--------------------:|
| ampy ls                        | 列出目錄文件 |
| ampy rm "abc" | 删除目錄文件 |
| ampy mkdir "abc" | 創建目錄 |
| ampy rmdir "abc" | 删除目录 |
| ampy put src.py dest.py   | 上傳目錄文件 |
| ampy get src.py dest.py   | 下載目錄文件 |
 


## 安裝 *minicom* 測試 *ESP32* 到開發扳串口連接 

```
$ dmesg | grep tty
$ sudo apt-get install minicom
$ sudo minicom -D /dev/ttyUSB0
$ minicom

```


## 安裝 *Thonny* 處理輸入和輸出 *ESP32* 到開發扳

```
$ sudo apt install python3 python3-pip python3-tk
$ bash <(wget -O - https://thonny.org/installer-for-linux)

```

選擇 *ESP32* 到開發扳如下所示，文件上傳、下載可直接使用程序功能

![Alt thonny]({{ '/assets/img/IoT/thonny.png' | relative_url }})

## MicroPython 資料

常用的 MicroPython 指令

- help('modules')
- help('module')
- dir('modules')

常用的 MicroPython 檔案

- boot.py – 該腳本在開發板啟動時執行為開發板設置各種配置選項
- main.py – 這是 *Python* 程序的主腳本在 *boot.py* 之後執行

### ESP32資料 

boot.py 包括WiFi基本命令設置, 帶檢查內存大小的命令 

 - SSID, PASSWORD - 必須根據你的家庭WiFi設置修訂
 
```
import network
import utime
import ubinascii
import gc

__sta=None

def connectWifi(ssid, pwd):
  global __sta
  if __sta is None:
    __sta=network.WLAN(network.STA_IF)
    __sta.active(True)    
    __sta.connect(ssid, pwd)
    print('Connecting to WiFi STA ...')
    utime.sleep(8)
  if __sta.isconnected():
    print('Connected: {} : {}.'.format(ssid, __sta.ifconfig()[0]))
  else:
    print('{} connect failure!'.format(ssid))
    return None

def scanAP():
  global __sta
  if __sta is None:
    __sta=network.WLAN(network.STA_IF)
  __sta.active(True)
  aps=__sta.scan()
  for ap in aps:
    ssid=ap[0].decode()
    mac=ubinascii.hexlify(ap[1], ':').decode()
    rssi=str(ap[3])+'dBm'
    print('{:>20} {:>20} {:>10}'.format(ssid, mac, rssi))

def getIP():
  global __sta
  if __sta is None:
    print("Not connect yet!")
  else:
    return __sta.ifconfig()

def df(dir='/'):
  from os import statvfs
  s=statvfs(dir)
  print((s[0]*s[3]) / 1048576,'MB') 

connectWifi(SSID, PASSWORD)
gc.collect()
print("---------------------------------------")

```

webserver.py 處理 *JSON* 的最小網絡服務器

```
try:
  import usocket as socket
except:
  import socket
import ujson
import gc
import utime

__html=None
__jSonStr=None
__webserver=None
__callback=None

def init(port):
  global __webserver
  __webserver=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  __webserver.bind(('', port))
  __webserver.listen(5)
 
def html_page(filename):
  global __html
  if __html is None:
    f=open(filename)
    __html=f.read()
    f.close()

def callback(pCallback):
  global __callback
  __callback=pCallback;

def loop():
  global __webserver
  global __jSonStr
  global __html
  response="Error!"
  while True:
    conn,addr=__webserver.accept()
    if not __html is None:
      response=__html
    request=conn.recv(1024)
    request=str(request)
    if __jSonStr is None:
      pt0=request.find("{")
      pt1=request.find("}")+1
      if pt0 < 10:
        __jSonStr=request[pt0:pt1]
        if __jSonStr.find("{")==0:
          __jSonStr=urldecode(__jSonStr)
          parsed=ujson.loads(__jSonStr) 
          updateStatus(parsed)
        __jSonStr=None
    conn.send('HTTP/1.1 200 OK\n')
    conn.send('Content-Type: text/html\n')
    conn.send('Connection: close\n\n')
    conn.sendall(response)
    conn.close()
    gc.collect()
      
def urldecode(strV): 
  dic={"%21":"!","%22":'"',"%23":"#","%24":"$","%26":"&","%27":"\"","%28":"(","%29":")","%2A":"*","%2B":"+","%2C":",","%2F":"/","%3A":":","%3B":";","%3D":"=","%3F":"?","%40":"@","%5B":"[","%5D":"]","%7B":"{","%7D":"}"}
  for k,v in dic.items():
    strV=strV.replace(k,v)
  return strV

def updateStatus(jlist):
  global __callback
  if not __callback is None:
    __callback(jlist)
  else:
    print("callback not set!")

```

index.html

```
<html>
<head>
  <title>ESP Web Server</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="data:,">
  <style>
    html {
      font-family: Helvetica;
      display: inline-block;
      margin: 0px auto;
      text-align: center;
    }
    h1 {
      color: #0F3376;
      padding: 2vh;
    }
    .button {
      display: inline-block;
      background-color: #e7bd3b;
      border: none;
      border-radius: 4px;
      color: white;
      padding: 16px 40px;
      text-decoration: none;
      font-size: 30px;
      margin: 2px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>ESP Web Server</h1> 
  <a href=\"?{'led_1':'on','led_2':'off','led_3':'on'}\"><button class="button">Action</button></a>
</body>
</html> 

```

main.py - 處理最小網絡功能的示例

```
import webserver

def updateStatus(jlist):
  print(jlist["led_1"])
  print(jlist["led_2"])
  print(jlist["led_3"])

webserver.init(8080)
webserver.html_page("index.html")
webserver.callback(updateStatus)
webserver.loop()

```

![Alt website]({{ '/assets/img/IoT/espwebsite.png' | relative_url }})


### ESP32 **GPIO**

```
from machine import Pin

led = Pin(2, Pin.OUT)
button = Pin(15, Pin.IN)

```


### ESP **MQTT** basic tool

```
import machine
import utime
import network
from lib.umqtt.simple2 import MQTTClient as _MQTTClient

wifiOptions = {
    'ssid': SSID_of_Wifi,
    'pwd': Pasword_of_Wifi
    }

mqttOptions = {
    'mID': MQTT_Client_ID,
    'IP': IP_of_mqtt_broker,
    'port': PORT_of_mqtt_broker,
    'user': User_Name,
    'pwd': User_Password,
    'qos': 1,
    'timeout':30
    }

class mqttClient:
    
    def __init__(self, mqttOptions): 
        self.client = None
        self.wifi = None
        self.qos = 1
        self.timeout = 30
        self.user = mqttOptions['user']
        self.pwd = mqttOptions['pwd']
        self.ID = mqttOptions['mID']
        self.IP = mqttOptions['IP']
        self.port = mqttOptions['port']
        self.callback = None;
        if 'qos' in mqttOptions.keys():
            self.qos = mqttOptions['qos']
        if 'timeout' in mqttOptions.keys():
            self.timeout = mqttOptions['timeout']
            
    def setCallback(self, callback):
        self.callback = callback
     
    def _sub_callback(self, topic, msg, retained, dup):
        if not self.callback is None:
            self.callback(topic.decode('ascii'), msg.decode('ascii'))
        else:
            print('TOPIC: {},  MSG: {}'.format(topic.decode('ascii'), msg.decode('ascii')))

    def publish(self, topic, message):
        self.client.publish(topic, message, qos=self.qos)
        for i in range(self.timeout):
            utime.sleep_ms(100)

    def subscribe(self, topic):
        self.client.subscribe(topic)
        for i in range(self.timeout):
            utime.sleep(1)
            self.client.check_msg()

    def connect(self, options):
        print("--------------------------")
        self.client = _MQTTClient(self.ID, self.IP, port=self.port, user=self.user, password=self.pwd)
        self.wifi = connectWifi(options['ssid'], options['pwd']) 
        self.client.set_callback(self._sub_callback)
        self.client.connect()

    def disconnect(self):
        self.client.disconnect()    
        self.wifi.active(False)
        print("--------------------------")

def callback(topic, msg):
    print('Callback Value: {} : {}'.format(topic, msg))

test = mqttClient(mqttOptions)
test.setCallback(callback)
test.connect(wifiOptions)

test.publish("temp", "test QoS 1 test -----------------")
test.subscribe("temp")

test.disconnect()

```