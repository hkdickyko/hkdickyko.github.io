---
category: [積體電路, 編程]
tags: [IoT]
---

# MicroPython 在 ESP32 內的安裝方法

MicroPython 有 Python許多迷你化的標準函式庫，也有例如 *machine*、*network* 等硬體相關的專屬函式庫用於控制硬體相關功能

- 源代碼下載地址 : [MicroPython](https://micropython.org/download/)

## 改裝 ESP32 開發板


網址下載 [ESP32 的 microPython 內核](https://micropython.org/download/esp32/)，下載已編譯的 **MicroPython** 版的 **ESP32** 內核，用以燒錄到 ESP32 的開發版內。


燒錄方法如下:


- 安裝 **esptool** 作燒錄 ESP 開發版之工具
- *esp32-20180511-v1.9.4.bin* 為 **MicroPython** 版預制的 **ESP32** 內核，其中 *20180511-v1.9.4* 為預製內核的開發日期及版本號碼
- */dev/ttyUSB0* 為 *USB* 接口地址

 

```
$ pip install esptool
$ esptool.py --chip esp32 --port /dev/ttyUSB0 write_flash -z 0x1000 esp32-20180511-v1.9.4.bin

```

ESP 開發板圖示如下

![Alt ESP32]({{ '/assets/img/IoT/esp32.png' | relative_url }})


## 安裝 **ampy** 來將*microPython* 上傳/下載文件 *ESP32* 到開發扳內

- */dev/ttyUSB0* 為 *USB* 接口地址

```
$ sudo pip3 install adafruit-ampy
$ echo "export AMPY_PORT='/dev/ttyUSB0'" >> ~/.bashrc

```

---

|            ampy 指令            |       指令描述        |
|:-------------------------------|:--------------------:|
| ampy ls                        | 列出目錄文件 |
| ampy rm "abc" | 删除目錄文件 |
| ampy mkdir "abc" | 創建目錄 |
| ampy rmdir "abc" | 删除目录 |
| ampy put src.py dest.py   | 上傳目錄文件 |
| ampy get src.py dest.py   | 下載目錄文件 |
 


## 安裝 *minicom* 測試 *ESP32* 到開發扳串口連接 

```
$ dmesg | grep tty
$ sudo apt-get install minicom
$ sudo minicom -D /dev/ttyUSB0
$ minicom

```


## 安裝 *Thonny* 處理輸入和輸出 *ESP32* 到開發扳

```
$ sudo apt install python3 python3-pip python3-tk
$ bash <(wget -O - https://thonny.org/installer-for-linux)

```

選擇 *ESP32* 到開發扳如下所示，文件上傳、下載可直接使用程序功能

![Alt thonny]({{ '/assets/img/IoT/thonny.png' | relative_url }})

## MicroPython 資料

常用的 MicroPython 指令

- help('modules')
- help('module')
- dir('modules')

常用的 MicroPython 檔案

- boot.py – 該腳本在開發板啟動時執行為開發板設置各種配置選項
- main.py – 這是 *Python* 程序的主腳本在 *boot.py* 之後執行

### ESP32資料 

ESP32 的 boot.py (包括WiFi基本命令設置, 帶檢查內存大小的命令)
```
import machine
import esp32
import network
import utime
import ubinascii
import gc

sta = None

def connectWifi(ssid, pwd):
    global sta
    if sta is None:
        sta = network.WLAN(network.STA_IF)
        sta.active(True)    
        sta.connect(ssid, pwd)
        print('Connecting to WiFi STA ...')
        utime.sleep(8)
    if sta.isconnected():
        print('Connected: {} : {}.'.format(ssid, sta.ifconfig()[0]))
        return sta
    else:
        print('{} connect failure!'.format(ssid))
        return None

def scanAP():
    global sta
    if sta is None:
        sta=network.WLAN(network.STA_IF)
    sta.active(True)
    aps = sta.scan()
    for ap in aps:
        ssid=ap[0].decode()
        mac=ubinascii.hexlify(ap[1], ':').decode()
        rssi=str(ap[3]) + 'dBm'
        print('{:>20} {:>20} {:>10}'.format(ssid, mac, rssi))

def getIP():
    global sta
    if sta is None:
        print("No connect yet!")
    else:
        return sta.ifconfig()

def df(dir='/'):
    from os import statvfs
    s = statvfs(dir)
    print((s[0]*s[3]) / 1048576,'MB') 

connectWifi(SSID, PASSWORD)
print("---------------------------------------")

```

### ESP32 **GPIO**

```
from machine import Pin

led = Pin(2, Pin.OUT)
button = Pin(15, Pin.IN)

```


### ESP **MQTT** basic tool

```
import machine
import utime
import network
from lib.umqtt.simple2 import MQTTClient as _MQTTClient

wifiOptions = {
    'ssid': SSID_of_Wifi,
    'pwd': Pasword_of_Wifi
    }

mqttOptions = {
    'mID': MQTT_Client_ID,
    'IP': IP_of_mqtt_broker,
    'port': PORT_of_mqtt_broker,
    'user': User_Name,
    'pwd': User_Password,
    'qos': 1,
    'timeout':30
    }

class mqttClient:
    
    def __init__(self, mqttOptions): 
        self.client = None
        self.wifi = None
        self.qos = 1
        self.timeout = 30
        self.user = mqttOptions['user']
        self.pwd = mqttOptions['pwd']
        self.ID = mqttOptions['mID']
        self.IP = mqttOptions['IP']
        self.port = mqttOptions['port']
        self.callback = None;
        if 'qos' in mqttOptions.keys():
            self.qos = mqttOptions['qos']
        if 'timeout' in mqttOptions.keys():
            self.timeout = mqttOptions['timeout']
            
    def setCallback(self, callback):
        self.callback = callback
     
    def _sub_callback(self, topic, msg, retained, dup):
        if not self.callback is None:
            self.callback(topic.decode('ascii'), msg.decode('ascii'))
        else:
            print('TOPIC: {},  MSG: {}'.format(topic.decode('ascii'), msg.decode('ascii')))

    def publish(self, topic, message):
        self.client.publish(topic, message, qos=self.qos)
        for i in range(self.timeout):
            utime.sleep_ms(100)

    def subscribe(self, topic):
        self.client.subscribe(topic)
        for i in range(self.timeout):
            utime.sleep(1)
            self.client.check_msg()

    def connect(self, options):
        print("--------------------------")
        self.client = _MQTTClient(self.ID, self.IP, port=self.port, user=self.user, password=self.pwd)
        self.wifi = connectWifi(options['ssid'], options['pwd']) 
        self.client.set_callback(self._sub_callback)
        self.client.connect()

    def disconnect(self):
        self.client.disconnect()    
        self.wifi.active(False)
        print("--------------------------")

def callback(topic, msg):
    print('Callback Value: {} : {}'.format(topic, msg))

test = mqttClient(mqttOptions)
test.setCallback(callback)
test.connect(wifiOptions)

test.publish("temp", "test QoS 1 test -----------------")
test.subscribe("temp")

test.disconnect()

```