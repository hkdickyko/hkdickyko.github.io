---
category: [系统]
tags: [编程, 電子]
title: Kotlin
date: 2025-07-14 1:00:00
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
    text-align: center;
  }
  td.left {
    vertical-align: center;
    text-align: left;
  }  
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
  }
</style>

# Kotlin

**Kotlin** 是一种运行在 Java 虚拟机 (JVM) 上的静态类型编程语言，也可以编译成 JavaScript。 它被设计成可以与 Java 代码无缝协作，并且提供了更简洁、更安全的语法。

## 变量
 
而 **Kotlin** 中定义一个变量，只允许在变量前声明两种关键字： **val** 和 **var**。
 - val（value 的简写）用来声明一个不可变的变量，这种变量在初始赋值之后就再也不能重新赋值，对应 Java 中的 <font color="#FF1000">final</font> 变量。
 - var（variable 的简写）用来声明一个可变的变量，这种变量在初始赋值之后仍然可以再被重新赋值，对应 Java 中的<font color="#FF1000">非 final</font> 变量。

小诀窍，永远优先使用 val 来声明一个变量，而当 val 没有办法满足你的需求时再使用 var。这样设计出来的程序会更加健壮，也更加符合高质量的编码规范。声明变量方法如下：

```kotlin
# 隐式声明 (不设定数据类型)
val a = 10

# 显式声明 (设定数据类型)
val a: Int = 10
```

|Java基本数据类型|Kotlin对象数据类型|数据类型说明|
|:---:|:---:|:---:|
|int|Int|整型|
|long|Long|长整型|
|short|Short|短整型|
|float|Float|单精度浮点型|
|double|Double|双精度浮点型|
|boolean|Boolean|布尔型|
|char|Char|字符型|
|byte|Byte|字节型|

## 函数

fun（function 的简写）是定义函数的关键字，无论定义什么函数，都一定要使用 **fun** 来声明。函数名后面紧跟着一对括号，里面可以声明该函数接收什么参数，参数的数量可以是任意个数。最后函数可返回一个类型的数据。例子如下：


```kotlin
fun largerNumber(num1: Int, num2: Int): Int 
{    
   return max(num1, num2)
}
```

### Kotlin 语法糖

当一个函数中只有一行代码时，Kotlin 允许不必编写函数体，可以直接将唯一的一行代码写在函数定义的尾部，中间用等号连接即可。使用这种语法，return 关键字也可以省略了，等号足以表达返回值的意思。

```kotlin
fun largerNumber(num1: Int, num2: Int): Int = max(num1, num2)
```

## 逻辑控制

主要分为 **2** 种：条件语句和循环语句。

### 条件语句（ if， when ）

**if** - if 语句和 Java 中的 if 语句几乎没有任何区别。

**when** - 远比 Java 中的 switch 语句强大。格式是：匹配值 -> { 执行逻辑 }，示例如下：

```kotlin
fun getScore(name: String) = when (name) 
{     
    "Tom" -> 86
    "Jim" -> 77
    "Jack" -> 95
    "Lily" -> 100
    else -> 0 
}
```

除了精确匹配之外，**when** 语句还允许进行类型匹配。

```kotlin
fun checkNumber(num: Number) 
{   
  when (num) {         
    is Int -> println("number is Int")               
    is Double -> println("number is Double")         
    else -> println("number not support")     
  } 
}
```

when 语句还有一种不带参数的用法，有些场景必须使用这种写法才能实现。举个例子：


```kotlin
fun getScore(name: String) = when {     
  name.startsWith("Tom") -> 86
  name == "Jim" -> 77     
  name == "Jack" -> 95     
  name == "Lily" -> 100     
  else -> 0 
}
```

## 循环语句（ while，for-in / until / step / downTo ）

**while** 循环不管是在语法还是使用技巧上都和 Java中的 while 循环没有任何区别。

**for-in** 循环来遍历这个区间

```kotlin
fun main() {
  for (i in 0..10) {
     pprintln(i)     
  } 
}
```

使用 until 关键字来创建一个左闭右开的区间。代码表示创建了一个 **0** 到 **10** 的左闭右开区间，它的数学表达方式是 [0, 10)。main() 函数中的代码，使用 until 替代 .. 关键字，就会发现最后一行 10 不会再打印出来。结合 step 关键字，就能够实现一些更加复杂的循环逻辑。

```kotlin
fun main() {
  for (i in 0 until 10 step 2) {         
    println(i)
  } 
}
```

想创建一个降序的区间，可以使用 downTo 关键字，用法如下：

```kotlin
fun main() {
  for (i in 10 downTo 1) {        
    println(i)     
  } 
}
```

## 面向对象编程

面向对象的语言是可以创建类的。类就是对事物的一种封装，通过类的封装，就可以在适当的时候创建该类的对象，然后调用对象中的字段和函数来满足实际编程的需求，就相等于电子零件中的集成电路。当然面向对象编程还有很多其他特性，如继承、多态等。


**Class** 表示创建一个非抽象类


```kotlin
class Person { 

}
```

实例化一个类的方式和 Java 是基本类似的，只是去掉了 new 关键字而已。代码如下所示：

```kotlin
val p = Person()
```

## **open Class** 表示创建一个抽象类

Kotlin 在设计的时默认所有非抽象类都是不可以被继承的。之所以这里一直在说非抽象类，是因为抽象类本身是无法创建实例的，一定要由子类去继承它才能创建实例，因此抽象类必须可以被继承才行，要不然就没有意义了。

只有加上 **open** 关键字之后，就是在主动告诉Kotlin 编译器，这个类是专门为继承而设计的，

```kotlin
open class Person {

}
```

在 Java 中继承的关键字是 extends，而在 Kotlin 中变成了一个冒号，写法如下：


```kotlin
class Student(val sno: String, val grade: Int, name: String, age: Int) 
  : Person(name, age) 
{ 

}
```

Student 类的主构造函数中增加 name 和 age 这两个字段时，不能再将它们声明成 val，因为在主构造函数中声明成 val 或者 var 的参数将自动成为该类的字段，这就会导致和父类中同名的 name 和 age 字段造成冲突。因此，这里的 name 和 age 参数前面不用加任何关键字，让它的作用域仅限定在主构造函数当中即可。

### 次构造函数

次构造函数是通过 constructor 关键字来定义的，这里定义了两个次构造函数：
 - 第一个次构造函数接收 name 和 age 参数，然后它又通过 this 关键字调用了主构造函数，并将 sno 和 grade 这两个参数赋值成初始值；
 - 第二个次构造函数不接收任何参数，它通过 this 关键字调用了我们刚才定义的第一个次构造函数， name 和 age 参数也赋值成初始值，由于第二个次构造函数间接调用了主构造函数，因此这仍然是合法的。


```kotlin
class Student(val sno: String, val grade: Int, name: String, age: Int) 
  : Person(name, age) {     
  constructor(name: String, age: Int) 
    : this("", 0, name, age) {
    } 
  constructor() : this("", 0) {
  } 
}
```







