---
category: 數學
tags: [數學]
title: 强制类型转换 (int 到 float)
date: 2024-04-28 01:38:36
---

<style>
  table {
    width: 100%git clone https://github.com/hkdickyko/hkdickyko.github.io
    }
  td {
    vertical-align: center;
  }
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
  }
</style>

# 强制类型转换 (int 到 float)

C语言中为什么 32 位 int 型数据强制转换到 float 型会出现精度不能完全保留的现象：

首先来看看的 int 型变量，在一台典型的 32 位机器上一个有符号的 int 型的取值范围为 -2147483648 ~ 2147483647 

$$（-2^{31} ~ (2^{31}-1)) $$ 

（注1）。也就是说，在一个 4 字节（32 位 2 进制），除去首位用于符号位表示正负外，其余的 31 位都是数字的有效位。

下面再来看看 float 型变量：根据 IEEE 的浮点标准，一个浮点数应该用下述形式来表示：

$$ V=(-1)^s * M * 2^E $$

IEEE-745浮点数表示法存储结构：

![Alt x](../assets/img/math/ieeetable.png)

![Alt x](../assets/img/math/ieee64.png)

在 C 语言中， 32 位的 float 型变量有着这样的规定：首位表示符号位 **s**，接下来的 **8** 位（指数域）用于表示 **2** 的指数 **E**，剩余的 **23** 位（小数域）表示M（取值范围为 **[1，2)** 或 **[0，1)** ）。除了上述规定以外，根据指数域的二进制表示情况不同，被编码的 **float** 型数字又可以分成三种情况：

- 规格化值。当指数域的 8 个二进制数字既非全零又非全1时， float 数值就是这种情况。设指数域的八位二进制所表示的十进制数为 **e**, 则公式1中的 **E** 就是 
   $$ E = e - (2^7 - 1) $$
- 非规格化值。当指数域的8个二进制数字为全0时，float数值就为这种情况。这时指数域所表示的十进制数为0，规定指数值为 
   $$ E = 1 - (2^7 - 1) $$
也就是 E 为定值 -126；此时小数域的值仍表示 f = 0.(f22)(f21)...(f1)(f0)。
- 特殊值。当指数域的 8 个二进制数字为全 1 时即为这种情况。当小数域为全零时，该 float 值根据符号位的不同表示正无穷或者负无穷；当小数域为非全零时，该 float 值为 NaN（Not a Number）。

以上，只是在C语言中对int和float的规约。具体在代码中执行强制类型转化究竟会发生什么？从下面两句很简单的语句开始：

int a = 3490593;
float b = (float)a;

那么在内存中a和b究竟存放的是什么值呢？

将a展开为二进制，其值为0000 0000 0011 0101 0100 0011 0010 0001，其十六进制即为0x00354321。 因为要转化为float型，所以首先要对上述二进制的表示形式改变为 M * 2^E 的形式.由于该数明显大于1，所以按照IEEE的标准，其浮点形势必然为规格化值。因此 ，转化后的形式为
a = 1.101010100001100100001 * 2^21

根据 规格化值的定义，M = 1 + f. 所以f = 0.101010100001100100001.因为float型变量的小数域一共23位。所以b的最后23位可以得出，其值为10101010000110010000100; ?& e& o" A% g, I# G
; }. r8 Y* k; t) ^+ \
下面再演绎指数域的值：因为a的指数表示法中，指数E = 21。根据公式2，e = E + (2^7 -1) = 148.所以可以得出b的指数域的二进制表示为：10010100。在加上原数为正，所以符号位s=0。
8 K% c% ^9 P: ]4 V# s! s7 e
所以，可以得出b的二进制表示为0 10010100 10101010000110010000100。转化为十六位进制则是0x4A550C84。换句话说，它存储在内存中的值是与a是完全不同的。但是其间还是有关联性的——a的首位为1的数值位后的二进制表示是与b的小数域完全相同的。

很快，问题就出现了。int型的有效位数是31，而float型小数域的有效位只有23位，也就是说如果上面的a的二进制的有效位超过了24位，那么float型的小数域的精度就不够了。因此必须进行舍入。比如：如果上面的a的二进制为0000 0001 1111 0101 0100 0011 0010 0001。这时b的小数域必须有24位才够，但是，这显然是不现实的，因此必须舍入到23位，舍入的原则是：所得结果的最低有效位为0。因此这个a在转换到float时，其精度就会丢失，因为该float的最后23位变成了11110101010000110010000——这显然是与原值不符的。