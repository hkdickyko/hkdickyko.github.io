---
category: [編程]
tags: [Linux, IoT]
title: ESP RMT
date: 2024-09-08 08:00:00
---
<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
  }
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
  }
</style>


# ESP RMT（远程控制收发器）

ESP32 模组中有个 RMT 类别可以扩展为多功能通用收发器，发送或接收许多其他类型的信号。虽然原用途并不是拿来做 PWM，但因设计上的巧合, 刚好可以用来变造成可自订不同频率的 PWM。

因 RMT 添加到 TX 缓冲区的每个项目都是 32 位的信号。体现在 IO 上也就是高低电平。对于步进机，可使用成对的相同高/低项目。构建成不同频率，而频率时间取决于使用的时钟分频器。

由於 RMT 有 **8** 個通道, 所以就等於有 **8** 個可隨意自訂頻率的 PWM 可以使用。


用 RMT 来设计 PWM。例子如下：

- 製作 261Hz 的信号源, 可以计算出周期为：

$$
\frac {1}{H_z} = \frac {1s}{261} = 3831.418 \mu s,
$$

因为是方波信号，所以占空比为 **50%** 也就是

$$
\frac {3831.418\mu s}{2}  = 1915.709 \mu s
$$

为高电位与低电位各自持续的时间。

时脉除频器 (clock divider)，决定 RMT 发射器产生的脉冲长度范围或接收器的判别。通过设置 clk_div 为 **1** 至 **255** 范围内的一个值来选择。RMT 的源时钟通常为APB CLK，默认为 **80Mhz**。

注意，由于 RMT 选择的时钟分频器不同。因此每一個时间刻度为:

$$
一脉冲长度 = \frac {1s} {80MH_z} \times {时脉除频器_{[1..255]}} = 0.0125 \mu s \approx  3.1875 \mu s
$$

预设指定交替高低电位的持续脉冲长度为 **0~32767**，一周期为两个脉冲长度

$$
一周期长度 = 2 \times 32767 \times \frac {1 \mu s} {80} \times {时脉除频器_{[1..255]}} = 819.175 \mu s \approx  208889.625 \mu s
$$

最慢的频率区间

$$
最慢的频率_{[1..255]} = \frac {80,000,000} {65534 \times 时脉除频器_{[1..255]}} \\
最低频率带宽_{[1..255]} = 1.221 kH_z \approx \color{red}{4.787} H_z
$$

$$
最快的频率_{[1..255]} = \frac {80,000,000} {2 \times 时脉除频器_{[1..255]}}
$$

$$
最高频率带宽_{[1..255]} = \color{red}{40} MH_z \approx 156.286 kH_z
$$

$$
即远程控制收发器的频率带宽为：**40** MH_z 至 **4.787** H_z
$$

## 步进电动机解决方法

```c
#include "freertos/FreeRTOS.h"
#include "nvs_flash.h"
#include "driver/gpio.h"
#include "driver/rmt_tx.h"
#include "esp_log.h"
#include "esp_check.h"

#define CW 0
#define CCW 1
#define ON 0
#define OFF 1

struct stepper_pins stepper0; // 步进电机的初始端口
#define STEP_MOTOR_RESOLUTION_HZ 1000000 // 1MHz resolution
static const char *TAG = "example";

struct stepper_pins
{
  uint8_t ENA;
  uint8_t DIR;
  uint8_t PLU;
};

void setEnable(int value)
{
  gpio_set_level(stepper0.ENA, value);
}

void setDirection(int value)
{
  gpio_set_level(stepper0.DIR, value);
}

void setPlus(int steps, int ms)
{
  double delay = (double) ms / portTICK_PERIOD_MS;
  printf("--%lf,%ld",delay, portTICK_PERIOD_MS);
  for (int n = 0; n < steps; n++)
  {
    gpio_set_level(stepper0.PLU, OFF);
    vTaskDelay(delay);
    gpio_set_level(stepper0.PLU, ON);
    vTaskDelay(delay);
  }
}

typedef struct {
    uint32_t resolution;    // Encoder resolution, in Hz
    uint32_t sample_points; // Sample points used for deceleration phase. Note: |end_freq_hz - start_freq_hz| >= sample_points
    uint32_t start_freq_hz; // Start frequency on the curve, in Hz
    uint32_t end_freq_hz;   // End frequency on the curve, in Hz
} stepper_motor_curve_encoder_config_t;

typedef struct {
    rmt_encoder_t base;
    rmt_encoder_handle_t copy_encoder;
    uint32_t sample_points;
    struct {
        uint32_t is_accel_curve: 1;
    } flags;
    rmt_symbol_word_t curve_table[];
} rmt_stepper_curve_encoder_t;

static float convert_to_smooth_freq(uint32_t freq1, uint32_t freq2, uint32_t freqx)
{
    float normalize_x = ((float)(freqx - freq1)) / (freq2 - freq1);
    // third-order "smoothstep" function: https://en.wikipedia.org/wiki/Smoothstep
    float smooth_x = normalize_x * normalize_x * (3 - 2 * normalize_x);
    return smooth_x * (freq2 - freq1) + freq1;
}

static esp_err_t rmt_del_stepper_motor_curve_encoder(rmt_encoder_t *encoder)
{
    rmt_stepper_curve_encoder_t *motor_encoder = __containerof(encoder, rmt_stepper_curve_encoder_t, base);
    rmt_del_encoder(motor_encoder->copy_encoder);
    free(motor_encoder);
    return ESP_OK;
}

static size_t rmt_encode_stepper_motor_curve(rmt_encoder_t *encoder, rmt_channel_handle_t channel, const void *primary_data, size_t data_size, rmt_encode_state_t *ret_state)
{
    rmt_stepper_curve_encoder_t *motor_encoder = __containerof(encoder, rmt_stepper_curve_encoder_t, base);
    rmt_encoder_handle_t copy_encoder = motor_encoder->copy_encoder;
    rmt_encode_state_t session_state = RMT_ENCODING_RESET;
    uint32_t points_num = *(uint32_t *)primary_data;
    size_t encoded_symbols = 0;
    if (motor_encoder->flags.is_accel_curve) {
        encoded_symbols = copy_encoder->encode(copy_encoder, channel, &motor_encoder->curve_table[0],
                                               points_num * sizeof(rmt_symbol_word_t), &session_state);
    } else {
        encoded_symbols = copy_encoder->encode(copy_encoder, channel, &motor_encoder->curve_table[0] + motor_encoder->sample_points - points_num,
                                               points_num * sizeof(rmt_symbol_word_t), &session_state);
    }
    *ret_state = session_state;
    return encoded_symbols;
}

static esp_err_t rmt_reset_stepper_motor_curve_encoder(rmt_encoder_t *encoder)
{
    rmt_stepper_curve_encoder_t *motor_encoder = __containerof(encoder, rmt_stepper_curve_encoder_t, base);
    rmt_encoder_reset(motor_encoder->copy_encoder);
    return ESP_OK;
}

esp_err_t rmt_new_stepper_motor_curve_encoder(const stepper_motor_curve_encoder_config_t *config, rmt_encoder_handle_t *ret_encoder)
{
    esp_err_t ret = ESP_OK;
    rmt_stepper_curve_encoder_t *step_encoder = NULL;
    float smooth_freq;
    uint32_t symbol_duration;
    ESP_GOTO_ON_FALSE(config && ret_encoder, ESP_ERR_INVALID_ARG, err, TAG, "invalid arguments");
    ESP_GOTO_ON_FALSE(config->sample_points, ESP_ERR_INVALID_ARG, err, TAG, "sample points number can't be zero");
    ESP_GOTO_ON_FALSE(config->start_freq_hz != config->end_freq_hz, ESP_ERR_INVALID_ARG, err, TAG, "start freq can't equal to end freq");
     step_encoder = rmt_alloc_encoder_mem(sizeof(rmt_stepper_curve_encoder_t) + config->sample_points * sizeof(rmt_symbol_word_t));
     ESP_GOTO_ON_FALSE(step_encoder, ESP_ERR_NO_MEM, err, TAG, "no mem for stepper curve encoder");
     rmt_copy_encoder_config_t copy_encoder_config = {};
     ESP_GOTO_ON_ERROR(rmt_new_copy_encoder(&copy_encoder_config, &step_encoder->copy_encoder), err, TAG, "create copy encoder failed");
     bool is_accel_curve = config->start_freq_hz < config->end_freq_hz;

     // prepare the curve table, in RMT symbol format
     uint32_t curve_step = 0;
     if (is_accel_curve) {
         curve_step = (config->end_freq_hz - config->start_freq_hz) / (config->sample_points - 1);
        for (uint32_t i = 0; i < config->sample_points; i++) {
            smooth_freq = convert_to_smooth_freq(config->start_freq_hz, config->end_freq_hz, config->start_freq_hz + curve_step * i);
            symbol_duration = config->resolution / smooth_freq / 2;
            step_encoder->curve_table[i].level0 = 0;
            step_encoder->curve_table[i].duration0 = symbol_duration;
            step_encoder->curve_table[i].level1 = 1;
            step_encoder->curve_table[i].duration1 = symbol_duration;
        }
    } else {
        curve_step = (config->start_freq_hz - config->end_freq_hz) / (config->sample_points - 1);
        for (uint32_t i = 0; i < config->sample_points; i++) {
            smooth_freq = convert_to_smooth_freq(config->end_freq_hz, config->start_freq_hz, config->end_freq_hz + curve_step * i);
            symbol_duration = config->resolution / smooth_freq / 2;
            step_encoder->curve_table[config->sample_points - i - 1].level0 = 0;
            step_encoder->curve_table[config->sample_points - i - 1].duration0 = symbol_duration;
            step_encoder->curve_table[config->sample_points - i - 1].level1 = 1;
            step_encoder->curve_table[config->sample_points - i - 1].duration1 = symbol_duration;
        }
    }
    ESP_GOTO_ON_FALSE(curve_step > 0, ESP_ERR_INVALID_ARG, err, TAG, "|end_freq_hz - start_freq_hz| can't be smaller than sample_points");

    step_encoder->sample_points = config->sample_points;
    step_encoder->flags.is_accel_curve = is_accel_curve;
    step_encoder->base.del = rmt_del_stepper_motor_curve_encoder;
    step_encoder->base.encode = rmt_encode_stepper_motor_curve;
    step_encoder->base.reset = rmt_reset_stepper_motor_curve_encoder;
    *ret_encoder = &(step_encoder->base);
    return ESP_OK;
 err:
    if (step_encoder) {
        if (step_encoder->copy_encoder) {
            rmt_del_encoder(step_encoder->copy_encoder);
        }
        free(step_encoder);
    }
    return ret;
}

void app_main(void)
{
  nvs_flash_init();
  stepper0.ENA = 27;
  stepper0.DIR = 26;
  stepper0.PLU = 25;
  gpio_set_direction(stepper0.ENA, GPIO_MODE_OUTPUT);
  gpio_set_direction(stepper0.DIR, GPIO_MODE_OUTPUT);
  gpio_set_direction(stepper0.PLU, GPIO_MODE_OUTPUT);
  setEnable(ON);
  setDirection(CW);
  int ms = 1;
  printf("--->%d", ms);
  setPlus(200, ms);

  const static uint32_t accel_samples = 500;
  rmt_channel_handle_t motor_chan = NULL;
  rmt_tx_channel_config_t tx_chan_config = {
      .clk_src = RMT_CLK_SRC_DEFAULT, 
      .gpio_num = stepper0.PLU,
      .mem_block_symbols = 64,
      .resolution_hz = STEP_MOTOR_RESOLUTION_HZ,
      .trans_queue_depth = 10, 
  };
  rmt_transmit_config_t tx_config = {
      .loop_count = 0,
  };

  stepper_motor_curve_encoder_config_t accel_encoder_config = {
      .resolution = STEP_MOTOR_RESOLUTION_HZ,
      .sample_points = 500,
      .start_freq_hz = 500,
      .end_freq_hz = 1200,
  };
  rmt_encoder_handle_t accel_motor_encoder = NULL;

  ESP_ERROR_CHECK(rmt_new_stepper_motor_curve_encoder(&accel_encoder_config, &accel_motor_encoder));
  ESP_ERROR_CHECK(rmt_new_tx_channel(&tx_chan_config, &motor_chan));
  ESP_ERROR_CHECK(rmt_enable(motor_chan));
  ESP_ERROR_CHECK(rmt_transmit(motor_chan, accel_motor_encoder, &accel_samples, sizeof(accel_samples), &tx_config));    
  ESP_ERROR_CHECK(rmt_tx_wait_all_done(motor_chan, -1));

  vTaskDelay(pdMS_TO_TICKS(1000));
}
```