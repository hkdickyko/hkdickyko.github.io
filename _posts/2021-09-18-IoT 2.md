---
category: [積體電路, 編程]
tags: [IoT-2]
---

## MicroPython MPU-9250 (MPU-6500 + AK8963)


[現有的代碼庫 MPU-9250](https://github.com/tuupola/micropython-mpu9250)

![Alt ESP32]({{ '/assets/img/IoT/mpu9250.png' | relative_url }})

## MPU9250 是兩個集成電路(MPU-6500 + AK8963)的組合

![Alt ESP32]({{ '/assets/img/IoT/mpu9250axis.png' | relative_url }})

## x, y 和 z 軸的關係變量值的說明

![Alt ESP32]({{ '/assets/img/IoT/3axis.png' | relative_url }})

## 繞 X 軸旋轉角度 &Phi; = roll	

![Alt ESP32]({{ '/assets/img/IoT/xaxis.png' | relative_url }})

## 繞 Y 軸旋轉角度 &theta; = pitch 

![Alt ESP32]({{ '/assets/img/IoT/yaxis.png' | relative_url }})


## 繞 Z 軸旋轉角度 &psi; = yaw

![Alt ESP32]({{ '/assets/img/IoT/zaxis.png' | relative_url }})

 - A<sub>x</sub>, A<sub>y</sub>, A<sub>z</sub> 是 x, y 和 z 軸加速度變化 
 - mx, my, mz 是 x, y 和 z 軸磁場強度變化
 
 
main.py - 處理最小功能的示例 

```python
from machine import I2C, Pin, Timer
from mpu9250 import MPU9250
from ak8963 import AK8963
import math
from d3d import D3D

i2c = I2C(scl=Pin(22), sda=Pin(21))
dummy = MPU9250(i2c) # this opens the bybass to access to the AK8963

# Code for Calibration
print("Waiting for Calibration")
ak8963 = AK8963(i2c)

#offset, scale = ak8963.calibrate(count=256, delay=200)
#print("Calibration completed.")

# sensor = MPU9250(i2c, ak8963=ak8963)
# print("{}:{}".format(offset, scale))
ak8963 = AK8963(i2c, offset=(44.3584, -10.05469, -24.70254), scale=(0.9937236, 0.9021546, 1.129655))

sensor = MPU9250(i2c, ak8963=ak8963)
flag = False

def sw():
    #print("---{}".format(flag))
    return flag

def getmag():                               # Return (x, y, z) tuple (blocking read)
#    print(sensor.magnetic)
    return sensor.magnetic

def read_sensor(timer):
#  radAngXYZ = d3x.getAngleXYZ(sensor.acceleration, sensor.magnetic)
#  print("Basic:{}".format(d3x.rad2Deg(radAngXYZ)))
#   print("roll:{}, pitch:{}, yaw:{}".format(roll, pitch, yaw))
#   d2R = d3x.deg2Rad([roll, pitch, yaw])
#   print(d2R)
#   print(radAngXYZ)
#   qr = d3x.euler_to_quaternion(radAngXYZ)
#   print(qr)
#   qe = d3x.quaternion_to_euler(qr)
#   print(qe)
#   print(d3x.quaternion_to_matrix(qr))
#  print("deg:{}".format(sensor.gyro))
  print(d3x.update(sensor.acceleration, d3x.rad2Deg(sensor.gyro) , sensor.magnetic))

def setStop(timer):
    global flag
    print("Stop")
    flag = True 

print("MPU9250 id: " + hex(sensor.whoami))
print("\n")
d3x = D3D()
tim = Timer(1)
tim.init(period=10000, mode=Timer.ONE_SHOT, callback=setStop)

d3x.calibrate(getmag, sw)
print("bias:{}".format(d3x.magbias))
timer_0 = Timer(0)
timer_0.init(period=1000, mode=Timer.PERIODIC, callback=read_sensor)

```    


D3D.py 處理 *3D* 計算代碼

```python
import math
try:
    import utime as time
except ImportError:
    import time

from math import sqrt, atan2, asin, degrees, radians
from deltat import DeltaT

class D3D:

  def __init__(self, timediff=None):
    self.factor = 180 / math.pi
    self.magbias = (0, 0, 0)          
    self.deltat = DeltaT(timediff)    
    self.q = [1.0, 0.0, 0.0, 0.0]     
    GyroMeasError = radians(40)       
    self.beta = sqrt(3.0 / 4.0) * GyroMeasError
    self.pitch = 0
    self.heading = 0
    self.roll = 0
    self.declination = 0 

  def getAngleXYZ(self, acceleration, magnetic):
    x, y, z = acceleration
    magX, magY, magZ = magnetic
    pitch = math.atan(x / math.sqrt((y * y) + (z * z)));
    roll = math.atan(y / math.sqrt((x * x) + (z * z)));
    yaw = math.atan(z / math.sqrt((x * x) + (y * y)));
    Xh = (magX * math.cos(pitch)) + (magY * math.sin(roll) * math.sin(pitch)) + (magZ * math.cos(roll) * math.sin(pitch));
    Yh = (magY * math.cos(roll)) - (magZ * math.sin(roll));
    yaw = math.atan2(-Yh, Xh);
    return (roll, pitch, yaw)

  def rad2Deg(self, xyz):
      roll = xyz[0] * self.factor
      pitch = xyz[1] * self.factor
      yaw= xyz[2] * self.factor
      return (roll, pitch, yaw)
      
  def deg2Rad(self, xyz):
      roll = xyz[0] / self.factor
      pitch = xyz[1] / self.factor
      yaw= xyz[2] / self.factor
      return (roll, pitch, yaw)      

  def euler_to_quaternion(self,r):
    (roll, pitch, yaw) = (r[0], r[1], r[2])
    qx = math.sin(roll/2) * math.cos(pitch/2) * math.cos(yaw/2) - math.cos(roll/2) * math.sin(pitch/2) * math.sin(yaw/2)
    qy = math.cos(roll/2) * math.sin(pitch/2) * math.cos(yaw/2) + math.sin(roll/2) * math.cos(pitch/2) * math.sin(yaw/2)
    qz = math.cos(roll/2) * math.cos(pitch/2) * math.sin(yaw/2) - math.sin(roll/2) * math.sin(pitch/2) * math.cos(yaw/2)
    qw = math.cos(roll/2) * math.cos(pitch/2) * math.cos(yaw/2) + math.sin(roll/2) * math.sin(pitch/2) * math.sin(yaw/2)
    return [qx, qy, qz, qw]

  def quaternion_to_euler(self, q):
    (x, y, z, w) = (q[0], q[1], q[2], q[3])
    t0 = +2.0 * (w * x + y * z)
    t1 = +1.0 - 2.0 * (x * x + y * y)
    roll = math.atan2(t0, t1)
    t2 = +2.0 * (w * y - z * x)
    t2 = +1.0 if t2 > +1.0 else t2
    t2 = -1.0 if t2 < -1.0 else t2
    pitch = math.asin(t2)
    t3 = +2.0 * (w * z + x * y)
    t4 = +1.0 - 2.0 * (y * y + z * z)
    yaw = math.atan2(t3, t4)
    return [roll, pitch, yaw]

  def quaternion_to_matrix(self, Q):

    q0 = Q[0]
    q1 = Q[1]
    q2 = Q[2]
    q3 = Q[3]
    # First row of the rotation matrix
    r00 = 2 * (q0 * q0 + q1 * q1) - 1
    r01 = 2 * (q1 * q2 - q0 * q3)
    r02 = 2 * (q1 * q3 + q0 * q2)
    # Second row of the rotation matrix
    r10 = 2 * (q1 * q2 + q0 * q3)
    r11 = 2 * (q0 * q0 + q2 * q2) - 1
    r12 = 2 * (q2 * q3 - q0 * q1)
    # Third row of the rotation matrix
    r20 = 2 * (q1 * q3 - q0 * q2)
    r21 = 2 * (q2 * q3 + q0 * q1)
    r22 = 2 * (q0 * q0 + q3 * q3) - 1
    # 3x3 rotation matrix
    rot_matrix = [[r00, r01, r02],
                  [r10, r11, r12],
                  [r20, r21, r22]]
                            
    return rot_matrix

  def quaternion_multiply(Q0,Q1):
    # Extract the values from Q0
    w0 = Q0[0]
    x0 = Q0[1]
    y0 = Q0[2]
    z0 = Q0[3]
    # Extract the values from Q1
    w1 = Q1[0]
    x1 = Q1[1]
    y1 = Q1[2]
    z1 = Q1[3]
    # Computer the product of the two quaternions, term by term
    Q0Q1_w = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1
    Q0Q1_x = w0 * x1 + x0 * w1 + y0 * z1 - z0 * y1
    Q0Q1_y = w0 * y1 - x0 * z1 + y0 * w1 + z0 * x1
    Q0Q1_z = w0 * z1 + x0 * y1 - y0 * x1 + z0 * w1
    # Create a 4 element array containing the final quaternion
    final_quaternion = [Q0Q1_w, Q0Q1_x, Q0Q1_y, Q0Q1_z]
    # Return a 4 element array containing the final quaternion (q02,q12,q22,q32) 
    return final_quaternion

  def calibrate(self, getxyz, stopfunc, wait=0):
    magmax = list(getxyz())             
    magmin = magmax[:]
    while not stopfunc():
        if wait != 0:
            if callable(wait):
                wait()
            else:
                time.sleep(wait/1000)  # Portable
        magxyz = tuple(getxyz())
        for x in range(3):
          magmax[x] = max(magmax[x], magxyz[x])
          magmin[x] = min(magmin[x], magxyz[x])
    self.magbias = tuple(map(lambda a, b: (a +b)/2, magmin, magmax))

  def update(self, accel, gyro, mag, ts=None):     # 3-tuples (x, y, z) for accel, gyro and mag data
    mx, my, mz = (mag[x] - self.magbias[x] for x in range(3)) # Units irrelevant (normalised)
    ax, ay, az = accel                  # Units irrelevant (normalised)
    gx, gy, gz = (radians(x) for x in gyro)  # Units deg/s
    q1, q2, q3, q4 = (self.q[x] for x in range(4))   # short name local variable for readability
    # Auxiliary variables to avoid repeated arithmetic
    _2q1 = 2 * q1
    _2q2 = 2 * q2
    _2q3 = 2 * q3
    _2q4 = 2 * q4
    _2q1q3 = 2 * q1 * q3
    _2q3q4 = 2 * q3 * q4
    q1q1 = q1 * q1
    q1q2 = q1 * q2
    q1q3 = q1 * q3
    q1q4 = q1 * q4
    q2q2 = q2 * q2
    q2q3 = q2 * q3
    q2q4 = q2 * q4
    q3q3 = q3 * q3
    q3q4 = q3 * q4
    q4q4 = q4 * q4

    # Normalise accelerometer measurement
    norm = sqrt(ax * ax + ay * ay + az * az)
    if (norm == 0):
        return # handle NaN
    norm = 1 / norm                     # use reciprocal for division
    ax *= norm
    ay *= norm
    az *= norm

    # Normalise magnetometer measurement
    norm = sqrt(mx * mx + my * my + mz * mz)
    if (norm == 0):
        return                          # handle NaN
    norm = 1 / norm                     # use reciprocal for division
    mx *= norm
    my *= norm
    mz *= norm

    # Reference direction of Earth's magnetic field
    _2q1mx = 2 * q1 * mx
    _2q1my = 2 * q1 * my
    _2q1mz = 2 * q1 * mz
    _2q2mx = 2 * q2 * mx
    hx = mx * q1q1 - _2q1my * q4 + _2q1mz * q3 + mx * q2q2 + _2q2 * my * q3 + _2q2 * mz * q4 - mx * q3q3 - mx * q4q4
    hy = _2q1mx * q4 + my * q1q1 - _2q1mz * q2 + _2q2mx * q3 - my * q2q2 + my * q3q3 + _2q3 * mz * q4 - my * q4q4
    _2bx = sqrt(hx * hx + hy * hy)
    _2bz = -_2q1mx * q3 + _2q1my * q2 + mz * q1q1 + _2q2mx * q4 - mz * q2q2 + _2q3 * my * q4 - mz * q3q3 + mz * q4q4
    _4bx = 2 * _2bx
    _4bz = 2 * _2bz

    # Gradient descent algorithm corrective step
    s1 = (-_2q3 * (2 * q2q4 - _2q1q3 - ax) + _2q2 * (2 * q1q2 + _2q3q4 - ay) - _2bz * q3 * (_2bx * (0.5 - q3q3 - q4q4)
         + _2bz * (q2q4 - q1q3) - mx) + (-_2bx * q4 + _2bz * q2) * (_2bx * (q2q3 - q1q4) + _2bz * (q1q2 + q3q4) - my)
         + _2bx * q3 * (_2bx * (q1q3 + q2q4) + _2bz * (0.5 - q2q2 - q3q3) - mz))

    s2 = (_2q4 * (2 * q2q4 - _2q1q3 - ax) + _2q1 * (2 * q1q2 + _2q3q4 - ay) - 4 * q2 * (1 - 2 * q2q2 - 2 * q3q3 - az)
         + _2bz * q4 * (_2bx * (0.5 - q3q3 - q4q4) + _2bz * (q2q4 - q1q3) - mx) + (_2bx * q3 + _2bz * q1) * (_2bx * (q2q3 - q1q4)
         + _2bz * (q1q2 + q3q4) - my) + (_2bx * q4 - _4bz * q2) * (_2bx * (q1q3 + q2q4) + _2bz * (0.5 - q2q2 - q3q3) - mz))

    s3 = (-_2q1 * (2 * q2q4 - _2q1q3 - ax) + _2q4 * (2 * q1q2 + _2q3q4 - ay) - 4 * q3 * (1 - 2 * q2q2 - 2 * q3q3 - az)
         + (-_4bx * q3 - _2bz * q1) * (_2bx * (0.5 - q3q3 - q4q4) + _2bz * (q2q4 - q1q3) - mx)
         + (_2bx * q2 + _2bz * q4) * (_2bx * (q2q3 - q1q4) + _2bz * (q1q2 + q3q4) - my)
         + (_2bx * q1 - _4bz * q3) * (_2bx * (q1q3 + q2q4) + _2bz * (0.5 - q2q2 - q3q3) - mz))

    s4 = (_2q2 * (2 * q2q4 - _2q1q3 - ax) + _2q3 * (2 * q1q2 + _2q3q4 - ay) + (-_4bx * q4 + _2bz * q2) * (_2bx * (0.5 - q3q3 - q4q4)
          + _2bz * (q2q4 - q1q3) - mx) + (-_2bx * q1 + _2bz * q3) * (_2bx * (q2q3 - q1q4) + _2bz * (q1q2 + q3q4) - my)
          + _2bx * q2 * (_2bx * (q1q3 + q2q4) + _2bz * (0.5 - q2q2 - q3q3) - mz))

    norm = 1 / sqrt(s1 * s1 + s2 * s2 + s3 * s3 + s4 * s4)    # normalise step magnitude
    s1 *= norm
    s2 *= norm
    s3 *= norm
    s4 *= norm

    # Compute rate of change of quaternion
    qDot1 = 0.5 * (-q2 * gx - q3 * gy - q4 * gz) - self.beta * s1
    qDot2 = 0.5 * (q1 * gx + q3 * gz - q4 * gy) - self.beta * s2
    qDot3 = 0.5 * (q1 * gy - q2 * gz + q4 * gx) - self.beta * s3
    qDot4 = 0.5 * (q1 * gz + q2 * gy - q3 * gx) - self.beta * s4

    # Integrate to yield quaternion
    deltat = self.deltat(ts)
    q1 += qDot1 * deltat
    q2 += qDot2 * deltat
    q3 += qDot3 * deltat
    q4 += qDot4 * deltat
    norm = 1 / sqrt(q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4)    # normalise quaternion
    self.q = q1 * norm, q2 * norm, q3 * norm, q4 * norm
    yaw = self.declination + degrees(atan2(2.0 * (self.q[1] * self.q[2] + self.q[0] * self.q[3]),
        self.q[0] * self.q[0] + self.q[1] * self.q[1] - self.q[2] * self.q[2] - self.q[3] * self.q[3]))
    pitch = degrees(-asin(2.0 * (self.q[1] * self.q[3] - self.q[0] * self.q[2])))
    roll = degrees(atan2(2.0 * (self.q[0] * self.q[1] + self.q[2] * self.q[3]),
        self.q[0] * self.q[0] - self.q[1] * self.q[1] - self.q[2] * self.q[2] + self.q[3] * self.q[3]))
    return (roll, pitch, yaw)

```

[現有的代碼庫 MPU-9250 帶補償係數](https://github.com/micropython-IMU/micropython-fusion)

