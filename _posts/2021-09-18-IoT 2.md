---
category: [積體電路, 編程]
tags: [IoT-2]
---

## MicroPython MPU-9250 (MPU-6500 + AK8963)


[現有的代碼庫 MPU-9250](https://github.com/tuupola/micropython-mpu9250)

![Alt ESP32]({{ '/assets/img/IoT/mpu9250.png' | relative_url }})

## MPU9250 是兩個集成電路(MPU-6500 + AK8963)的組合

![Alt ESP32]({{ '/assets/img/IoT/mpu9250axis.png' | relative_url }})

## x, y 和 z 軸的關係變量值的說明

![Alt ESP32]({{ '/assets/img/IoT/3axis.png' | relative_url }})

## 繞 X 軸旋轉角度 &Phi; = roll	

![Alt ESP32]({{ '/assets/img/IoT/xaxis.png' | relative_url }})

## 繞 Y 軸旋轉角度 &theta; = pitch 

![Alt ESP32]({{ '/assets/img/IoT/yaxis.png' | relative_url }})


## 繞 Z 軸旋轉角度 &psi; = yaw

![Alt ESP32]({{ '/assets/img/IoT/zaxis.png' | relative_url }})

 - A<sub>x</sub>, A<sub>y</sub>, A<sub>z</sub> 是 x, y 和 z 軸加速度變化 
 - mx, my, mz 是 x, y 和 z 軸磁場強度變化

```python
from machine import I2C, Pin, Timer
from mpu9250 import MPU9250
from ak8963 import AK8963
import math
from d3d import D3D

i2c = I2C(scl=Pin(22), sda=Pin(21))
dummy = MPU9250(i2c) # this opens the bybass to access to the AK8963

# Code for Calibration
print("Waiting for Calibration")
ak8963 = AK8963(i2c)

#offset, scale = ak8963.calibrate(count=256, delay=200)
#print("Calibration completed.")

# sensor = MPU9250(i2c, ak8963=ak8963)
# print("{}:{}".format(offset, scale))
ak8963 = AK8963(i2c, offset=(44.3584, -10.05469, -24.70254), scale=(0.9937236, 0.9021546, 1.129655))

sensor = MPU9250(i2c, ak8963=ak8963)

def read_sensor(timer):
  radAngXYZ = d3x.getAngleXYZ(sensor.acceleration, sensor.magnetic)
#   print("roll:{}, pitch:{}, yaw:{}".format(roll, pitch, yaw))
#   d2R = d3x.deg2Rad([roll, pitch, yaw])
#   print(d2R)
  print(radAngXYZ)
  qr = d3x.euler_to_quaternion(radAngXYZ)
  print(qr)
  qe = d3x.quaternion_to_euler(qr)
  print(qe)
  print(d3x.quaternion_to_matrix(qr))

print("MPU9250 id: " + hex(sensor.whoami))
d3x = D3D() 
timer_0 = Timer(0)
timer_0.init(period=1000, mode=Timer.PERIODIC, callback=read_sensor)

```    


```python
import math

class D3D:

  def __init__(self):
    self.factor = 180 / math.pi
    pass

  def getAngleXYZ(self, acceleration, magnetic):
    x, y, z = acceleration
    magX, magY, magZ = magnetic
    pitch = math.atan(x / math.sqrt((y * y) + (z * z)));
    roll = math.atan(y / math.sqrt((x * x) + (z * z)));
    yaw = math.atan(z / math.sqrt((x * x) + (y * y)));
    Xh = (magX * math.cos(pitch)) + (magY * math.sin(roll) * math.sin(pitch)) + (magZ * math.cos(roll) * math.sin(pitch));
    Yh = (magY * math.cos(roll)) - (magZ * math.sin(roll));
    yaw = math.atan2(-Yh, Xh);
    return (roll, pitch, yaw)

  def rad2Deg(self, xyz):
      roll = xyz[0] * self.factor
      pitch = xyz[1] * self.factor
      yaw= xyz[2] * self.factor
      return [roll, pitch, yaw]
      
  def deg2Rad(self, xyz):
      roll = xyz[0] / self.factor
      pitch = xyz[1] / self.factor
      yaw= xyz[2] / self.factor
      return [roll, pitch, yaw]      

  def euler_to_quaternion(self,r):
    (roll, pitch, yaw) = (r[0], r[1], r[2])
    qx = math.sin(roll/2) * math.cos(pitch/2) * math.cos(yaw/2) - math.cos(roll/2) * math.sin(pitch/2) * math.sin(yaw/2)
    qy = math.cos(roll/2) * math.sin(pitch/2) * math.cos(yaw/2) + math.sin(roll/2) * math.cos(pitch/2) * math.sin(yaw/2)
    qz = math.cos(roll/2) * math.cos(pitch/2) * math.sin(yaw/2) - math.sin(roll/2) * math.sin(pitch/2) * math.cos(yaw/2)
    qw = math.cos(roll/2) * math.cos(pitch/2) * math.cos(yaw/2) + math.sin(roll/2) * math.sin(pitch/2) * math.sin(yaw/2)
    return [qx, qy, qz, qw]

  def quaternion_to_euler(self, q):
    (x, y, z, w) = (q[0], q[1], q[2], q[3])
    t0 = +2.0 * (w * x + y * z)
    t1 = +1.0 - 2.0 * (x * x + y * y)
    roll = math.atan2(t0, t1)
    t2 = +2.0 * (w * y - z * x)
    t2 = +1.0 if t2 > +1.0 else t2
    t2 = -1.0 if t2 < -1.0 else t2
    pitch = math.asin(t2)
    t3 = +2.0 * (w * z + x * y)
    t4 = +1.0 - 2.0 * (y * y + z * z)
    yaw = math.atan2(t3, t4)
    return [roll, pitch, yaw]

  def quaternion_to_matrix(self, Q):

    q0 = Q[0]
    q1 = Q[1]
    q2 = Q[2]
    q3 = Q[3]
    # First row of the rotation matrix
    r00 = 2 * (q0 * q0 + q1 * q1) - 1
    r01 = 2 * (q1 * q2 - q0 * q3)
    r02 = 2 * (q1 * q3 + q0 * q2)
    # Second row of the rotation matrix
    r10 = 2 * (q1 * q2 + q0 * q3)
    r11 = 2 * (q0 * q0 + q2 * q2) - 1
    r12 = 2 * (q2 * q3 - q0 * q1)
    # Third row of the rotation matrix
    r20 = 2 * (q1 * q3 - q0 * q2)
    r21 = 2 * (q2 * q3 + q0 * q1)
    r22 = 2 * (q0 * q0 + q3 * q3) - 1
    # 3x3 rotation matrix
    rot_matrix = [[r00, r01, r02],
                  [r10, r11, r12],
                  [r20, r21, r22]]
                            
    return rot_matrix

  def quaternion_multiply(Q0,Q1):
    # Extract the values from Q0
    w0 = Q0[0]
    x0 = Q0[1]
    y0 = Q0[2]
    z0 = Q0[3]
    # Extract the values from Q1
    w1 = Q1[0]
    x1 = Q1[1]
    y1 = Q1[2]
    z1 = Q1[3]
    # Computer the product of the two quaternions, term by term
    Q0Q1_w = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1
    Q0Q1_x = w0 * x1 + x0 * w1 + y0 * z1 - z0 * y1
    Q0Q1_y = w0 * y1 - x0 * z1 + y0 * w1 + z0 * x1
    Q0Q1_z = w0 * z1 + x0 * y1 - y0 * x1 + z0 * w1
    # Create a 4 element array containing the final quaternion
    final_quaternion = [Q0Q1_w, Q0Q1_x, Q0Q1_y, Q0Q1_z]
    # Return a 4 element array containing the final quaternion (q02,q12,q22,q32) 
    return final_quaternion

```

[現有的代碼庫 MPU-9250 帶補償係數](https://github.com/micropython-IMU/micropython-fusion)

