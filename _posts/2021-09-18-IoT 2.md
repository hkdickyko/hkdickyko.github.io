---
category: [積體電路]
tags: [IoT, 編程]
title: IoT-2
date: 2021-09-18 22:34:36
---

## MicroPython MPU-9250 (MPU-6500 + AK8963)


[現有的代碼庫 MPU-9250](https://github.com/tuupola/micropython-mpu9250)

![Alt ESP32](../assets/img/iot/mpu9250.png)

## MPU9250 是兩個集成電路(MPU-6500 + AK8963)的組合

![Alt ESP32](../assets/img/iot/mpu9250axis.png)

## x, y 和 z 軸的關係變量值的說明

![Alt ESP32](../assets/img/iot/3axis.png)


## 上述代碼庫中的默認值如下

三軸加速度計 $ m/s^2 $ , 三軸磁力計 $ μT $ , 三軸陀螺儀 $ rad/s $ 

## 校準芯片數據方法簡介

芯片的數據夾雜有噪音，在芯片處理靜止狀態時數據擺動都可能超過 2% 。 除了噪音，各項數據還會有偏移的現象，也就是說數據並不是圍繞靜止工作點擺動，因此要先對數據偏移進行校準 ，再通過濾波算法消除噪音。  

## 三軸加速度計 ( $ A_{\theta} $ , $ A_{\phi} $ , $ M_{\varphi} $ )

加速度計的三軸分量 $ ACC_{X} $ , $ ACC_{Y} $ 和 $ ACC_{Z} $ 均為16位有符號整數，分別表示器件在三個軸向上的加速度，取負值時加速度沿座標軸負向，取正值時沿正向。

三個加速度分量均以重力加速度 *g* 的倍數為單位，能夠表示的加速度範圍，即倍率可以統一設定，有4個可選倍率：2g, 4g, 8g, 16g。 只需將不同倍率對應的標誌寫入對應寄存器即可修改。 倍率默認設定為2g，以 $ ACC_{X} $ 為例，在倍率為2g的時候，$ ACC_{X} $ 的最小值為-32768，最大值為32768。 當 $ ACC_{X} $ 為32768時，當前加速度為沿 **X** 軸正方向2倍的重力加速度。

加速度计算公式如图所示： 

$$ A_{x}=\frac{2\times{g}\times{ACC_{X}}}{32768} $$

---

![Alt ESP32](../assets/img/iot/mpu6050.png)

---

### 繞 X 軸旋轉角度 $ A_{\theta} $ = roll	

$$ A_{\theta}=\arctan\left(\frac{A_{y}}{A_{z}}\right) $$

### 繞 Y 軸旋轉角度 $ A_{\phi} $ = pitch 

$$ A_{\phi}=\arctan\left(\frac{-A_{x}}{\sqrt{A_{y}^2+A_{z}^2}}\right) $$ 


 - $ A_{x}, A_{y}, A_{y} $ 是三軸加速度計測量的 x, y 和 z 軸加速度變化 

## 用三軸加速度計及三軸磁力計估計偏航 *yaw*

三軸加速度計分量就不能這樣簡單的完成了，因為芯片靜止時的加速度並不為 **0**。

加速度值的偏移來自兩個方面，
 - 芯片的測量精度，導至它測得的加速度向量並不垂直於大地稱為讀數偏移；
 - 芯片在整個系統上安裝的精度是有限的，系統與芯片的座標系很難達到完美重合稱為角度偏移。 
因為讀數和角度之間是非線性關係，所以要想以高精度進行校準必須先單獨校準讀數偏移，再把芯片固定在系統中後校準角度偏移。然而，由於校準角度偏移需要專業設備且對於一般應用來說，兩步校準帶來的精度提升並不大，因此通常只進行讀數校準即可。

為了盡量避免讀數偏移帶來的影響，首先將開發板牢牢地固定在系統中，並使二者座標系盡可能的重合。
此時，我們認為芯片的 $ ACC_{X} $ 和 $ ACC_{Y} $ 的理論值應為 **0**，$ ACC_{Z} $ 的理論值應為-16384（默認2g的倍率）。
由於 $ ACC_{X} $ 和 $ ACC_{Y} $ 的理論值應為0，與角速度量的校準類似，這兩個讀數偏移量可用統計均值的方式校準。  $ ACC_{Z} $ 則需要多一步處理，即在統計偏移量的過程中，每次讀數都要加上16384，再進行統計均值校準。

$$ \varphi_{xyz} = \arctan\left(\frac{h_{y}}{h_{x}}\right)\pm{D} $$

 - D 是地理北與水平分量之間的偏角

[網上文章關於在磁域中完成三軸磁力計校準](https://www.hindawi.com/journals/js/2010/967245/)

---

### 繞 Z 軸旋轉角度 $ M_{\varphi} $ = yaw

$$ A_{norm}=\sqrt{A_{x}^2 + A_{y}^2 + A_{z}^2 } $$

$$ M_{norm}=\sqrt{mag_{x}^2 + mag_{y}^2 + mag_{z}^2 } $$

$$ m_{x}=\frac{mag_{x}}{M_{norm}} $$ 

$$ m_{y}=\frac{-mag_{y}}{M_{norm}} $$

$$ m_{z}=\frac{mag_{z}}{M_{norm}} $$

$$ \phi=-\arcsin\left(\frac{A_{x}}{A_{norm}}\right) $$

$$ \theta=\arcsin\left(\frac{A_{y}}{\cos(\phi)\times{A_{norm}}}\right) $$

$$ M_{x}=m_{x}\times\cos(\phi)+m_{z}\times\sin(\phi) $$

$$ M_{y}=m_{x}\times\sin(\theta)\times\sin(\phi)+m_{y}\times\cos(\theta)-m_{z}\sin(\theta)\times\cos(\phi) $$

### 以上公式 (4) 但仍不能計算出正確數值，有以下兩個原因：
---
 - 因每當 $ M_{x}=0 $ 時，公式就會失敗

 - 對於 $ M_{x}=M_{y}=1 $ 和 $ M_{x}=M_{y}=-1 $ ，它給出相同的方位角。 換句話說，它無法區分東北和西南。所以要有如下計算安排。

在 $ M_{x}>0 $ 下:

$$ M{\varphi}=\arctan\left(\frac{M_{y}}{M_{x}}\right) $$

在 $ M_{x}=0 $ 及 $ M_{y}>0 $ 下:

$$ M{\varphi} = \frac{\pi}{2} $$

在 $ M_{x}=0 $ 及 $ M_{y}<0 $ 下

$$ M{\varphi} = -\frac{\pi}{2} $$

在 $ M_{x}<0 $ 及 $ M_{y}\geq{0} $ 下

$$ M{\varphi}=\arctan\left(\frac{M_{y}}{M_{x}}\right)+\pi $$

在 $ M_{x}<0 $ 及 $ M_{y} < 0 $ 下

$$ M{\varphi}=\arctan\left(\frac{M_{y}}{M_{x}}\right)-\pi $$

 - $ mag_{x}, mag_{y}, mag_{z} $ 是三軸磁力計測量的 x, y 和 z 軸磁場強度變化

## 三軸陀螺儀 ( $ G_{\theta}, G_{\phi}, G_{\varphi} $ )

繞 *X*, *Y* 和 *Z* 三個座標軸旋轉的角速度分量 $ GYR_{X} $ , $ GYR_{Y} $ 和 $ GYR_{Z} $ 均為16位有符號整數。 從原點向旋轉軸方向看去，取正值時為順時針旋轉，取負值時為逆時針旋轉。

三個角速度分量以 **度/秒** 為單位，能夠表示的角速度範圍，即倍率可統一設定，有4個可選倍率：250度/秒, 500度/秒, 1000度/秒, 2000度/秒。 以 $ GYR_{X} $ 為例，若倍率設定為250度/秒，則意味著GYR取正最大值32768時，當前角速度為順時針250度/秒；若設定為500度/秒，取32768時表示當前角速度為順時針500度/秒。顯然，倍率越低精度越好，倍率越高表示的範圍越大。倍率默認設定為250度/秒。 只需將不同倍率對應的標誌寫入對應寄存器即可修改。

三軸陀螺儀校準是比較簡單的工作，我們只需要找出擺動的數據圍繞的中心點即可。 我們以 $ GYR_{X} $ 為例，在芯片處理靜止狀態時，這個讀數理論上講應當為 **0**但它往往會存在偏移量，取一組校準值的均值進行計算偏移量，每次的讀數都減去偏移量就可以得到校准後的讀數了。 當然這個偏移量只是估計值，比較準確的偏移量要對大量的數據進行統計才能獲知，數據量越大越準，但統計的時間也就越慢。 一般校準可以在每次啟動系統時進行。
  
$$ w_{x}=\frac{1000\times{GYR_{X}}}{32768} $$ 

---

$$ G_{\theta}=w_{x}\times\delta(t) $$

$$ G_{\phi}=w_{y}\times\delta(t) $$

$$ G_{\varphi}=w_{z}\times\delta(t) $$


對三軸加速度計輸入值( $ A_{\theta}, A_{\phi}, M_{\varphi} $ )和三軸陀螺儀( $ G_{\theta}, G_{\phi}, G_{\varphi} $ )使用卡爾曼濾波器計算找出( $ \theta, \phi, \varphi $ )

---

## 卡爾曼濾波器計算







 
main.py - 處理最小功能的示例 

```python
from machine import I2C, Pin, Timer
from mpu9250 import MPU9250
from mpu6500 import MPU6500
from ak8963 import AK8963
import math
from d3d import D3D

i2c = I2C(scl=Pin(22), sda=Pin(21))
dummy = MPU9250(i2c) # this opens the bybass to access to the AK8963

# Code for Calibration
print("Waiting for Calibration")

mpu6500 = MPU6500(i2c)
#gyro_Offset = mpu6500.calibrate()
#print(gyro_Offset)
ak8963 = AK8963(i2c)
#offset, scale = ak8963.calibrate(count=1024, delay=300)
#print("{}:{}".format(offset, scale))
#print("Calibration completed.")
mpu6500 = MPU6500(i2c, gyro_offset=(0.009607737, -0.02210805, -0.005498386)) #gyro_Offset)
ak8963 = AK8963(i2c, offset=(35.66777, 21.11485, 23.03818), scale=(1.018878, 0.9046935, 1.095072)) #offset=offset, scale=scale)
sensor = MPU9250(i2c, mpu6500=mpu6500, ak8963=ak8963)

def read_sensor(timer):
  radAngXYZ = d3x.getAngleXYZ(sensor.acceleration, sensor.magnetic)
  print(radAngXYZ)


print("MPU9250 id: " + hex(sensor.whoami) + "\n")
d3x = D3D()
timer_0 = Timer(0)
timer_0.init(period=1000, mode=Timer.PERIODIC, callback=read_sensor)

```    


D3D.py 處理 *3D* 計算代碼

```python
import math
import array
try:
    import utime as time
except ImportError:
    import time

class D3D:

  def __init__(self, timediff=None):
    self.factor = 180 / math.pi
    self.q_angle = 0.001
    self.q_bias = 0.003
    self.R = 0.03
    self.angle = 0.0
    self.bias = 0.0
    self.rate = 0.0
    self.P = array.array('d', [0.0, 0.0, 0.0, 0.0])
    self.P[0] = 0.0
    self.P[1] = 0.0
    self.P[2] = 0.0
    self.P[3] = 0.0
    
  def getAngle(self, newAngle, newRate, dt):
    self.rate = newRate - self.bias
    self.angle = self.angle + (dt * self.rate)
    self.P[0] = self.P[0] + (dt*self.P[3] - self.P[1] - self.P[2] + self.q_angle);
    self.P[1] = self.P[1] - (dt*self.P[3])
    self.P[2] = self.P[2] - (dt*self.P[3])
    self.P[3] = self.P[3] + self.q_bias * dt
    S = P[0] + self.R
    K = array.array('d', [0.0, 0.0])
    K[0] = P[0] / S
    K[1] = P[2] / S
    y = newAngle - self.angle
    self.angle = self.angle + K[0] * y
    self.bias = self.bias + K[1] * y
    P00_temp = P[0]
    P01_temp = P[1]
    P[0] = P[0] - K[0] * P00_temp
    P[1] = P[1] - K[0] * P01_temp
    P[2] = P[2] - K[1] * P00_temp
    P[3] = P[3] - K[1] * P01_temp
    return self.angle

  def setAngle(self, angle):
    self.angle = angle
    
  def getRate(self):
      return self.rate
      
  def setQAngle(self, angle):
    self.q_angle = angle
      
  def setQBias(self, bias):
    self.q_bias = bias
    
  def setR(self, R):
    self.R = R

  def getQAngle(self):
    return self.q_angle
      
  def getQBias(self):
    return self.q_bias
    
  def getR(self):
    return self.R

  def getAngleXYZ(self, acceleration, magnetic):
    AccX, AccY, AccZ = acceleration
    magX, magY, magZ = magnetic
    
    A_roll = math.atan2(AccY, AccZ) * self.factor
    A_pitch = math.atan2(-AccX, math.sqrt((AccY * AccY) + (AccZ *AccZ))) * self.factor
    
    A_norm = math.sqrt(AccX * AccX + AccY * AccY + AccZ * AccZ)
    pitch = -math.asin(AccX / A_norm)
    roll = math.asin(AccY / (math.cos(pitch) * A_norm))
    
    M_norm = math.sqrt(magX * magX + magY * magY + magZ * magZ)
    m_x = magX / M_norm
    m_y = -1 * magY / M_norm
    m_z = magZ / M_norm
    
    M_x = (m_x * math.cos(pitch)) + (m_z * math.sin(pitch));
    M_y = (m_x * math.sin(roll) * math.sin(pitch)) + (m_y * math.cos(roll)) - (m_z * math.sin(roll) * math.cos(pitch))
    M_yaw = math.atan2(-M_y, M_x) * self.factor
    if M_yaw > 360:
        M_yaw = M_yaw - 360
    if M_yaw < 0:
        M_yaw = M_yaw + 360
    return (A_roll, A_pitch, M_yaw)

```

[現有的代碼庫 MPU-9250 帶補償係數](https://github.com/micropython-IMU/micropython-fusion)

[MPU-9250 調教準參數計算原理](https://github.com/alrevuelta/sensor-calibration)







   