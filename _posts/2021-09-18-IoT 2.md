---
category: [積體電路, 編程]
tags: [IoT-2]
---

## MicroPython MPU-9250 (MPU-6500 + AK8963)


[現有的代碼庫 MPU-9250](https://github.com/tuupola/micropython-mpu9250)

![Alt ESP32]({{ '/assets/img/IoT/mpu9250.png' | relative_url }})

## MPU9250 是兩個集成電路(MPU-6500 + AK8963)的組合

![Alt ESP32]({{ '/assets/img/IoT/mpu9250axis.png' | relative_url }})

## x, y 和 z 軸的關係變量值的說明

![Alt ESP32]({{ '/assets/img/IoT/3axis.png' | relative_url }})

## 繞 X 軸旋轉角度 &Phi; = roll	

![Alt ESP32]({{ '/assets/img/IoT/xaxis.png' | relative_url }})

## 繞 Y 軸旋轉角度 &theta; = pitch 

![Alt ESP32]({{ '/assets/img/IoT/yaxis.png' | relative_url }})


## 繞 Z 軸旋轉角度 &psi; = yaw

![Alt ESP32]({{ '/assets/img/IoT/zaxis.png' | relative_url }})

 - Ax, Ay, Az 是 x, y 和 z 軸加速度變化 
 - mx, my, mz 是 x, y 和 z 軸磁場強度變化

```python
from machine import I2C, Pin, Timer
from mpu9250 import MPU9250
from ak8963 import AK8963
import math
from d3d import D3D

i2c = I2C(scl=Pin(22), sda=Pin(21))
dummy = MPU9250(i2c) # this opens the bybass to access to the AK8963

# Code for Calibration
print("Waiting for Calibration")
ak8963 = AK8963(i2c)
offset, scale = ak8963.calibrate(count=256, delay=200)
print("Calibration completed.")

# sensor = MPU9250(i2c, ak8963=ak8963)
# print("{}:{}".format(offset, scale))
# ak8963 = AK8963(i2c, offset=(44.3584, -10.05469, -24.70254), scale=(0.9937236, 0.9021546, 1.129655))

sensor = MPU9250(i2c, ak8963=ak8963)


def getAngle(acceleration, magnetic):
  x, y, z = acceleration
  magX, magY, magZ = magnetic
  pitch = math.atan(x / math.sqrt((y * y) + (z * z)));
  roll = math.atan(y / math.sqrt((x * x) + (z * z)));
  yaw = math.atan(z / math.sqrt((x * x) + (y * y)));
  Xh = (magX * math.cos(pitch)) + (magY * math.sin(roll) * math.sin(pitch)) + (magZ * math.cos(roll) * math.sin(pitch));
  Yh = (magY * math.cos(roll)) - (magZ * math.sin(roll));
  yaw = math.atan2(-Yh, Xh);
  #convert radians into degrees
  pitch = pitch  * (180.0 / math.pi); 
  roll = roll * (180.0 / math.pi); 
  yaw = yaw * (180.0 / math.pi); 
  print("roll:{}, pitch:{}, yaw:{}".format(roll, pitch, yaw))
  d2R = d3x.deg2Rad([roll, pitch, yaw])
  print(d2R)
  qr = d3x.quaternion_from_euler(d2R[0], d2R[1], d2R[2])
  print(qr)
#   qrx = d3x.euler_from_quaternion(qr)
#   print(d3x.rad2Deg(qrx))

def read_sensor(timer):
#     print(sensor.acceleration)
#     print(sensor.gyro)
#     print(sensor.magnetic)
#     print(sensor.temperature)
    getAngle(sensor.acceleration, sensor.magnetic)
#     fuse.update(sensor.acceleration, sensor.gyro, sensor.magnetic)
#     print(fuse.magbias)
#     print("Heading, Pitch, Roll: {:7.3f} {:7.3f} {:7.3f}".format(fuse.heading, fuse.pitch, fuse.roll))
#     await fuse.start()
# async def read_coro():
#     imu.mag_trigger()  # Hardware dependent: trigger a nonblocking read
#     await asyncio.sleep_ms(20)  # Wait for mag to be ready
#     return imu.accel.xyz, imu.gyro.xyz, imu.mag_nonblocking.xyz
#     # Returned (ax, ay, az), (gx, gy, gz), (mx, my, mz)

#fuse = Fusion(read_coro)

# async def read_coro():
#     sensor.mag_trigger()  # Hardware dependent: trigger a nonblocking read
#     await asyncio.sleep_ms(20)  # Wait for mag to be ready
#     return imu.accel.xyz, imu.gyro.xyz, imu.mag_nonblocking.xyz
#     # Returned (ax, ay, az), (gx, gy, gz), (mx, my, mz)
# 
# print(update_nomag( sensor.acceleration, sensor.gyro) )

print("MPU9250 id: " + hex(sensor.whoami))
d3x = D3D() 
timer_0 = Timer(0)
timer_0.init(period=1000, mode=Timer.PERIODIC, callback=read_sensor)



```    


[現有的代碼庫 MPU-9250 帶補償係數](https://github.com/micropython-IMU/micropython-fusion)

