---
category: 編程
tags: [C]
---

# C 程序設計

## 前置處理器處理過的 C 程式碼

預處理在本質上是一種`字串代換的過程`。前置處理器會將 C 程式碼中`巨集宣告`的部分，代換成不含巨集的 C 程式碼。之後再將處理過的 C 程式碼導給 C 編譯器，進行真正的編譯。如下面的例子：

| 宏定義 | 宏公式 |
|-|-|
|#define `SIZE` 5 | #define `SIZE` 5 |
|int main(void) | int main(void)|
|{              | { |
|&nbsp;&nbsp;&nbsp;&nbsp;int arr[`SIZE`];|&nbsp;&nbsp;&nbsp;&nbsp;int arr[`5`];|
|&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i < SIZE; i++) {|&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i < `5`; i++) { |
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i] = i + 3;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i] = i + 3;|
|&nbsp;&nbsp;&nbsp;&nbsp;}|&nbsp;&nbsp;&nbsp;&nbsp;}|         
|}|}|

實際上，在轉換後的 C 程式中，並沒有 SIZE 這個變數。每個 SIZE 所在的位置會經前置處理器代換為 `5`。

## 在C定義中巨集的特殊用法

 - `＃` : 在巨集展開的時候會將#後面的參數替換成字符串，如：

         ＃define p(exp) printf(#exp);

         調用p(asdfsadf)的時候會將#exp換成 "asdfsadf"。

 - `##` : 將前後兩個的單詞拼接在一起。例如：

         #define cat(x,y) x##y

         調用cat(var, 123)展開後成為 var123。

 - `#@` : 將值序列變為一個字符

         #define ch(c) #@c

         調用ch(a)展開後成為 'a'。

## 有用的位元運算宏

 `BITNAME`是可變名稱，用於組合`_MASK`或`_POS`，用戶預定義了一些`_MASK`名稱掩蓋沒用的部分，並用`_POS`得有用的位元的值。

 用`BITNAME_MASK`抹去value不用的位元的值， 接著用`BITNAME_POS`右移取得value需要的位元值。
 
| 宏定義 | 
|-|
|#define GET_BITS(BITNAME， value) |
| ((value & BITNAME##_MASK) >> BITNAME##_POS)|

用`~BITNAME_MASK`抹去value有用的位元的值， 接著用`BITNAME_POS`左移value需要的位元值至合適的位置，接著用`BITNAME_MASK`抹去value不用的位元的值，然後將兩者的位元組成在一起。

| 宏定義 | 
|:-|
|#define SET_BITS(BITNAME， value， reg_Var)|
|((reg_Var & ~BITNAME##_MASK) \| ((value << BITNAME##_POS) & BITNAME##_MASK))|

 用`BITNAME_POS`取得有用的位元的值

| 宏定義 | 
|:-|
|#define GET_BITS_POS(BITNAME， reg_Data) |
| (reg_Data & BITNAME##_MASK)|

 用`BITNAME_MASK`掩蓋reg_Data位元的值， 接著用`BITNAME_MASK`取得data位元的值。然後將兩者的位元組成在一起。

| 宏定義 |
|:-|
|#define SET_BITS_POS(BITNAME， data， reg_Data) |
| ((reg_Data & ~BITNAME##_MASK) \| (data & BITNAME##_MASK))|

## 用巨集進行條件編譯

利用巨集中有關條件編譯的語法，我們可以利用這項特性保留所的需程式碼，去除不需要的程式碼。當前置處理器第一次讀到此標頭檔時，`SHOMETHING_H`是未定義的，這時候前置處理器會繼續執行下一行敘述。

反之，當前置處理器第二次讀到此標頭檔時，由於`SOMETHING_H`己定義了，前置處理器不會繼續執行後續的內容，巧妙地避開了重覆引入的議題。

```
#ifndef SOMETHING_H
#define SOMETHING_H

/* Declare some data types and public functions. */

#endif /* SOMETHING_H */
```
## extern "C" 敘述

我們不希望 C++ 編譯器將 C 函式庫的標頭檔內的函式宣告也 mangling，所以我們用 extern "C" 敘述告知 C++ 編譯器不要對該區塊內的函式名稱 mangling。

```
#ifdef __cplusplus
extern "C" {
#endif

/* Some declarations. */

#ifdef __cplusplus
}
#endif
```

## 用巨集創造語法

為 C 語言創造新語法。這種用法簡化名稱定義對於積體電路程序設計有幫助。
```
typedef unsigned int uint;
```

# C 指標

C 語言中特有的指標，可以透過記憶體映射的方式直接控制硬體，這也是為什麼 C 語言在硬體系統特別強大的原因。

記憶體就像一個大櫃子，每個格子都有相對應的地址。在16位元系統中，地址將為16位元，在32位元系統中，地址將為32位元。依此類推。而記憶體最小單元是 1 byte，等於4位元。

程序設計中會向記憶體要一塊空間來儲存變數值，這個儲存空間有一個起始位址。再加上這個變數的名稱「b」與變數值「2」。

在宣告一個變數，比如宣告變數的名稱「b」的時候，在 C 語言裡面，有個運算符號是用來「'取址'」，就是「&」是「`指標`」。「&b」就是變數的名稱「b」的起始位址。 

這邊需要特別注意的是，我講的是「`指標`」，而不是「`指標變數`」；這兩個是不同的東西。

C 語言中的另一個運算元「*」是「`指標變數`」，能利用一個變數的地址、去拿到這個變數，直接把地址寫出來然後執行。指標變數就是用來存「地址」的變數。

事實上，「*&b」和「b」的意義是相等的。

利用 pointer 去拿到它指向的 b 這個變數:
```
int b = 2; 
int *pointer = &b;
```
也就是說變數 b 在記憶體中對應了一塊儲存空間，而這塊儲存空間總有一個起始的地址。所以 pointer 對應到的就是這個起始地址。

## 記憶體

![Alt memory]({{ ‘/assets/img/ccode/memory.png’ | relative_url }})
