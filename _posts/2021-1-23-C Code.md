---
category: 編程
tags: [C]
---

# C 程序設計

## 前置處理器處理過的 C 程式碼

預處理在本質上是一種`字串代換的過程`。前置處理器會將 C 程式碼中`巨集宣告`的部分，代換成不含巨集的 C 程式碼。之後再將處理過的 C 程式碼導給 C 編譯器，進行真正的編譯。如下面的例子：

| 宏定義 | 宏公式 |
|-|-|
|#define `SIZE` 5 | #define `SIZE` 5 |
|int main(void) | int main(void)|
|{              | { |
|&nbsp;&nbsp;&nbsp;&nbsp;int arr[`SIZE`];|&nbsp;&nbsp;&nbsp;&nbsp;int arr[`5`];|
|&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i < SIZE; i++) {|&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i < `5`; i++) { |
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i] = i + 3;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i] = i + 3;|
|&nbsp;&nbsp;&nbsp;&nbsp;}|&nbsp;&nbsp;&nbsp;&nbsp;}|         
|}|}|

實際上，在轉換後的 C 程式中，並沒有 SIZE 這個變數。每個 SIZE 所在的位置會經前置處理器代換為 `5`。

## 在C定義中巨集的特殊用法

 - `＃` : 在巨集展開的時候會將#後面的參數替換成字符串，如：

         ＃define p(exp) printf(#exp);

         調用p(asdfsadf)的時候會將#exp換成 "asdfsadf"。

 - `##` : 將前後兩個的單詞拼接在一起。例如：

         #define cat(x,y) x##y

         調用cat(var, 123)展開後成為 var123。

 - `#@` : 將值序列變為一個字符

         #define ch(c) #@c

         調用ch(a)展開後成為 'a'。

## 有用的位元運算宏

 `BITNAME`是可變名稱，用於組合`_MASK`或`_POS`，用戶預定義了一些`_MASK`名稱掩蓋沒用的部分，並用`_POS`得有用的位元的值。

 用`BITNAME_MASK`抹去value不用的位元的值， 接著用`BITNAME_POS`右移取得value需要的位元值。
 
| 宏定義 | 
|-|
|#define GET_BITS(BITNAME， value) |
| ((value & BITNAME##_MASK) >> BITNAME##_POS)|

用`~BITNAME_MASK`抹去value有用的位元的值， 接著用`BITNAME_POS`左移value需要的位元值至合適的位置，接著用`BITNAME_MASK`抹去value不用的位元的值，然後將兩者的位元組成在一起。

| 宏定義 | 
|:-|
|#define SET_BITS(BITNAME， value， reg_Var)|
|((reg_Var & ~BITNAME##_MASK) \| ((value << BITNAME##_POS) & BITNAME##_MASK))|

 用`BITNAME_POS`取得有用的位元的值

| 宏定義 | 
|:-|
|#define GET_BITS_POS(BITNAME， reg_Data) |
| (reg_Data & BITNAME##_MASK)|

 用`BITNAME_MASK`掩蓋reg_Data位元的值， 接著用`BITNAME_MASK`取得data位元的值。然後將兩者的位元組成在一起。

| 宏定義 |
|:-|
|#define SET_BITS_POS(BITNAME， data， reg_Data) |
| ((reg_Data & ~BITNAME##_MASK) \| (data & BITNAME##_MASK))|

## 用巨集進行條件編譯

利用巨集中有關條件編譯的語法，我們可以利用這項特性保留所的需程式碼，去除不需要的程式碼。當前置處理器第一次讀到此標頭檔時，`SHOMETHING_H`是未定義的，這時候前置處理器會繼續執行下一行敘述。

反之，當前置處理器第二次讀到此標頭檔時，由於`SOMETHING_H`己定義了，前置處理器不會繼續執行後續的內容，巧妙地避開了重覆引入的議題。

```
#ifndef SOMETHING_H
#define SOMETHING_H

/* Declare some data types and public functions. */

#endif /* SOMETHING_H */
```
## extern "C" 敘述

我們不希望 C++ 編譯器將 C 函式庫的標頭檔內的函式宣告也 mangling，所以我們用 extern "C" 敘述告知 C++ 編譯器不要對該區塊內的函式名稱 mangling。

```
#ifdef __cplusplus
extern "C" {
#endif

/* Some declarations. */

#ifdef __cplusplus
}
#endif
```

## 用巨集創造語法

為 C 語言創造新語法。這種用法簡化名稱定義對於積體電路程序設計有幫助。
```
typedef unsigned int uint;
```

# C 指標

C 語言中特有的指標，可以透過記憶體映射的方式直接控制硬體，這也是為什麼 C 語言在硬體系統特別強大的原因。

記憶體就像一個大櫃子，每個格子都有相對應的地址。在16位元系統中，地址將為16位元，在32位元系統中，地址將為32位元。依此類推。而記憶體最小單元是 1 byte，等於4位元。

程序設計中會向記憶體要一塊空間來儲存變數值，這個儲存空間有一個起始位址。再加上這個變數的名稱「b」與變數值「2」。

在宣告一個變數，比如宣告變數的名稱「b」的時候，在 C 語言裡面，有個運算符號是用來「'取址'」，就是「&」是「`指標`」。「&b」就是變數的名稱「b」的起始位址。 

這邊需要特別注意的是，我講的是「`指標`」，而不是「`指標變數`」；這兩個是不同的東西。

C 語言中的另一個運算元「*」是「`指標變數`」，能利用一個變數的地址、去拿到這個變數，直接把地址寫出來然後執行。指標變數就是用來存「地址」的變數。

事實上，「*&b」和「b」的意義是相等的。

利用 pointer 去拿到它指向的 b 這個變數:
```
int b = 2; 
int *pointer = &b;
```
也就是說變數 b 在記憶體中對應了一塊儲存空間，而這塊儲存空間總有一個起始的地址。所以 pointer 對應到的就是這個起始地址。

## 記憶體

![Alt memory]({{ '/assets/img/ccode/memory.png' | relative_url }})

## text：程式碼
文字區段（text segment）也稱為程式碼區段（code segment），這裡存放的是可執行的 CPU 指令（instructions）。

這個區段通常位於 heap 或 stack 之後，避免因 heap 或 stack 溢位而覆寫 CPU 指令。

通常文字區段的資料是可以共用的，當多個同樣的程式在執行時，在記憶體中只需要存有一份就夠了，而這個文字區段通常都是唯讀的，避免程式本身誤改了自己的 CPU 指令。

## data：初始化靜態變數
初始化資料區段（initialized data segment）儲存的是一些已經初始化的靜態變數，例如有經過初始化的 C 語言的全域變數（global variables）以及靜態變數（static variables）都是儲存於此處。

這個區段的變數又可分為唯讀區域（read-only area）以及可讀寫區域（read-write area），可讀寫區域用於存放一般變數，其資料會隨著程式的執行而改變，而唯讀區域則是存放固定的常數。

## bss：未初始化靜態變數
未初始化資料區段（uninitialized data segment）又稱為 bss 區段（這個名稱的起源來自於古老的組譯器，代表 block started by symbol）是儲存尚未被初始化的靜態變數，而這些變數在程式執行之前會被系統初始化為 0 或是 null。

## stack：區域變數
堆疊區段（stack segment）用於儲存函數的區域變數，以及各種函數呼叫時需要儲存的資訊（例如函數返回的記憶體位址還有呼叫者函數的狀態等），每一次的函數呼叫就會在堆疊區段建立一個 stack frame，儲存該次呼叫的所有變數與狀態，這樣一來同一個函數重複被呼叫時就會有不同的 stack frame，不會互相干擾，遞迴函數就是透過這樣的機制來執行的。

## heap：動態配置變數
heap 區段的記憶體空間用於儲存動態配置的變數，例如 C 語言的 malloc 以及 C++ 的 new 所建立的變數都是儲存於此。

堆疊區段一般的狀況會從高記憶體位址往低記憶體位址成長，而 heap 剛好從對面以相反的方向成長。

## system：命令列參數與環境變


