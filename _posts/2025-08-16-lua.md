---
category: [系统]
tags: [编程, 電子]
title: Lua
date: 2025-08-16 1:00:00
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
    text-align: center;
  }
  td.left {
    vertical-align: center;
    text-align: left;
  }  
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
  }
</style>

# Lua

Lua 是一种编程语言，而 luac 是 Lua 编译器。Lua 代码以人类可读的文本格式编写，而 luac 将该代码转换为 Lua 解释器可以执行的二进制格式（字节码）。优点如下：

 - lua 是一个免费、小巧、简单、强大、高效、轻量级的嵌入式的脚本语言，lua 当前的发行版本一般小於300k
 - 它是用 C 语言开发的项目，所以可以在大部分的操作系统上运行
 - lua 是目前速度最快的脚本语言，既可以提升语言的灵活性还可以最大限度的保留速度
 - 其语法非常简单，没有特例
 - lua 还可以作为 C 的 API 来使用

# Luac

它将 lua 源码文件，生成为二进制 01 编码的程序，这样做的好处如下：
 - 安全
 - 机器识别速度快。原来读 lua 文件要经过一遍语义分析等，现在省掉了中间几个步骤。


# LuaJIT

LuaJIT 已经在多个领域广泛应用，特别是在游戏领域，更是在很多地方替代了以前的 lua 源码或者 luac 字节码。不仅 LuaJIT 在一定程度上带来了效率的提高，而且对于逆向工程师来说，其逆向难度也大大增加，暂时还没办法将其转化为可读性强的 lua 源码。

# Lua 和 C 通信

Lua 和 C 通信的主要方法是通过一个虚拟栈来完成，lua 提供了 C API 对栈进行操作。几乎所有的 API 调用都是对栈上的值进行操作，所有 C 与 Lua 之间的数据交换也都通过这个栈来完成。另外，也可以使用栈来保存临时变量。
　　C API 是一个 C 代码与 Lua 进行交互的函数集。由以下部分组成:
 - 读写 Lua 全局变量的函数
 - 调用 Lua 函数的函数
 - 运行 Lua 代码片断的函数
 - 注册 C 函数然后可以在 Lua 中被调用的函数

Lua 以一个严格的 LIFO 规则（后进先出；即是始终存取栈顶）来操作栈：　

　- C 调用 Lua 时，返回结果只会改变栈顶部分
　- 编写 C 代码比较自由，可以查询栈上的任何元素，在任何一个位置插入和删除元素


在调用 C API 时有几个重要的头文件，这几个头文件都是 lua 源代码，可以直接下载使用：

 - lua.h：基础函数库，对栈的基本操作都在里面实现，lua_前缀
 - lauxlib.h：辅助库，luaL_前缀，利用 lua.h 实现的更高层的抽象
 - lualib.h：为了保持Lua的苗条，所有的标准库以单独的包提供，如果不需要就可以不使用它们。
    - 头文件 lualib.h 定义了打开这些库的函数。例如调用 luaopen_io，以创建 io table 并注册 I/O 函数（io.read,io.write 等等）到 Lua 环境中。

## 常用辅助函数

```c
// 创建一个新环境 (新的 Lua 状态)
lua_State *luaL_newstate (void);
// 打开指定状态机中的所有 Lua 标准库。如：print, pcall
void luaL_openlibs (lua_State *L);
// 将一个字符串加载为  Lua  代码块
int luaL_loadstring (lua_State *L, const char *s); 
// 把一个文件加载为  Lua  代码块
int luaL_loadfile (lua_State *L, const char *filename);
int luaL_loadfilex (lua_State *L, const char *filename,const char *mode);
int luaL_loadbuffer (lua_State *L,const char *buff,size_t sz,const char *name);
int luaL_loadbufferx (lua_State *L,const char *buff,size_t sz,const char *name,const char *mode);
```

## 常用的基础函数 - 压入栈元素

```c
// 将空值压栈
void lua_pushnil (lua_State *L);
void lua_pushboolean (lua_State *L, int bool);
// 把一个值为 n 的浮点数压栈
void lua_pushnumber (lua_State *L, double n);
void lua_pushlstring (lua_State *L, const char *s, size_t length);
// 将指针 s 指向的零结尾的字符串压栈。因此 s 处的内存在函数返回后，可以释放掉或是立刻重用于其它用途
void lua_pushstring (lua_State *L, const char *s);
```

检查一个元素能否被转换成指定的类型。

```c
// 当索引的值是 nil 时，返回 1，否则返回 0
int lua_isnil (lua_State *L, int index);
// 当索引值是一个数字，或可转数字的字符串时，返回 1，否则返回 0
int lua_isnumber (lua_State *L, int index);
// 当索引值是一个字符串或是一个数字时，返回 1 ，否则返回 0
int lua_isstring (lua_State *L, int index);
// 当索引值是一张表时，返回 1，否则返回 0
int lua_istable (lua_State *L, int index);
// 当索引值是一个布尔量时，返回 1，否则返回 0
int lua_isboolean (lua_State *L, int index);
// 当索引值是一个函数时，返回 1，否则返回 0
int lua_isfunction (lua_State *L, int index);
```

从栈中获得值。即使给定的元素类型不正确，调用这些函数也没问题。

```c
int lua_toboolean (lua_State *L, int index);
double lua_tonumber (lua_State *L, int index);
const char * lua_tostring (lua_State *L, int index);
```

Lua_tostring 函数返回一个指向字符串的内部拷贝的指针。像一个 **const**。只要这个指针对应的值还在栈内，Lua 会保证这个指针一直有效。当一个 C 函数返回后，Lua会清理它的栈，所以，有一个原则：永远不要将指向 Lua 字符串的指针保存到访问它的外部函数中。

```c
// 返回字符串的实际长度
size_t lua_strlen (lua_State *L, int index);
// 检查栈空间。默认有 20 个空闲的记录，lua.h 中的 LUA_MINSTACK 宏定义了这个常量
int lua_checkstack(lua_State *L, int sz);
// 返回栈中元素的类型
int lua_type (lua_State *L, int idx);
// 返回 type 对应的名字字符串，第二个参数为lua_type 返回的类型
const char* lua_typename(lua_State *L, int tp);
// 返回参数 arg 是否是类型 t，第三个参数为 lua_type 的取值
void luaL_checktype (lua_State *L, int arg, int t);
```

在 lua.h 头文件中，每种类型都被定义为一个常量：   
 - LUA_TNIL
 - LUA_TBOOLEAN
 - LUA_TNUMBER
 - LUA_TSTRING
 - LUA_TTABLE
 - LUA_TFUNCTION
 - LUA_TUSERDATA
 - LUA_TTHREAD

```c
// 返回栈中元素个数，它也是栈顶元素的索引
int lua_gettop (lua_State *L);
// 设置栈顶元素的索引，相当于设置栈的大小。如果开始的栈顶高于新的栈顶，顶部的值被丢弃。否则，为了得到指定的大小这个函数压入相应个数的空值（nil）到栈上。
// lua_settop(L,0)：清空堆栈
void lua_settop (lua_State *L, int index);
// 宏定义，弹出 n 个元素
#define lua_pop(L,n) lua_settop(L, -(n)-1);
// 压入堆栈上指定索引的一个抟贝到栈顶，等于拷贝 index 处的元素，然后添加到栈顶
void lua_pushvalue (lua_State *L, int index);
// 移除指定索引的元素，并将其上面所有的元素下移来填补这个位置的空白
void lua_remove (lua_State *L, int index);
// 移动栈顶元素到指定索引的位置，并将这个索引位置上面的元素全部上移至栈顶被移动留下的空隔
void lua_insert (lua_State *L, int index);
// 从栈顶弹出元素值并将其设置到指定索引位置，没有任何移动操作
void lua_replace (lua_State *L, int index);
```

### Lua和C简单交互代码

```c
#include <stdio.h>
#include <string.h>
#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

int main(void){
  char buff[256];
  int error;
  // 打开 Lua,创建一个新环境(新的 Lua 状态)
  lua_State *L = luaL_newstate();
  // 打开标准库
  luaL_openlibs(L);   
  //接收用户输入lua代码, 并编译解析
  while(fgets(buff,sizeof(buff),stdin)!=NULL){
    // luaL_loadbuffer 编译 Lua 代码(没有错误则压入栈)，lua_pcall 执行
    error = luaL_loadbuffer(L,buff,strlen(buff),"line")||lua_pcall(L,0,0,0);
    if(error){
      //执行或编译错误lua_tostring打印错误信息
      fprintf(stderr,"%s\n",lua_tostring(L,-1));
        // 从栈中弹出错误消息
        lua_pop(L,1);  
    }
  }
  lua_close(L);//关闭lua状态
  return 0;
}
```

## 编译代码

```sh
gcc -lm -g -o testlua testlua.c /usr/local/lib/liblua.a -ldl
```

### GCC 常用参数

|参数	|功能|
|:---|:---|
|-c|编译但不连结，产生.o 档|
|-o filename|指定输出档名|
|-l<font color="#FF1000">library</font>|指定连结的函式库， lib<font color="#FF1000">library</font> 为函式库名称|
|-I|增加 include header 档案的搜寻路径|
|-L|增加 library 档案的搜寻路径|
|-Wall|	显示所有的警告讯息|
|-g|编入除错资讯 (使用 GDB 除错时用)|
|-S|输出组译码|
|-E|显示预处理 (define, macro) 的结果|
|-ansi|只支持 ANSI 标准的 C 语法。 这一选项将禁止 GNU C 的某些特色 例如 asm 或 typeof 关键词|
|-Dmacro|	定义指定巨集为有效|
|-Dmarco=defn|	定义指定巨集为 defn|
|-Wa,option|将选项 (option) 传给组译器|
|-wl,option|将选项 (option) 传给连结器|

-lm 选项指定使用数学函式库。当指定 -l<font color="#FF1000">library</font>, 系统会到存放标准函式库的目录中 (通常位于 /usr/lib) 中去寻找 lib<font color="#FF1000">library</font>.a 档案。 所以所寻找的数学函式库应该是 /usr/lib/libm.a . 和表头档一样，函式库有时也放在非标准路径的目录下。