---
category: [系统]
tags: [编程, 電子]
title: Lua
date: 2025-08-16 1:00:00
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
    text-align: center;
  }
  td.left {
    vertical-align: center;
    text-align: left;
  }  
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
  }
</style>

# Lua

Lua 是一种编程语言，而 luac 是 Lua 编译器。Lua 代码以人类可读的文本格式编写，而 luac 将该代码转换为 Lua 解释器可以执行的二进制格式（字节码）。优点如下：

 - lua 是一个免费、小巧、简单、强大、高效、轻量级的嵌入式的脚本语言，lua 当前的发行版本一般小於300k
 - 它是用 C 语言开发的项目，所以可以在大部分的操作系统上运行
 - lua 是目前速度最快的脚本语言，既可以提升语言的灵活性还可以最大限度的保留速度
 - 其语法非常简单，没有特例
 - lua 还可以作为 C 的 API 来使用

# Luac

它将 lua 源码文件，生成为二进制 01 编码的程序，这样做的好处如下：
 - 安全
 - 机器识别速度快。原来读 lua 文件要经过一遍语义分析等，现在省掉了中间几个步骤。


# LuaJIT

LuaJIT 已经在多个领域广泛应用，特别是在游戏领域，更是在很多地方替代了以前的 lua 源码或者 luac 字节码。不仅 LuaJIT 在一定程度上带来了效率的提高，而且对于逆向工程师来说，其逆向难度也大大增加，暂时还没办法将其转化为可读性强的 lua 源码。

# Lua 和 C 通信

Lua 和 C 通信的主要方法是通过一个虚拟栈来完成，lua 提供了 C API 对栈进行操作。几乎所有的 API 调用都是对栈上的值进行操作，所有 C 与 Lua 之间的数据交换也都通过这个栈来完成。另外，也可以使用栈来保存临时变量。
　　C API 是一个 C 代码与 Lua 进行交互的函数集。由以下部分组成:
 - 读写 Lua 全局变量的函数
 - 调用 Lua 函数的函数
 - 运行 Lua 代码片断的函数
 - 注册 C 函数然后可以在 Lua 中被调用的函数

Lua 以一个严格的 LIFO 规则（后进先出；即是始终存取栈顶）来操作栈：　

　- C 调用 Lua 时，返回结果只会改变栈顶部分
　- 编写 C 代码比较自由，可以查询栈上的任何元素，在任何一个位置插入和删除元素


在调用 C API 时有几个重要的头文件，这几个头文件都是 lua 源代码，可以直接下载使用：

 - lua.h：基础函数库，对栈的基本操作都在里面实现，lua_前缀
 - lauxlib.h：辅助库，luaL_前缀，利用 lua.h 实现的更高层的抽象
 - lualib.h：为了保持Lua的苗条，所有的标准库以单独的包提供，如果不需要就可以不使用它们。
    - 头文件 lualib.h 定义了打开这些库的函数。例如调用 luaopen_io，以创建 io table 并注册 I/O 函数（io.read,io.write 等等）到 Lua 环境中。

## 常用辅助函数

```c
// 创建一个新环境 (新的 Lua 状态)
lua_State *luaL_newstate (void);
// 打开指定状态机中的所有 Lua 标准库。如：print, pcall
void luaL_openlibs (lua_State *L);
// 将一个字符串加载为  Lua  代码块
int luaL_loadstring (lua_State *L, const char *s); 
// 把一个文件加载为  Lua  代码块
int luaL_loadfile (lua_State *L, const char *filename);
int luaL_loadfilex (lua_State *L, const char *filename,const char *mode);
int luaL_loadbuffer (lua_State *L,const char *buff,size_t sz,const char *name);
int luaL_loadbufferx (lua_State *L,const char *buff,size_t sz,const char *name,const char *mode);
```

## 常用的基础函数 - 压入栈元素

```c
// 将空值压栈
void lua_pushnil (lua_State *L);
void lua_pushboolean (lua_State *L, int bool);
// 把一个值为 n 的浮点数压栈
void lua_pushnumber (lua_State *L, double n);
void lua_pushlstring (lua_State *L, const char *s, size_t length);
// 将指针 s 指向的零结尾的字符串压栈。因此 s 处的内存在函数返回后，可以释放掉或是立刻重用于其它用途
void lua_pushstring (lua_State *L, const char *s);
```

检查一个元素能否被转换成指定的类型。

```c
// 当索引的值是 nil 时，返回 1，否则返回 0
int lua_isnil (lua_State *L, int index);
// 当索引值是一个数字，或可转数字的字符串时，返回 1，否则返回 0
int lua_isnumber (lua_State *L, int index);
// 当索引值是一个字符串或是一个数字时，返回 1 ，否则返回 0
int lua_isstring (lua_State *L, int index);
// 当索引值是一张表时，返回 1，否则返回 0
int lua_istable (lua_State *L, int index);
// 当索引值是一个布尔量时，返回 1，否则返回 0
int lua_isboolean (lua_State *L, int index);
// 当索引值是一个函数时，返回 1，否则返回 0
int lua_isfunction (lua_State *L, int index);
```

从栈中获得值。即使给定的元素类型不正确，调用这些函数也没问题。

```c
int lua_toboolean (lua_State *L, int index);
double lua_tonumber (lua_State *L, int index);
const char * lua_tostring (lua_State *L, int index);
```

Lua_tostring 函数返回一个指向字符串的内部拷贝的指针。像一个 **const**。只要这个指针对应的值还在栈内，Lua 会保证这个指针一直有效。当一个 C 函数返回后，Lua会清理它的栈，所以，有一个原则：永远不要将指向 Lua 字符串的指针保存到访问它的外部函数中。

```c
// 返回字符串的实际长度
size_t lua_strlen (lua_State *L, int index);
// 检查栈空间。默认有 20 个空闲的记录，lua.h 中的 LUA_MINSTACK 宏定义了这个常量
int lua_checkstack(lua_State *L, int sz);
// 返回栈中元素的类型
int lua_type (lua_State *L, int idx);
// 返回 type 对应的名字字符串，第二个参数为lua_type 返回的类型
const char* lua_typename(lua_State *L, int tp);
// 返回参数 arg 是否是类型 t，第三个参数为 lua_type 的取值
void luaL_checktype (lua_State *L, int arg, int t);
```

在 lua.h 头文件中，每种类型都被定义为一个常量：   
 - LUA_TNIL
 - LUA_TBOOLEAN
 - LUA_TNUMBER
 - LUA_TSTRING
 - LUA_TTABLE
 - LUA_TFUNCTION
 - LUA_TUSERDATA
 - LUA_TTHREAD

```c
// 返回栈中元素个数，它也是栈顶元素的索引
int lua_gettop (lua_State *L);
// 设置栈顶元素的索引，相当于设置栈的大小。如果开始的栈顶高于新的栈顶，顶部的值被丢弃。
// 否则，为了得到指定的大小这个函数压入相应个数的空值（nil）到栈上。
// lua_settop(L,0)：清空堆栈
void lua_settop (lua_State *L, int index);
// 宏定义，弹出 n 个元素
#define lua_pop(L,n) lua_settop(L, -(n)-1);
// 压入堆栈上指定索引的一个抟贝到栈顶，等于拷贝 index 处的元素，然后添加到栈顶
void lua_pushvalue (lua_State *L, int index);
// 移除指定索引的元素，并将其上面所有的元素下移来填补这个位置的空白
void lua_remove (lua_State *L, int index);
// 移动栈顶元素到指定索引的位置，并将这个索引位置上面的元素全部上移至栈顶被移动留下的空隔
void lua_insert (lua_State *L, int index);
// 从栈顶弹出元素值并将其设置到指定索引位置，没有任何移动操作
void lua_replace (lua_State *L, int index);
```

### Lua和C简单交互代码

```c
#include <stdio.h>
#include <string.h>
#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

int main(void){
  char buff[256];
  int error;
  // 打开 Lua,创建一个新环境(新的 Lua 状态)
  lua_State *L = luaL_newstate();
  // 打开标准库
  luaL_openlibs(L);   
  //接收用户输入lua代码, 并编译解析
  while(fgets(buff,sizeof(buff),stdin)!=NULL){
    // luaL_loadbuffer 编译 Lua 代码(没有错误则压入栈)，lua_pcall 执行
    error = luaL_loadbuffer(L,buff,strlen(buff),"line")||lua_pcall(L,0,0,0);
    if(error){
      //执行或编译错误lua_tostring打印错误信息
      fprintf(stderr,"%s\n",lua_tostring(L,-1));
        // 从栈中弹出错误消息
        lua_pop(L,1);  
    }
  }
  lua_close(L);//关闭lua状态
  return 0;
}
```

## 编译代码

```sh
gcc -lm -g -o testlua testlua.c /usr/local/lib/liblua.a -ldl
```

### GCC 常用参数

|参数	|功能|
|:---|:---|
|-c|编译但不连结，只产生 .o 档|
|-o <font color="#FF1000">filename</font>|<font color="#FF1000">filename</font> 为指定输出档名|
|-l<font color="#FF1000">library</font>|指定连结的函式库， lib<font color="#FF1000">library</font> 为加载函式库名称。注意是小寫 **L**。|
|-I|增加 include 头文件档案的搜寻路径。注意是大寫 **i**。|
|-L|增加 library 函式库档案的搜寻路径|
|-W<font color="#FF1000">all</font>|	显示所有的警告讯息|
|-O[0-3]|指定优化级别，其中 0 表示无优化，3 表示积极优化|
|-g|编入除错资讯 (使用 GDB 除错时用)|
|-ansi|只支持 ANSI 标准的 C 语法。 这一选项将禁止 GNU C 的某些特色 例如 asm 或 typeof 关键词|

用 **-l** 参数将库加入。库命名是一致的，一般为 libxxx.so，或 libxxx.a，libxxx.la，那么要链接某个库就用 -lxxx，去掉头 lib 及 "." 后面的 so，la，a 等即可。 因为数学函数位于 libm.so 库文件中（通常在 /lib 目录下），-lm 选项告诉编译器，程序中用到的数学函数要到这个库文件里找。同时，常见的库链接方法为： 

数学库
 - -lc 是关联到 libc
 - -lm 是关联到 libm
 - -lz 是关联到 libz
 - -ldl 是关联到 libdl

用 **-ldl**，是显式加载动态库的动态函数库。基本定义在 IEEE Std 1003.1-2001, <dlfcn.h>。动态库的相关部分如下：

```c
#include <dlfcn.h>
  dlopen();
  dlclose();
  dlerror(); 
  dlsym();
```

# Lua 指令编码格式

Lua 虚拟机指令可以分为五类，分别对应五种编码模式，大部分指令编码格式都是 iABC 模式。

|版本|格式名称|操作数|格式位数|操作码位数|
|:---:|:---:|:---:|:---:|:---:|
|5.3|iABC|3|9，9，8|6|
|5.3|iABx|2|18，8|6|
|5.3|iAsBx|2|18，8|6|
|5.3|iAx|1|26|6|
|5.4|iABC|3|8，8，8|7|
|5.4|iABx|2|17,，8|7|
|5.4|iAsBx|2|17，8|7|
|5.4|iAx|1|25|7|
|5.4|isJ|1|25|7|

编码名解释
 - i 应该是指令 (instruction)
 - A、B、C 是三个参数的基本名称 (无符号整数)
 - x (例如 B<font color="#FF1000">x</font>) 是扩展 (extended) 表示该参数的长度会被扩展
 - s (例如 <font color="#FF1000">s</font>Bx) 是符号 (signed) 表示该参应为有符号整数

Lua 5.3 操作码占用低 <font color="#FF1000">6</font> 位，其余高 28 位可以编码 1 到 3 个参数（以及一个标志位）。因此 Lua 5.3 指令集最多只能包含 **64** 条指令，定义了 **47** 条。

Lua 5.4 虚拟机指令集改动较大，增加了许多新的指令，因 6 比特操作码不够用，所以改为 <font color="#FF1000">7</font> 位，其余 27 位可以编码 1 到 3 个参数（以及一个标志位）。因此 Lua 5.4 指令集最多只能包含 **128** 条指令，定义了 **83** 条。


## 元表 与 元方法

Lua 中，**元表**（metatable）是一种特殊的表，用于定义表的行为，而 **元方法** (metamethod) 是定义在元表中的特殊函数，用于重载或改变特定操作的行为。它允许自定义的元方法来改变表的行为，实现更加灵活和强大的功能。通过元表和元方法，可以实现运算符重载、索引操作的自定义、以及其他各种高级特性。

**元表**（Metatable）

 - 概念：元表可以看作是其他表的“属性”，它定义了当对该表执行特定操作时应该如何处理。
 - 作用：通过元表，可以改变Lua中表的默认行为，例如算术运算、索引、函数调用等。
 - 设置：setmetatable(table, metatable) 函数用于将一个元表关联到一个表上。
 - 获取：getmetatable(table) 函数可以获取一个表的元表。


**元方法**（Metamethod）

 - 概念：元方法是定义在元表中的函数，用于处理特定操作。
 - 命名: 元方法通常以双下划线"__" 开头。
 - 作用：当对一个表执行特定操作时，如果该表有元表，并且元表中定义了相应的元方法，那么 Lua 就会调用这个元方法来处理该操作。 

常用元方法:

|方法名称|用途|
|:---:|:---|
|__add|用于重载加法运算符 +|
|__sub|用于重载减法运算符 -|
|__mul|用于重载乘法运算符 *| 
|__div|用于重载除法运算符 /| 
|__unm|用于重载一元负号运算符 -|
|__concat|用于重载字符串连接运算符 ... |
|__eq|用于重载等于运算符 ==|
|__lt|用于重载小于运算符 <|
|__le|用于重载小于等于运算符 <=|
|__index|用于重载表的索引操作，当访问表中不存在的键时调用|
|__newindex|用于重载表的赋值操作，当对表中不存在的键进行赋值时调用|
|__call|用于重载函数调用操作，当对一个值进行函数调用时调用|
|__tostring|用于重载 tostring 函数，当将一个值转换为字符串时调用|

元表及元方法示例：

```lua
local myTable = {}
local myMetatable = {
  __index = function(table, key)
    print("访问不存在的键:", key)
    return nil
  end,
  __add = function(a, b)
    print("执行加法运算:", a, b)
    return a + b
  end
}

setmetatable(myTable, myMetatable)

myTable[1] = 10
print(myTable[1])       
-- 输出: 10
print(myTable[2])       
-- 输出: nil  (触发__index)

local result = myTable + 5  
-- 触发__add
print(result)           
-- 输出: 15
```

## rawset 与 rawget

rawset/rawget：对 “原始的” 表进行直接的赋值/取值操作。raw 方法就是忽略 table 对应的 metatable，绕过 metatable 的行为约束，强制对原始表进行一次原始的操作，也就是一次不考虑元表的简单更新。另外，一次原始的操作其实并不会加速代码执行的速度，效率一样。

当操作table时，如果有以下需求：

 - rawget(table, key)：访问时，不想从 __index 对应的元方法中查询值。
 - rawset(table, key, value)：更新时，不想执行 __newindex 对应的元方法
在 __newindex 元方法中，设置 table 的 key /value 时，不想陷入死循环，可以考虑使用 raw 方法。

## Lua 数据类型

|数据类型|	描述|
|:---:|:---|
|nil|	这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）|
|boolean	|包含两个值：false和true|
|number|	表示双精度类型的实浮点数|
|string|	字符串由一对双引号或单引号来表示|
|function|由 C 或 Lua 编写的函数|
|userdata|	表示任意存储在变量中的C数据结构|
|thread|	表示执行的独立线路，用于执行协同程序|
|table|	其实是一个 **关联数组**（associative arrays），数组的索引可以是数字、字符串或表类型。table 的创建是通过 **构造表达式** 来完成，最简单构造表达式是 {}，用来创建一个空表|

## Lua 的保留关键字

保留关键字不能作为常量或变量或其他用户自定义标示符：

### 变量
 - local：显式声明为局部变量
 - nil：表示一个无效值(在条件表达式中相当于false)。

### 逻辑
 - and
 - or
 - not
 - true
 - false

### 迭代器
 - for > in > do > end

```lua
for k, v in pairs(t) do
    print(k, v)
end
```
### 循环
 
 - if > then > elseif > else > end

```lua
if(a == 10) then
  print("a 的值为 10")
  elseif(a == 20) then  
    print("a 的值为 20")
    else
      print("没有匹配 a 的值")
end
```
 - until > repeat:重复执行循环，直到指定的条件为真时为止

```lua
repeat
  print("a的值为:", a)
  a = a + 1
until( a > 15 )
```

 - while > do > end：在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true

```lua
while(a < 20) do
  print("a 的值为:", a)
  a = a + 1
end
```

 - for > do > end：重复执行指定语句，重复次数可在 for 语句中控制

```lua
for i=10,1,-1 do
  print(i)
end
```

### 中断

 - break：退出当前循环或语句，并开始脚本执行紧接着的语句

```lua
while(a < 20) do
  print("a 的值为:", a)
  a = a + 1
  if(a > 15) then
  --[ 使用 break 语句终止循环 --]
    break
  end
end
```

 - goto：将程序的控制点转移到一个标签处

```lua
for i=1, 3 do
  if i <= 2 then
    print(i, "yes continue")
      goto continue
  end
  print(i, " no continue")
::continue::
  print([[i'm end]])
end
```

### 函数

 - function：由 C 或 Lua 编写的函数
 - return

```lua
function maximum (a)
  local mi = 1     -- 最大值索引
  local m = a[mi]  -- 最大值
  for i,val in ipairs(a) do
    if val > m then
      mi = i
      m = val
    end
  end
  return m, mi
end
```