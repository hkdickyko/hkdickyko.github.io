---
category: [動畫]
tags: [電子]
title: Matter.js (基礎技巧)
date: 2022-12-15 1:00:00
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
    text-align: center;
  }
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
    overflow:hidden;
  }
</style>

# Matter.JS

matter.js 是由 JavaScript 撰寫的物理引擎，透過瀏覽器上模擬物理反應，可輕易調整物體重量、質量、速度，甚至是密度、摩擦力等等變量，非常適合用在需要呈現 2D 物理效果。

## 通用模組

matter.js 的 API 定義的很易懂有 

 - World
 - Body
 - Constraint

這是使用 matter.js 所需要的基礎元件。

> ### World
> 透過此模組來創建一個模擬世界，可以微調世界中的一些屬性，像是重力、邊界等。

> ### Bodies
> 提供方法去生成一些物體，像是圓形物體、方形物體等等，你也可以傳入 svg、img 去客製化物體形狀與樣式。產生的物體放入 World 中後就可以被 render 在畫面上。

> ### Body
> 利用 Bodies 產生的物件可以利用 Body 模組來進行進一步的操控。透過 Body 可以旋轉、縮放、位移物體，也可以更改物體本身的密度、速度等等。用來調整物體的物理特性。

> ### Engine
> 引擎是驅動整個模擬物理世界的動力，根據 Body 的物理性質來精準掌控 World 內 Body 彼此間的物理現象，確保能模擬出符合設定的反應。是 matter.js 的核心。

> ### Render
>  一個 Canvas based 的 Renderer，能將 Engine 的結果繪製出來，這個內建的 Render 模組主要是用在開發與除錯上，但對於簡單的動畫或遊戲，還是可以。另外要注意的是，該模組預設只會繪製出 wirefram 與向量，你要主動將 render.options.wireframes 設為 false。所以一般要獨立制作 Render 使用。

> ### Composites
> 模組像 Bodies 模組，差別在於 Bodies 模組創建出 ”一個“ 物體，而 Composites 提供方法創建出多個物體所組合而成的物體，像是 Stack、Pyramid 或甚至是 Car, Chain 等等。

> ### Composite
> Composite 就是對應於 Composites 的模組，讓你控制由 Composites 創建出的組合物體的物理特性。

> ### Constraint
> Constraint 模組能為兩個物體之間增加物理限制，像是兩物體一定要間隔一定距離等等。像是 Newton's Cradle等等。

> ### MouseConstraint
> 這模組增加滑鼠與物體之間的”約束”，透過建立物體與滑鼠的限制，可以透過滑鼠與創建的物體互動。

## 例子

``` js
const World = Matter.World;
const Bodies = Matter.Bodies;
const Body = Matter.Body;
const Engine = Matter.Engine;
const Render = Matter.Render;
const Composites = Matter.Composites;

// 創建引擎
const engine = Engine.create();
const world = engine.world;

// 創建渲染器
const render = Render.create({
  element: document.body,
  engine: engine,
  options: {
    width: 920,
    height: 600,
  }
});

(function run() {
  window.requestAnimationFrame(run);
  Engine.update(engine, 1000 / 60);
})();

Engine.run(engine);
Render.run(render);

```





