---
category: [動畫]
tags: [電子]
title: Matter.js (基礎技巧)
date: 2022-12-15 1:00:00
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
    text-align: center;
  }
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
  iframe{
    width: 100%;
    display: block;
    border-style:none;
    overflow:hidden;
  }
</style>
<script>
function setFrame(id, src){
document.getElementById(id).src="../assets/html/" + src;
}

function basic(){
setFrame("basic","matter/basic.html");
}
</script>


# Matter.JS

matter.js 是由 JavaScript 撰寫的物理引擎，透過瀏覽器上模擬物理反應，可輕易調整物體重量、質量、速度，甚至是密度、摩擦力等等變量，非常適合用在需要呈現 2D 物理效果。

## 通用模組

matter.js 的 API 定義的很易懂有 

 - World
 - Body
 - Constraint

這是使用 matter.js 所需要的基礎元件。

> ### World
> 透過此模組來創建一個模擬世界，可以微調世界中的一些屬性，像是重力、邊界等。

> ### Bodies
> 提供方法去生成一些物體，像是圓形物體、方形物體等等，你也可以傳入 svg、img 去客製化物體形狀與樣式。產生的物體放入 World 中後就可以被 render 在畫面上。

> ### Body
> 利用 Bodies 產生的物件可以利用 Body 模組來進行進一步的操控。透過 Body 可以旋轉、縮放、位移物體，也可以更改物體本身的密度、速度等等。用來調整物體的物理特性。

> ### Engine
> 引擎是驅動整個模擬物理世界的動力，根據 Body 的物理性質來精準掌控 World 內 Body 彼此間的物理現象，確保能模擬出符合設定的反應。是 matter.js 的核心。

> ### Render
>  一個 Canvas based 的 Renderer，能將 Engine 的結果繪製出來，這個內建的 Render 模組主要是用在開發與除錯上，但對於簡單的動畫或遊戲，還是可以。另外要注意的是，該模組預設只會繪製出 wirefram 與向量，你要主動將 render.options.wireframes 設為 false。所以一般要獨立制作 Render 使用。

> ### Composites
> 模組像 Bodies 模組，差別在於 Bodies 模組創建出 ”一個“ 物體，而 Composites 提供方法創建出多個物體所組合而成的物體，像是 Stack、Pyramid 或甚至是 Car, Chain 等等。

> ### Composite
> Composite 就是對應於 Composites 的模組，讓你控制由 Composites 創建出的組合物體的物理特性。

> ### Constraint
> Constraint 模組能為兩個物體之間增加物理限制，像是兩物體一定要間隔一定距離等等。像是 Newton's Cradle等等。

> ### MouseConstraint
> 這模組增加滑鼠與物體之間的”約束”，透過建立物體與滑鼠的限制，可以透過滑鼠與創建的物體互動。


## 例子

``` js
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <script src="./build/matter.min.js"></script>
    <style>
      body {
        background-color: white;
      }
    </style>
    <script>
      document.addEventListener(
        "DOMContentLoaded",
        function () {
          const World = Matter.World;
          const Bodies = Matter.Bodies;
          const Body = Matter.Body;
          const Engine = Matter.Engine;
          const Render = Matter.Render;
          const Runner = Matter.Runner;
          const Composites = Matter.Composites;
          const Composite = Matter.Composite;
          // 創建引擎 Engine 是整個 Matter.js 世界中的主宰，控制整個世界的模擬與更新。
          const engine = Engine.create();
          const world = engine.world;
          // 創建渲染器 Render 將 Engine 運算的結果以 Canvas 顯示出來，提供邏輯處理與顯示的相關模組。
          const render = Render.create({
            element: document.body,
            engine: engine,
            options:{
              wireframes: false,
              background: 'rgb(255,255,255)'
            }
          });
          //  Rectangle 是在創建方形，基本上就是帶入位置、大小參數，以及以一些設置可選選項(如isStatic)等等。
          var boxA = Bodies.rectangle(400, 200, 80, 80);
          var boxB = Bodies.rectangle(450, 50, 80, 80);
          var ground = Bodies.rectangle(400, 610, 810, 60, { isStatic: true });
          // Composite 是一個組合的動作，把我們上面宣告的方形加入 world ，也就是engine中的世界。
          Composite.add(world, [boxA, boxB, ground]);
          // 運行渲染器 Render.run 會決定持續更新並渲染 Canvas 的幀數。
          Render.run(render);
          // 創建 Runner 持續更新 engine 中邏輯的相關資訊。
          var runner = Runner.create();
          // 最後 Runner.run 把上面的設置整個跑起來。
          Runner.run(runner, engine);
        },
        false
      );
    </script>
  </head>
  <body></body>
</html>
```

<div>
<button onclick="basic()">點擊測試</button>
<iframe id="basic" height="300px"></iframe>
</div>




