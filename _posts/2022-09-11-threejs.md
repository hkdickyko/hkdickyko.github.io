---
category: [動畫]
tags: [電子]
title: Three.js
date: 2022-09-10 1:00:00
---

<style>
  table {
    width: 100%
    }
  td {
    vertical-align: center;
    text-align: center;
  }
  table.inputT{
    margin: 10px;
    width: auto;
    margin-left: auto;
    margin-right: auto;
    border: none;
  }
  input{
    text-align: center;
    padding: 0px 10px;
  }
</style>

# Three.js

Three.js 是一個 JavaScript 函數庫用於開發 WebGL，它封裝成物件導向的方法和屬性，可以使用物件導向的方法在網絡瀏覽器下開發 3D 模式繪製空間。

[互聯網資源](https://github.com/mrdoob/three.js/)

## 繪製基本流程

- 建立基本框架
- 建立場景
- 建立相機
- 建立模型
- 建立材質
- 建立繪製器
- 渲染場景

Three.js 提供兩種繪製器：
  - WebGLRenderer: WebGLRenderingContext2D 實現 GPU 加速的 3D 和 2D 繪圖
  - CanvasRenderer: CanvasRenderingContext2D 實現 2D 繪圖

在特定情況下，CanvasRenderer 也可以使用 *2D* 環境模擬出 *3D* 效果，但並非所有 *3D* 功能，因此 *3D* 處理建議使用 WebGLRender。如果瀏覽器不支援 WebGLRenderingContext，而要實現的 3D 影像剛好又不需要材質和光源，此時就可以使用 CanvasRenderer。

```js
// 如果瀏覽器支援 WebGLRenderingContext 就使用 WebGLRenderer
if(window.WebGLRenderingContext){
  renderer = new THREE.WebGLRenderer();
}else{
  renderer = new THREE.CanvasRenderer();
}
```
## 建立基本框架

- 開始使用 Three.js之前，需要一個地方來顯示它。下列基本 *HTML* 框架保存為一個HTML文件，同時將 *three.js* 複製到該 *HTML* 文件所在的目錄下的 *js/* 目錄下，然後在瀏覽器中打開這個HTML文件。

```js
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>網絡編程標題</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script>
			// Javascript 將放在這裡
		</script>
	</body>
</html>
```

## 建立場景

 - 場景可以放置 **模型** , **光源** 和 **相機**，然後繪製器根據這些進行繪製，相機在建立後自動增加到場景中，但模型和光源必須使用 add() 方法增加。

```js
// 建立場景
const scene = new THREE.Scene();
// 在場景中創建網格
var grid = new THREE.GridHelper(100, 10);
scene.add(grid);
//建立一個點光源增加到場景中
var light = new THREE.PointLight(0xffff00, 1, 100);
  light.position.set(100, 100, 100);
scene.add(light);
```

### 檢查建立物件

 - 任何物件再加入到場景中，都會加入到 Scene 的 children 屬性陣列，可用來檢查所有物件：

```js
//檢查場景中的所有物件
for(var i = 0, l = scene.children.length; i < l; i++){
   ...
}
```
## 建立相機

 - 相機就是觀察點，有兩種類型，都繼承自 Camera 類別：
   - 透視投影相機（PerspectiveCamera）
   - 正交投影相機（OrthographicCamera）

### 透視投影相機

從建構方法來看，PerspectiveCamera 參數都可以省略(因有預設值)。

  THREE.PerspectiveCamera(fov, aspect, near, far);

 - FOV 視野角度就是無論在什麼時候，你所能在顯示器上看到的場景的範圍，它的單位是角度(與弧度區分開)。
 - aspect ratio 長寬比也就是用一個物體的寬除以它的高的值。
 - near 近截面 當物體某些部分比攝像機的遠截面遠或者比近截面近的時候，該這些部分將不會被渲染到場景中。或許不用擔心這個值的影響，但為了獲得更好的渲染性能，將可以在應用程序裡去設置它。
 - far 遠截面 當物體某些部分比攝像機的遠截面遠或者比近截面近的時候，該這些部分將不會被渲染到場景中。或許不用擔心這個值的影響，但為了獲得更好的渲染性能，將可以在應用程序裡去設置它。

### 正交投影相機

只有後兩個參數可以省略,只有後兩個參數可以省略(因有預設值)。

  THREE.OrthographicCamera(left, right, top, bottom, near, far);


### 增加觀察矩

可使用 Camera 增加觀察矩, Camera的 lookAt() 方法:

  Camera.lookAt(vector);

vector 表示焦點的位置，可透過建立相機後設定屬性 position (眼睛位置) 和 up (相機朝向)：

```js
camera = new THREE.PerspectiveCamera(55, 640/480, 1, 10000);
camera.position.z = 1000;
//改變相機的朝向，這裡設定倒置相機
camera.up.y = -1;
//看向右上方
camera.lookAt(new THREE.Vector3(320, 240, 0));
```

## 渲染場景

為了簡化流程，先解釋渲染場景，然後創建要渲染的對象 現在將寫好的代碼複製到 *HTML* 文件中，你不會在頁面中看到任何東西。這是因為還沒有對它進行真正的渲染。為此需要使用一個被叫做“渲染循環”（render loop）或者“動畫循環”（animate loop）。在這創建了一個使渲染器能夠在每次屏幕刷新時對場景進行繪製的循環（在大多數屏幕上，刷新率一般是 *60* 次/秒）。

```js
function animate() {
	requestAnimationFrame( animate );
	renderer.render( scene, camera );
}
animate();
```

## 建立材質

```js
material = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true});
```
